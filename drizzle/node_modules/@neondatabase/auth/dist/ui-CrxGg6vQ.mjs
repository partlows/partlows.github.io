'use client';
import { a as getLocalizedError, c as getViewByPath, i as cn, l as isValidEmail, n as authLocalization, o as getPasswordSchema, r as authViewPaths, s as getSearchParam, t as accountViewPaths, u as organizationViewPaths } from "./chunk-VCZJYX65-CLnrj1o7-D6ZQkcc_.mjs";
import * as z$1 from "zod";
import { clsx } from "clsx";
import { twMerge } from "tailwind-merge";
import * as React from "react";
import { Fragment, createContext, useCallback, useContext, useEffect, useMemo, useRef, useState, useSyncExternalStore } from "react";
import { Toaster, toast } from "sonner";
import { GoogleReCaptchaProvider, useGoogleReCaptcha } from "@wojtekmaj/react-recaptcha-v3";
import { Fragment as Fragment$1, jsx, jsxs } from "react/jsx-runtime";
import { Archive, ArrowLeftIcon, BuildingIcon, CheckIcon, ChevronDownIcon, ChevronUpIcon, ChevronsUpDown, CopyIcon, Edit, EllipsisIcon, EyeIcon, EyeOffIcon, FingerprintIcon, KeyRoundIcon, LaptopIcon, Loader2, LockIcon, LogInIcon, LogOutIcon, MailIcon, MenuIcon, MinusIcon, PlusCircleIcon, QrCodeIcon, RepeatIcon, SendIcon, SettingsIcon, SmartphoneIcon, Trash2Icon, UploadCloudIcon, UserCogIcon, UserRoundIcon, UserRoundPlus, UserX2Icon, UserXIcon, UsersIcon, XIcon } from "lucide-react";
import { Controller, FormProvider, useForm, useFormContext, useFormState } from "react-hook-form";
import { Slot } from "@radix-ui/react-slot";
import { cva } from "class-variance-authority";
import { zodResolver } from "@hookform/resolvers/zod";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import * as LabelPrimitive from "@radix-ui/react-label";
import * as AvatarPrimitive from "@radix-ui/react-avatar";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import * as SelectPrimitive from "@radix-ui/react-select";
import { UAParser } from "ua-parser-js";
import { Drawer } from "vaul";
import { CaptchaFox } from "@captchafox/react";
import HCaptcha from "@hcaptcha/react-hcaptcha";
import { Turnstile } from "@marsidev/react-turnstile";
import ReCAPTCHA from "react-google-recaptcha";
import { OTPInput, OTPInputContext } from "input-otp";
import QRCode from "react-qr-code";
import * as SeparatorPrimitive from "@radix-ui/react-separator";
import { ThemeProvider, useTheme } from "next-themes";

//#region ../auth-ui/dist/index.mjs
var AuthDataCache = class {
	cache = /* @__PURE__ */ new Map();
	listeners = /* @__PURE__ */ new Map();
	inFlightRequests = /* @__PURE__ */ new Map();
	get(key) {
		return this.cache.get(key);
	}
	set(key, data) {
		const entry = {
			data,
			timestamp: Date.now(),
			isRefetching: false
		};
		this.cache.set(key, entry);
		this.notify(key);
	}
	setRefetching(key, isRefetching) {
		const entry = this.cache.get(key);
		if (entry) {
			entry.isRefetching = isRefetching;
			this.notify(key);
		}
	}
	clear(key) {
		if (key) {
			this.cache.delete(key);
			this.inFlightRequests.delete(key);
			this.notify(key);
		} else {
			this.cache.clear();
			this.inFlightRequests.clear();
			const keys = Array.from(this.listeners.keys());
			for (const key2 of keys) this.notify(key2);
		}
	}
	getInFlightRequest(key) {
		return this.inFlightRequests.get(key);
	}
	setInFlightRequest(key, promise) {
		this.inFlightRequests.set(key, promise);
	}
	removeInFlightRequest(key) {
		this.inFlightRequests.delete(key);
	}
	subscribe(key, callback) {
		if (!this.listeners.has(key)) this.listeners.set(key, /* @__PURE__ */ new Set());
		this.listeners.get(key).add(callback);
		return () => {
			const callbacks = this.listeners.get(key);
			if (callbacks) {
				callbacks.delete(callback);
				if (callbacks.size === 0) this.listeners.delete(key);
			}
		};
	}
	notify(key) {
		const callbacks = this.listeners.get(key);
		if (callbacks) {
			const callbackArray = Array.from(callbacks);
			for (const callback of callbackArray) callback();
		}
	}
};
var authDataCache = new AuthDataCache();
function subscribe() {
	return () => {};
}
function useIsHydrated() {
	return useSyncExternalStore(subscribe, () => true, () => false);
}
function useLang() {
	const [lang, setLang] = useState();
	useEffect(() => {
		const checkLang = () => {
			setLang(document.documentElement.getAttribute("lang") ?? void 0);
		};
		checkLang();
		const observer = new MutationObserver((mutations) => {
			for (const mutation of mutations) if (mutation.attributeName === "lang") checkLang();
		});
		observer.observe(document.documentElement, { attributes: true });
		return () => {
			observer.disconnect();
		};
	}, []);
	return { lang };
}
function useTheme$1() {
	const [theme, setTheme] = useState("light");
	useEffect(() => {
		const checkTheme = () => {
			var _a;
			setTheme(document.documentElement.classList.contains("dark") || ((_a = document.documentElement.getAttribute("style")) == null ? void 0 : _a.includes("color-scheme: dark")) ? "dark" : "light");
		};
		checkTheme();
		const observer = new MutationObserver((mutations) => {
			for (const mutation of mutations) if (mutation.attributeName === "style" || mutation.attributeName === "class") checkTheme();
		});
		observer.observe(document.documentElement, { attributes: true });
		return () => {
			observer.disconnect();
		};
	}, []);
	return { theme };
}
function RecaptchaV3({ children }) {
	const isHydrated = useIsHydrated();
	const { captcha } = useContext(AuthUIContext);
	if ((captcha == null ? void 0 : captcha.provider) !== "google-recaptcha-v3") return children;
	return /* @__PURE__ */ jsxs(GoogleReCaptchaProvider, {
		reCaptchaKey: captcha.siteKey,
		useEnterprise: captcha.enterprise,
		useRecaptchaNet: captcha.recaptchaNet,
		children: [
			isHydrated && /* @__PURE__ */ jsx("style", { children: `
                    .grecaptcha-badge {
                        visibility: hidden;
                        border-radius: var(--radius) !important;
                        --tw-shadow: 0 1px 2px 0 var(--tw-shadow-color, #0000000d);
                        box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow) !important;
                        border-style: var(--tw-border-style) !important;
                        border-width: 1px;
                    }

                    .dark .grecaptcha-badge {
                        border-color: var(--input) !important;
                    }
                ` }),
			/* @__PURE__ */ jsx(RecaptchaV3Style, {}),
			children
		]
	});
}
function RecaptchaV3Style() {
	const { executeRecaptcha } = useGoogleReCaptcha();
	const { theme } = useTheme$1();
	const { lang } = useLang();
	useEffect(() => {
		if (!executeRecaptcha) return;
		const updateRecaptcha = async () => {
			const iframe = document.querySelector("iframe[title='reCAPTCHA']");
			if (iframe) {
				const iframeSrcUrl = new URL(iframe.src);
				iframeSrcUrl.searchParams.set("theme", theme);
				if (lang) iframeSrcUrl.searchParams.set("hl", lang);
				iframe.src = iframeSrcUrl.toString();
			}
		};
		updateRecaptcha();
	}, [
		executeRecaptcha,
		theme,
		lang
	]);
	return null;
}
function useCurrentOrganization({ slug: slugProp } = {}) {
	const { organization: organizationOptions, hooks: { useActiveOrganization, useListOrganizations } } = useContext(AuthUIContext);
	const { pathMode, slug: contextSlug } = organizationOptions || {};
	let data;
	let isPending;
	let isRefetching;
	let refetch;
	const { data: organizations, isPending: organizationsPending, isRefetching: organizationsRefetching } = useListOrganizations();
	if (pathMode === "slug") {
		const slug = slugProp || contextSlug;
		data = organizations == null ? void 0 : organizations.find((organization) => organization.slug === slug);
		isPending = organizationsPending;
		isRefetching = organizationsRefetching;
	} else {
		const { data: activeOrganization, isPending: organizationPending, isRefetching: organizationRefetching, refetch: refetchOrganization } = useActiveOrganization();
		refetch = refetchOrganization;
		data = activeOrganization;
		isPending = organizationPending;
		isRefetching = organizationRefetching;
	}
	return useMemo(() => ({
		data,
		isPending,
		isRefetching,
		refetch
	}), [
		data,
		isPending,
		isRefetching,
		refetch
	]);
}
var OrganizationRefetcher = () => {
	const { hooks: { useListOrganizations, useSession }, organization: organizationOptions, navigate, redirectTo } = useContext(AuthUIContext);
	const { slug, pathMode, personalPath } = organizationOptions || {};
	const { data: sessionData } = useSession();
	const { data: organization, isPending: organizationPending, isRefetching: organizationRefetching, refetch: refetchOrganization } = useCurrentOrganization();
	const { refetch: refetchListOrganizations } = useListOrganizations();
	const { data: organizations } = useListOrganizations();
	useEffect(() => {
		if (!(sessionData == null ? void 0 : sessionData.user.id)) return;
		if (organization || organizations) {
			refetchOrganization?.();
			refetchListOrganizations?.();
		}
	}, [sessionData == null ? void 0 : sessionData.user.id]);
	useEffect(() => {
		if (organizationRefetching || organizationPending) return;
		if (slug && pathMode === "slug" && !organization) navigate(personalPath || redirectTo);
	}, [
		organization,
		organizationRefetching,
		organizationPending,
		slug,
		pathMode,
		personalPath,
		navigate,
		redirectTo
	]);
	return null;
};
var DefaultLink = ({ href, className, children }) => /* @__PURE__ */ jsx("a", {
	className,
	href,
	children
});
var defaultNavigate = (href) => {
	window.location.href = href;
};
var defaultReplace = (href) => {
	window.location.replace(href);
};
var defaultToast = ({ variant = "default", message }) => {
	if (variant === "default") toast(message);
	else toast[variant](message);
};
var AuthUIContext = createContext({});
var AuthUIProvider = ({ children, authClient: authClientProp, account: accountProp, avatar: avatarProp, deleteUser: deleteUserProp, social: socialProp, genericOAuth: genericOAuthProp, basePath = "/auth", baseURL = "", captcha, redirectTo = "/", credentials: credentialsProp, changeEmail = true, freshAge = 3600 * 24, hooks: hooksProp, mutators: mutatorsProp, localization: localizationProp, localizeErrors = true, nameRequired = true, organization: organizationProp, teams: teamsProp, signUp: signUpProp = true, toast: toast2 = defaultToast, viewPaths: viewPathsProp, navigate, replace, Link = DefaultLink, ...props }) => {
	const authClient$1 = authClientProp;
	const avatar = useMemo(() => {
		if (!avatarProp) return;
		if (avatarProp === true) return {
			extension: "png",
			size: 128
		};
		return {
			upload: avatarProp.upload,
			delete: avatarProp.delete,
			extension: avatarProp.extension || "png",
			size: avatarProp.size || (avatarProp.upload ? 256 : 128),
			Image: avatarProp.Image
		};
	}, [avatarProp]);
	const account = useMemo(() => {
		var _a;
		if (accountProp === false) return;
		if (accountProp === true || accountProp === void 0) return {
			basePath: "/account",
			fields: ["image", "name"],
			viewPaths: accountViewPaths
		};
		return {
			basePath: (((_a = accountProp.basePath) == null ? void 0 : _a.endsWith("/")) ? accountProp.basePath.slice(0, -1) : accountProp.basePath) ?? "/account",
			fields: accountProp.fields || ["image", "name"],
			viewPaths: {
				...accountViewPaths,
				...accountProp.viewPaths
			}
		};
	}, [accountProp]);
	const deleteUser = useMemo(() => {
		if (!deleteUserProp) return;
		if (deleteUserProp === true) return {};
		return deleteUserProp;
	}, [deleteUserProp]);
	const social = useMemo(() => {
		if (!socialProp) return;
		return socialProp;
	}, [socialProp]);
	const genericOAuth = useMemo(() => {
		if (!genericOAuthProp) return;
		return genericOAuthProp;
	}, [genericOAuthProp]);
	const credentials = useMemo(() => {
		if (credentialsProp === false) return;
		if (credentialsProp === true) return {
			forgotPassword: true,
			usernameRequired: true
		};
		return {
			...credentialsProp,
			forgotPassword: (credentialsProp == null ? void 0 : credentialsProp.forgotPassword) ?? true,
			usernameRequired: (credentialsProp == null ? void 0 : credentialsProp.usernameRequired) ?? true
		};
	}, [credentialsProp]);
	const signUp = useMemo(() => {
		if (signUpProp === false) return;
		if (signUpProp === true || signUpProp === void 0) return { fields: ["name"] };
		return { fields: signUpProp.fields || ["name"] };
	}, [signUpProp]);
	const organization = useMemo(() => {
		var _a;
		if (!organizationProp) return;
		if (organizationProp === true) return {
			basePath: "/organization",
			viewPaths: organizationViewPaths,
			customRoles: []
		};
		let logo;
		if (organizationProp.logo === true) logo = {
			extension: "png",
			size: 128
		};
		else if (organizationProp.logo) logo = {
			upload: organizationProp.logo.upload,
			delete: organizationProp.logo.delete,
			extension: organizationProp.logo.extension || "png",
			size: organizationProp.logo.size || (organizationProp.logo.upload ? 256 : 128)
		};
		const basePath2 = ((_a = organizationProp.basePath) == null ? void 0 : _a.endsWith("/")) ? organizationProp.basePath.slice(0, -1) : organizationProp.basePath;
		return {
			...organizationProp,
			logo,
			basePath: basePath2 ?? "/organization",
			customRoles: organizationProp.customRoles || [],
			viewPaths: {
				...organizationViewPaths,
				...organizationProp.viewPaths
			}
		};
	}, [organizationProp]);
	const teams = useMemo(() => {
		var _a, _b;
		if (!teamsProp || !organization) return;
		if (teamsProp === true) return {
			enabled: true,
			customRoles: [],
			colors: {
				count: 5,
				prefix: "team"
			}
		};
		return {
			enabled: teamsProp.enabled ?? true,
			customRoles: teamsProp.customRoles || [],
			colors: {
				count: ((_a = teamsProp.colors) == null ? void 0 : _a.count) ?? 5,
				prefix: ((_b = teamsProp.colors) == null ? void 0 : _b.prefix) ?? "team"
			}
		};
	}, [teamsProp, organization]);
	const defaultMutators = useMemo(() => {
		return {
			deleteApiKey: (params) => authClient$1.apiKey.delete({
				...params,
				fetchOptions: { throw: true }
			}),
			deletePasskey: (params) => authClient$1.passkey.deletePasskey({
				...params,
				fetchOptions: { throw: true }
			}),
			revokeDeviceSession: (params) => authClient$1.multiSession.revoke({
				...params,
				fetchOptions: { throw: true }
			}),
			revokeSession: (params) => authClient$1.revokeSession({
				...params,
				fetchOptions: { throw: true }
			}),
			setActiveSession: (params) => authClient$1.multiSession.setActive({
				...params,
				fetchOptions: { throw: true }
			}),
			updateOrganization: (params) => authClient$1.organization.update({
				...params,
				fetchOptions: { throw: true }
			}),
			updateTeam: (params) => authClient$1.$fetch("/organization/update-team", {
				method: "POST",
				body: params,
				throw: true
			}),
			updateUser: (params) => authClient$1.updateUser({
				...params,
				fetchOptions: { throw: true }
			}),
			unlinkAccount: (params) => authClient$1.unlinkAccount({
				...params,
				fetchOptions: { throw: true }
			})
		};
	}, [authClient$1]);
	const defaultHooks = useMemo(() => {
		return {
			useSession: authClient$1.useSession,
			useListAccounts: () => useAuthData({
				queryFn: authClient$1.listAccounts,
				cacheKey: "listAccounts"
			}),
			useAccountInfo: (params) => useAuthData({
				queryFn: () => authClient$1.accountInfo(params),
				cacheKey: `accountInfo:${JSON.stringify(params)}`
			}),
			useListDeviceSessions: () => useAuthData({
				queryFn: authClient$1.multiSession.listDeviceSessions,
				cacheKey: "listDeviceSessions"
			}),
			useListSessions: () => useAuthData({
				queryFn: authClient$1.listSessions,
				cacheKey: "listSessions"
			}),
			useListPasskeys: authClient$1.useListPasskeys,
			useListApiKeys: () => useAuthData({
				queryFn: authClient$1.apiKey.list,
				cacheKey: "listApiKeys"
			}),
			useActiveOrganization: authClient$1.useActiveOrganization,
			useListOrganizations: authClient$1.useListOrganizations,
			useHasPermission: (params) => useAuthData({
				queryFn: () => authClient$1.$fetch("/organization/has-permission", {
					method: "POST",
					body: params
				}),
				cacheKey: `hasPermission:${JSON.stringify(params)}`
			}),
			useInvitation: (params) => useAuthData({
				queryFn: () => authClient$1.organization.getInvitation(params),
				cacheKey: `invitation:${JSON.stringify(params)}`
			}),
			useListInvitations: (params) => useAuthData({
				queryFn: () => {
					var _a;
					return authClient$1.$fetch(`/organization/list-invitations?organizationId=${((_a = params == null ? void 0 : params.query) == null ? void 0 : _a.organizationId) || ""}`);
				},
				cacheKey: `listInvitations:${JSON.stringify(params)}`
			}),
			useListUserInvitations: () => useAuthData({
				queryFn: () => authClient$1.$fetch("/organization/list-user-invitations"),
				cacheKey: `listUserInvitations`
			}),
			useListMembers: (params) => useAuthData({
				queryFn: () => {
					var _a;
					return authClient$1.$fetch(`/organization/list-members?organizationId=${((_a = params == null ? void 0 : params.query) == null ? void 0 : _a.organizationId) || ""}`);
				},
				cacheKey: `listMembers:${JSON.stringify(params)}`
			}),
			useListTeams: (params) => useAuthData({
				queryFn: () => authClient$1.$fetch(`/organization/list-teams?organizationId=${(params == null ? void 0 : params.organizationId) || ""}`),
				cacheKey: `listTeams:${JSON.stringify(params)}`
			}),
			useListTeamMembers: (params) => useAuthData({
				queryFn: () => authClient$1.$fetch("/organization/list-team-members", {
					method: "POST",
					body: (params == null ? void 0 : params.teamId) ? { query: { teamId: params.teamId } } : void 0
				}),
				cacheKey: `listTeamMembers:${JSON.stringify(params)}`
			}),
			useListUserTeams: () => useAuthData({
				queryFn: () => authClient$1.$fetch("/organization/list-user-teams"),
				cacheKey: "listUserTeams"
			})
		};
	}, [authClient$1]);
	const viewPaths = useMemo(() => {
		return {
			...authViewPaths,
			...viewPathsProp
		};
	}, [viewPathsProp]);
	const localization = useMemo(() => {
		return {
			...authLocalization,
			...localizationProp
		};
	}, [localizationProp]);
	const hooks = useMemo(() => {
		return {
			...defaultHooks,
			...hooksProp
		};
	}, [defaultHooks, hooksProp]);
	const mutators = useMemo(() => {
		return {
			...defaultMutators,
			...mutatorsProp
		};
	}, [defaultMutators, mutatorsProp]);
	baseURL = baseURL.endsWith("/") ? baseURL.slice(0, -1) : baseURL;
	basePath = basePath.endsWith("/") ? basePath.slice(0, -1) : basePath;
	const { data: sessionData } = hooks.useSession();
	return /* @__PURE__ */ jsxs(AuthUIContext.Provider, {
		value: {
			authClient: authClient$1,
			avatar,
			basePath: basePath === "/" ? "" : basePath,
			baseURL,
			captcha,
			redirectTo,
			changeEmail,
			credentials,
			deleteUser,
			freshAge,
			genericOAuth,
			hooks,
			mutators,
			localization,
			localizeErrors,
			nameRequired,
			organization,
			teams,
			account,
			signUp,
			social,
			toast: toast2,
			navigate: navigate || defaultNavigate,
			replace: replace || navigate || defaultReplace,
			viewPaths,
			Link,
			...props
		},
		children: [sessionData && organization && /* @__PURE__ */ jsx(OrganizationRefetcher, {}), (captcha == null ? void 0 : captcha.provider) === "google-recaptcha-v3" ? /* @__PURE__ */ jsx(RecaptchaV3, { children }) : children]
	});
};
function useAuthData({ queryFn, cacheKey, staleTime = 1e4 }) {
	var _a;
	const { hooks: { useSession }, toast: toast2, localization, localizeErrors } = useContext(AuthUIContext);
	const { data: sessionData, isPending: sessionPending } = useSession();
	const queryFnRef = useRef(queryFn);
	queryFnRef.current = queryFn;
	const stableCacheKey = cacheKey || queryFn.toString();
	const cacheEntry = useSyncExternalStore(useCallback((callback) => authDataCache.subscribe(stableCacheKey, callback), [stableCacheKey]), useCallback(() => authDataCache.get(stableCacheKey), [stableCacheKey]), useCallback(() => authDataCache.get(stableCacheKey), [stableCacheKey]));
	const initialized = useRef(false);
	const previousUserId = useRef(void 0);
	const [error, setError] = useState(null);
	const refetch = useCallback(async () => {
		const existingRequest = authDataCache.getInFlightRequest(stableCacheKey);
		if (existingRequest) {
			try {
				const result = await existingRequest;
				if (result.error) setError(result.error);
				else setError(null);
			} catch (err) {
				setError(err);
			}
			return;
		}
		if ((cacheEntry == null ? void 0 : cacheEntry.data) !== void 0) authDataCache.setRefetching(stableCacheKey, true);
		const fetchPromise = queryFnRef.current();
		authDataCache.setInFlightRequest(stableCacheKey, fetchPromise);
		try {
			const { data, error: error2 } = await fetchPromise;
			if (error2) {
				setError(error2);
				toast2({
					variant: "error",
					message: getLocalizedError({
						error: error2,
						localization,
						localizeErrors
					})
				});
			} else setError(null);
			authDataCache.set(stableCacheKey, data);
		} catch (err) {
			const error2 = err;
			setError(error2);
			toast2({
				variant: "error",
				message: getLocalizedError({
					error: error2,
					localization,
					localizeErrors
				})
			});
		} finally {
			authDataCache.setRefetching(stableCacheKey, false);
			authDataCache.removeInFlightRequest(stableCacheKey);
		}
	}, [
		stableCacheKey,
		toast2,
		localization,
		localizeErrors,
		cacheEntry
	]);
	useEffect(() => {
		var _a2;
		const currentUserId = (_a2 = sessionData == null ? void 0 : sessionData.user) == null ? void 0 : _a2.id;
		if (!sessionData) {
			authDataCache.setRefetching(stableCacheKey, false);
			authDataCache.clear(stableCacheKey);
			initialized.current = false;
			previousUserId.current = void 0;
			return;
		}
		const userIdChanged = previousUserId.current !== void 0 && previousUserId.current !== currentUserId;
		if (userIdChanged) authDataCache.clear(stableCacheKey);
		const hasCachedData = (cacheEntry == null ? void 0 : cacheEntry.data) !== void 0;
		const isStale = !cacheEntry || Date.now() - cacheEntry.timestamp > staleTime;
		if (!initialized.current || !hasCachedData || userIdChanged || hasCachedData && isStale) {
			if (!hasCachedData || isStale) {
				initialized.current = true;
				refetch();
			}
		}
		previousUserId.current = currentUserId;
	}, [
		sessionData,
		(_a = sessionData == null ? void 0 : sessionData.user) == null ? void 0 : _a.id,
		stableCacheKey,
		refetch,
		cacheEntry,
		staleTime
	]);
	const isPending = sessionPending || (cacheEntry == null ? void 0 : cacheEntry.data) === void 0 && !error;
	return {
		data: (cacheEntry == null ? void 0 : cacheEntry.data) ?? null,
		isPending,
		isRefetching: (cacheEntry == null ? void 0 : cacheEntry.isRefetching) ?? false,
		error,
		refetch
	};
}
/**
* Utilities for hex, bytes, CSPRNG.
* @module
*/
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */
function isBytes(a) {
	return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
/** Asserts something is Uint8Array. */
function abytes(value, length, title = "") {
	const bytes = isBytes(value);
	const len = value?.length;
	const needsLen = length !== void 0;
	if (!bytes || needsLen && len !== length) {
		const prefix = title && `"${title}" `;
		const ofLen = needsLen ? ` of length ${length}` : "";
		const got = bytes ? `length=${len}` : `type=${typeof value}`;
		throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
	}
	return value;
}
/** Asserts a hash instance has not been destroyed / finished */
function aexists(instance, checkFinished = true) {
	if (instance.destroyed) throw new Error("Hash instance has been destroyed");
	if (checkFinished && instance.finished) throw new Error("Hash#digest() has already been called");
}
/** Asserts output is properly-sized byte array */
function aoutput(out, instance) {
	abytes(out, void 0, "digestInto() output");
	const min = instance.outputLen;
	if (out.length < min) throw new Error("\"digestInto() output\" expected to be of length >=" + min);
}
/** Zeroize a byte array. Warning: JS provides no guarantees. */
function clean$1(...arrays) {
	for (let i = 0; i < arrays.length; i++) arrays[i].fill(0);
}
/** Create DataView of an array for easy byte-level manipulation. */
function createView(arr) {
	return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** The rotate right (circular right shift) operation for uint32 */
function rotr(word, shift) {
	return word << 32 - shift | word >>> shift;
}
const hasHexBuiltin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
/**
* Convert byte array to hex string. Uses built-in function, when available.
* @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
*/
function bytesToHex(bytes) {
	abytes(bytes);
	if (hasHexBuiltin) return bytes.toHex();
	let hex = "";
	for (let i = 0; i < bytes.length; i++) hex += hexes[bytes[i]];
	return hex;
}
/** Creates function with outputLen, blockLen, create properties from a class constructor. */
function createHasher(hashCons, info = {}) {
	const hashC = (msg, opts) => hashCons(opts).update(msg).digest();
	const tmp = hashCons(void 0);
	hashC.outputLen = tmp.outputLen;
	hashC.blockLen = tmp.blockLen;
	hashC.create = (opts) => hashCons(opts);
	Object.assign(hashC, info);
	return Object.freeze(hashC);
}
/** Creates OID opts for NIST hashes, with prefix 06 09 60 86 48 01 65 03 04 02. */
const oidNist = (suffix) => ({ oid: Uint8Array.from([
	6,
	9,
	96,
	134,
	72,
	1,
	101,
	3,
	4,
	2,
	suffix
]) });
/**
* Internal Merkle-Damgard hash utils.
* @module
*/
/** Choice: a ? b : c */
function Chi(a, b, c) {
	return a & b ^ ~a & c;
}
/** Majority function, true if any two inputs is true. */
function Maj(a, b, c) {
	return a & b ^ a & c ^ b & c;
}
/**
* Merkle-Damgard hash construction base class.
* Could be used to create MD5, RIPEMD, SHA1, SHA2.
*/
var HashMD = class {
	blockLen;
	outputLen;
	padOffset;
	isLE;
	buffer;
	view;
	finished = false;
	length = 0;
	pos = 0;
	destroyed = false;
	constructor(blockLen, outputLen, padOffset, isLE) {
		this.blockLen = blockLen;
		this.outputLen = outputLen;
		this.padOffset = padOffset;
		this.isLE = isLE;
		this.buffer = new Uint8Array(blockLen);
		this.view = createView(this.buffer);
	}
	update(data) {
		aexists(this);
		abytes(data);
		const { view, buffer, blockLen } = this;
		const len = data.length;
		for (let pos = 0; pos < len;) {
			const take = Math.min(blockLen - this.pos, len - pos);
			if (take === blockLen) {
				const dataView = createView(data);
				for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);
				continue;
			}
			buffer.set(data.subarray(pos, pos + take), this.pos);
			this.pos += take;
			pos += take;
			if (this.pos === blockLen) {
				this.process(view, 0);
				this.pos = 0;
			}
		}
		this.length += data.length;
		this.roundClean();
		return this;
	}
	digestInto(out) {
		aexists(this);
		aoutput(out, this);
		this.finished = true;
		const { buffer, view, blockLen, isLE } = this;
		let { pos } = this;
		buffer[pos++] = 128;
		clean$1(this.buffer.subarray(pos));
		if (this.padOffset > blockLen - pos) {
			this.process(view, 0);
			pos = 0;
		}
		for (let i = pos; i < blockLen; i++) buffer[i] = 0;
		view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE);
		this.process(view, 0);
		const oview = createView(out);
		const len = this.outputLen;
		if (len % 4) throw new Error("_sha2: outputLen must be aligned to 32bit");
		const outLen = len / 4;
		const state = this.get();
		if (outLen > state.length) throw new Error("_sha2: outputLen bigger than state");
		for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);
	}
	digest() {
		const { buffer, outputLen } = this;
		this.digestInto(buffer);
		const res = buffer.slice(0, outputLen);
		this.destroy();
		return res;
	}
	_cloneInto(to) {
		to ||= new this.constructor();
		to.set(...this.get());
		const { blockLen, buffer, length, finished, destroyed, pos } = this;
		to.destroyed = destroyed;
		to.finished = finished;
		to.length = length;
		to.pos = pos;
		if (length % blockLen) to.buffer.set(buffer);
		return to;
	}
	clone() {
		return this._cloneInto();
	}
};
/**
* Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.
* Check out `test/misc/sha2-gen-iv.js` for recomputation guide.
*/
/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */
const SHA256_IV = /* @__PURE__ */ Uint32Array.from([
	1779033703,
	3144134277,
	1013904242,
	2773480762,
	1359893119,
	2600822924,
	528734635,
	1541459225
]);
/**
* SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.
* SHA256 is the fastest hash implementable in JS, even faster than Blake3.
* Check out [RFC 4634](https://www.rfc-editor.org/rfc/rfc4634) and
* [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
* @module
*/
/**
* Round constants:
* First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)
*/
const SHA256_K = /* @__PURE__ */ Uint32Array.from([
	1116352408,
	1899447441,
	3049323471,
	3921009573,
	961987163,
	1508970993,
	2453635748,
	2870763221,
	3624381080,
	310598401,
	607225278,
	1426881987,
	1925078388,
	2162078206,
	2614888103,
	3248222580,
	3835390401,
	4022224774,
	264347078,
	604807628,
	770255983,
	1249150122,
	1555081692,
	1996064986,
	2554220882,
	2821834349,
	2952996808,
	3210313671,
	3336571891,
	3584528711,
	113926993,
	338241895,
	666307205,
	773529912,
	1294757372,
	1396182291,
	1695183700,
	1986661051,
	2177026350,
	2456956037,
	2730485921,
	2820302411,
	3259730800,
	3345764771,
	3516065817,
	3600352804,
	4094571909,
	275423344,
	430227734,
	506948616,
	659060556,
	883997877,
	958139571,
	1322822218,
	1537002063,
	1747873779,
	1955562222,
	2024104815,
	2227730452,
	2361852424,
	2428436474,
	2756734187,
	3204031479,
	3329325298
]);
/** Reusable temporary buffer. "W" comes straight from spec. */
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
/** Internal 32-byte base SHA2 hash class. */
var SHA2_32B = class extends HashMD {
	constructor(outputLen) {
		super(64, outputLen, 8, false);
	}
	get() {
		const { A, B, C, D, E, F, G, H } = this;
		return [
			A,
			B,
			C,
			D,
			E,
			F,
			G,
			H
		];
	}
	set(A, B, C, D, E, F, G, H) {
		this.A = A | 0;
		this.B = B | 0;
		this.C = C | 0;
		this.D = D | 0;
		this.E = E | 0;
		this.F = F | 0;
		this.G = G | 0;
		this.H = H | 0;
	}
	process(view, offset) {
		for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);
		for (let i = 16; i < 64; i++) {
			const W15 = SHA256_W[i - 15];
			const W2 = SHA256_W[i - 2];
			const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
			SHA256_W[i] = (rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10) + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
		}
		let { A, B, C, D, E, F, G, H } = this;
		for (let i = 0; i < 64; i++) {
			const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
			const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
			const T2 = (rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22)) + Maj(A, B, C) | 0;
			H = G;
			G = F;
			F = E;
			E = D + T1 | 0;
			D = C;
			C = B;
			B = A;
			A = T1 + T2 | 0;
		}
		A = A + this.A | 0;
		B = B + this.B | 0;
		C = C + this.C | 0;
		D = D + this.D | 0;
		E = E + this.E | 0;
		F = F + this.F | 0;
		G = G + this.G | 0;
		H = H + this.H | 0;
		this.set(A, B, C, D, E, F, G, H);
	}
	roundClean() {
		clean$1(SHA256_W);
	}
	destroy() {
		this.set(0, 0, 0, 0, 0, 0, 0, 0);
		clean$1(this.buffer);
	}
};
/** Internal SHA2-256 hash class. */
var _SHA256 = class extends SHA2_32B {
	A = SHA256_IV[0] | 0;
	B = SHA256_IV[1] | 0;
	C = SHA256_IV[2] | 0;
	D = SHA256_IV[3] | 0;
	E = SHA256_IV[4] | 0;
	F = SHA256_IV[5] | 0;
	G = SHA256_IV[6] | 0;
	H = SHA256_IV[7] | 0;
	constructor() {
		super(32);
	}
};
/**
* SHA2-256 hash function from RFC 4634. In JS it's the fastest: even faster than Blake3. Some info:
*
* - Trying 2^128 hashes would get 50% chance of collision, using birthday attack.
* - BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.
* - Each sha256 hash is executing 2^18 bit operations.
* - Good 2024 ASICs can do 200Th/sec with 3500 watts of power, corresponding to 2^36 hashes/joule.
*/
const sha256 = /* @__PURE__ */ createHasher(() => new _SHA256(), /* @__PURE__ */ oidNist(1));
/**
* Convert the given array buffer into a Base64URL-encoded string. Ideal for converting various
* credential response ArrayBuffers to string for sending back to the server as JSON.
*
* Helper method to compliment `base64URLStringToBuffer`
*/
function bufferToBase64URLString(buffer) {
	const bytes = new Uint8Array(buffer);
	let str = "";
	for (const charCode of bytes) str += String.fromCharCode(charCode);
	return btoa(str).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
/**
* Convert from a Base64URL-encoded string to an Array Buffer. Best used when converting a
* credential ID from a JSON string to an ArrayBuffer, like in allowCredentials or
* excludeCredentials
*
* Helper method to compliment `bufferToBase64URLString`
*/
function base64URLStringToBuffer(base64URLString) {
	const base64 = base64URLString.replace(/-/g, "+").replace(/_/g, "/");
	/**
	* Pad with '=' until it's a multiple of four
	* (4 - (85 % 4 = 1) = 3) % 4 = 3 padding
	* (4 - (86 % 4 = 2) = 2) % 4 = 2 padding
	* (4 - (87 % 4 = 3) = 1) % 4 = 1 padding
	* (4 - (88 % 4 = 0) = 4) % 4 = 0 padding
	*/
	const padLength = (4 - base64.length % 4) % 4;
	const padded = base64.padEnd(base64.length + padLength, "=");
	const binary = atob(padded);
	const buffer = new ArrayBuffer(binary.length);
	const bytes = new Uint8Array(buffer);
	for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
	return buffer;
}
/**
* Determine if the browser is capable of Webauthn
*/
function browserSupportsWebAuthn() {
	return _browserSupportsWebAuthnInternals.stubThis(globalThis?.PublicKeyCredential !== void 0 && typeof globalThis.PublicKeyCredential === "function");
}
/**
* Make it possible to stub the return value during testing
* @ignore Don't include this in docs output
*/
const _browserSupportsWebAuthnInternals = { stubThis: (value) => value };
function toPublicKeyCredentialDescriptor(descriptor) {
	const { id } = descriptor;
	return {
		...descriptor,
		id: base64URLStringToBuffer(id),
		transports: descriptor.transports
	};
}
/**
* A simple test to determine if a hostname is a properly-formatted domain name
*
* A "valid domain" is defined here: https://url.spec.whatwg.org/#valid-domain
*
* Regex sourced from here:
* https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch08s15.html
*/
function isValidDomain(hostname) {
	return hostname === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(hostname);
}
/**
* A custom Error used to return a more nuanced error detailing _why_ one of the eight documented
* errors in the spec was raised after calling `navigator.credentials.create()` or
* `navigator.credentials.get()`:
*
* - `AbortError`
* - `ConstraintError`
* - `InvalidStateError`
* - `NotAllowedError`
* - `NotSupportedError`
* - `SecurityError`
* - `TypeError`
* - `UnknownError`
*
* Error messages were determined through investigation of the spec to determine under which
* scenarios a given error would be raised.
*/
var WebAuthnError = class extends Error {
	constructor({ message, code, cause, name }) {
		super(message, { cause });
		Object.defineProperty(this, "code", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
		this.name = name ?? cause.name;
		this.code = code;
	}
};
/**
* Attempt to intuit _why_ an error was raised after calling `navigator.credentials.create()`
*/
function identifyRegistrationError({ error, options }) {
	const { publicKey } = options;
	if (!publicKey) throw Error("options was missing required publicKey property");
	if (error.name === "AbortError") {
		if (options.signal instanceof AbortSignal) return new WebAuthnError({
			message: "Registration ceremony was sent an abort signal",
			code: "ERROR_CEREMONY_ABORTED",
			cause: error
		});
	} else if (error.name === "ConstraintError") {
		if (publicKey.authenticatorSelection?.requireResidentKey === true) return new WebAuthnError({
			message: "Discoverable credentials were required but no available authenticator supported it",
			code: "ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",
			cause: error
		});
		else if (options.mediation === "conditional" && publicKey.authenticatorSelection?.userVerification === "required") return new WebAuthnError({
			message: "User verification was required during automatic registration but it could not be performed",
			code: "ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",
			cause: error
		});
		else if (publicKey.authenticatorSelection?.userVerification === "required") return new WebAuthnError({
			message: "User verification was required but no available authenticator supported it",
			code: "ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",
			cause: error
		});
	} else if (error.name === "InvalidStateError") return new WebAuthnError({
		message: "The authenticator was previously registered",
		code: "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",
		cause: error
	});
	else if (error.name === "NotAllowedError")
 /**
	* Pass the error directly through. Platforms are overloading this error beyond what the spec
	* defines and we don't want to overwrite potentially useful error messages.
	*/
	return new WebAuthnError({
		message: error.message,
		code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
		cause: error
	});
	else if (error.name === "NotSupportedError") {
		if (publicKey.pubKeyCredParams.filter((param) => param.type === "public-key").length === 0) return new WebAuthnError({
			message: "No entry in pubKeyCredParams was of type \"public-key\"",
			code: "ERROR_MALFORMED_PUBKEYCREDPARAMS",
			cause: error
		});
		return new WebAuthnError({
			message: "No available authenticator supported any of the specified pubKeyCredParams algorithms",
			code: "ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",
			cause: error
		});
	} else if (error.name === "SecurityError") {
		const effectiveDomain = globalThis.location.hostname;
		if (!isValidDomain(effectiveDomain)) return new WebAuthnError({
			message: `${globalThis.location.hostname} is an invalid domain`,
			code: "ERROR_INVALID_DOMAIN",
			cause: error
		});
		else if (publicKey.rp.id !== effectiveDomain) return new WebAuthnError({
			message: `The RP ID "${publicKey.rp.id}" is invalid for this domain`,
			code: "ERROR_INVALID_RP_ID",
			cause: error
		});
	} else if (error.name === "TypeError") {
		if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) return new WebAuthnError({
			message: "User ID was not between 1 and 64 characters",
			code: "ERROR_INVALID_USER_ID_LENGTH",
			cause: error
		});
	} else if (error.name === "UnknownError") return new WebAuthnError({
		message: "The authenticator was unable to process the specified options, or could not create a new credential",
		code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
		cause: error
	});
	return error;
}
var BaseWebAuthnAbortService = class {
	constructor() {
		Object.defineProperty(this, "controller", {
			enumerable: true,
			configurable: true,
			writable: true,
			value: void 0
		});
	}
	createNewAbortSignal() {
		if (this.controller) {
			const abortError = /* @__PURE__ */ new Error("Cancelling existing WebAuthn API call for new one");
			abortError.name = "AbortError";
			this.controller.abort(abortError);
		}
		const newController = new AbortController();
		this.controller = newController;
		return newController.signal;
	}
	cancelCeremony() {
		if (this.controller) {
			const abortError = /* @__PURE__ */ new Error("Manually cancelling existing WebAuthn API call");
			abortError.name = "AbortError";
			this.controller.abort(abortError);
			this.controller = void 0;
		}
	}
};
/**
* A service singleton to help ensure that only a single WebAuthn ceremony is active at a time.
*
* Users of **@simplewebauthn/browser** shouldn't typically need to use this, but it can help e.g.
* developers building projects that use client-side routing to better control the behavior of
* their UX in response to router navigation events.
*/
const WebAuthnAbortService = new BaseWebAuthnAbortService();
const attachments = ["cross-platform", "platform"];
/**
* If possible coerce a `string` value into a known `AuthenticatorAttachment`
*/
function toAuthenticatorAttachment(attachment) {
	if (!attachment) return;
	if (attachments.indexOf(attachment) < 0) return;
	return attachment;
}
/**
* Begin authenticator "registration" via WebAuthn attestation
*
* @param optionsJSON Output from **@simplewebauthn/server**'s `generateRegistrationOptions()`
* @param useAutoRegister (Optional) Try to silently create a passkey with the password manager that the user just signed in with. Defaults to `false`.
*/
async function startRegistration(options) {
	if (!options.optionsJSON && options.challenge) {
		console.warn("startRegistration() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information.");
		options = { optionsJSON: options };
	}
	const { optionsJSON, useAutoRegister = false } = options;
	if (!browserSupportsWebAuthn()) throw new Error("WebAuthn is not supported in this browser");
	const publicKey = {
		...optionsJSON,
		challenge: base64URLStringToBuffer(optionsJSON.challenge),
		user: {
			...optionsJSON.user,
			id: base64URLStringToBuffer(optionsJSON.user.id)
		},
		excludeCredentials: optionsJSON.excludeCredentials?.map(toPublicKeyCredentialDescriptor)
	};
	const createOptions = {};
	/**
	* Try to use conditional create to register a passkey for the user with the password manager
	* the user just used to authenticate with. The user won't be shown any prominent UI by the
	* browser.
	*/
	if (useAutoRegister) createOptions.mediation = "conditional";
	createOptions.publicKey = publicKey;
	createOptions.signal = WebAuthnAbortService.createNewAbortSignal();
	let credential;
	try {
		credential = await navigator.credentials.create(createOptions);
	} catch (err) {
		throw identifyRegistrationError({
			error: err,
			options: createOptions
		});
	}
	if (!credential) throw new Error("Registration was not completed");
	const { id, rawId, response, type } = credential;
	let transports = void 0;
	if (typeof response.getTransports === "function") transports = response.getTransports();
	let responsePublicKeyAlgorithm = void 0;
	if (typeof response.getPublicKeyAlgorithm === "function") try {
		responsePublicKeyAlgorithm = response.getPublicKeyAlgorithm();
	} catch (error) {
		warnOnBrokenImplementation("getPublicKeyAlgorithm()", error);
	}
	let responsePublicKey = void 0;
	if (typeof response.getPublicKey === "function") try {
		const _publicKey = response.getPublicKey();
		if (_publicKey !== null) responsePublicKey = bufferToBase64URLString(_publicKey);
	} catch (error) {
		warnOnBrokenImplementation("getPublicKey()", error);
	}
	let responseAuthenticatorData;
	if (typeof response.getAuthenticatorData === "function") try {
		responseAuthenticatorData = bufferToBase64URLString(response.getAuthenticatorData());
	} catch (error) {
		warnOnBrokenImplementation("getAuthenticatorData()", error);
	}
	return {
		id,
		rawId: bufferToBase64URLString(rawId),
		response: {
			attestationObject: bufferToBase64URLString(response.attestationObject),
			clientDataJSON: bufferToBase64URLString(response.clientDataJSON),
			transports,
			publicKeyAlgorithm: responsePublicKeyAlgorithm,
			publicKey: responsePublicKey,
			authenticatorData: responseAuthenticatorData
		},
		type,
		clientExtensionResults: credential.getClientExtensionResults(),
		authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment)
	};
}
/**
* Visibly warn when we detect an issue related to a passkey provider intercepting WebAuthn API
* calls
*/
function warnOnBrokenImplementation(methodName, cause) {
	console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${methodName}. You should report this error to them.\n`, cause);
}
/**
* Determine if the browser supports conditional UI, so that WebAuthn credentials can
* be shown to the user in the browser's typical password autofill popup.
*/
function browserSupportsWebAuthnAutofill() {
	if (!browserSupportsWebAuthn()) return _browserSupportsWebAuthnAutofillInternals.stubThis(new Promise((resolve) => resolve(false)));
	/**
	* I don't like the `as unknown` here but there's a `declare var PublicKeyCredential` in
	* TS' DOM lib that's making it difficult for me to just go `as PublicKeyCredentialFuture` as I
	* want. I think I'm fine with this for now since it's _supposed_ to be temporary, until TS types
	* have a chance to catch up.
	*/
	const globalPublicKeyCredential = globalThis.PublicKeyCredential;
	if (globalPublicKeyCredential?.isConditionalMediationAvailable === void 0) return _browserSupportsWebAuthnAutofillInternals.stubThis(new Promise((resolve) => resolve(false)));
	return _browserSupportsWebAuthnAutofillInternals.stubThis(globalPublicKeyCredential.isConditionalMediationAvailable());
}
const _browserSupportsWebAuthnAutofillInternals = { stubThis: (value) => value };
/**
* Attempt to intuit _why_ an error was raised after calling `navigator.credentials.get()`
*/
function identifyAuthenticationError({ error, options }) {
	const { publicKey } = options;
	if (!publicKey) throw Error("options was missing required publicKey property");
	if (error.name === "AbortError") {
		if (options.signal instanceof AbortSignal) return new WebAuthnError({
			message: "Authentication ceremony was sent an abort signal",
			code: "ERROR_CEREMONY_ABORTED",
			cause: error
		});
	} else if (error.name === "NotAllowedError")
 /**
	* Pass the error directly through. Platforms are overloading this error beyond what the spec
	* defines and we don't want to overwrite potentially useful error messages.
	*/
	return new WebAuthnError({
		message: error.message,
		code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
		cause: error
	});
	else if (error.name === "SecurityError") {
		const effectiveDomain = globalThis.location.hostname;
		if (!isValidDomain(effectiveDomain)) return new WebAuthnError({
			message: `${globalThis.location.hostname} is an invalid domain`,
			code: "ERROR_INVALID_DOMAIN",
			cause: error
		});
		else if (publicKey.rpId !== effectiveDomain) return new WebAuthnError({
			message: `The RP ID "${publicKey.rpId}" is invalid for this domain`,
			code: "ERROR_INVALID_RP_ID",
			cause: error
		});
	} else if (error.name === "UnknownError") return new WebAuthnError({
		message: "The authenticator was unable to process the specified options, or could not create a new assertion signature",
		code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
		cause: error
	});
	return error;
}
/**
* Begin authenticator "login" via WebAuthn assertion
*
* @param optionsJSON Output from **@simplewebauthn/server**'s `generateAuthenticationOptions()`
* @param useBrowserAutofill (Optional) Initialize conditional UI to enable logging in via browser autofill prompts. Defaults to `false`.
* @param verifyBrowserAutofillInput (Optional) Ensure a suitable `<input>` element is present when `useBrowserAutofill` is `true`. Defaults to `true`.
*/
async function startAuthentication(options) {
	if (!options.optionsJSON && options.challenge) {
		console.warn("startAuthentication() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information.");
		options = { optionsJSON: options };
	}
	const { optionsJSON, useBrowserAutofill = false, verifyBrowserAutofillInput = true } = options;
	if (!browserSupportsWebAuthn()) throw new Error("WebAuthn is not supported in this browser");
	let allowCredentials;
	if (optionsJSON.allowCredentials?.length !== 0) allowCredentials = optionsJSON.allowCredentials?.map(toPublicKeyCredentialDescriptor);
	const publicKey = {
		...optionsJSON,
		challenge: base64URLStringToBuffer(optionsJSON.challenge),
		allowCredentials
	};
	const getOptions = {};
	/**
	* Set up the page to prompt the user to select a credential for authentication via the browser's
	* input autofill mechanism.
	*/
	if (useBrowserAutofill) {
		if (!await browserSupportsWebAuthnAutofill()) throw Error("Browser does not support WebAuthn autofill");
		if (document.querySelectorAll("input[autocomplete$='webauthn']").length < 1 && verifyBrowserAutofillInput) throw Error("No <input> with \"webauthn\" as the only or last value in its `autocomplete` attribute was detected");
		getOptions.mediation = "conditional";
		publicKey.allowCredentials = [];
	}
	getOptions.publicKey = publicKey;
	getOptions.signal = WebAuthnAbortService.createNewAbortSignal();
	let credential;
	try {
		credential = await navigator.credentials.get(getOptions);
	} catch (err) {
		throw identifyAuthenticationError({
			error: err,
			options: getOptions
		});
	}
	if (!credential) throw new Error("Authentication was not completed");
	const { id, rawId, response, type } = credential;
	let userHandle = void 0;
	if (response.userHandle) userHandle = bufferToBase64URLString(response.userHandle);
	return {
		id,
		rawId: bufferToBase64URLString(rawId),
		response: {
			authenticatorData: bufferToBase64URLString(response.authenticatorData),
			clientDataJSON: bufferToBase64URLString(response.clientDataJSON),
			signature: bufferToBase64URLString(response.signature),
			userHandle
		},
		type,
		clientExtensionResults: credential.getClientExtensionResults(),
		authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment)
	};
}
const _envShim = Object.create(null);
const _getEnv = (useShim) => globalThis.process?.env || globalThis.Deno?.env.toObject() || globalThis.__env__ || (useShim ? _envShim : globalThis);
const env = new Proxy(_envShim, {
	get(_, prop) {
		return _getEnv()[prop] ?? _envShim[prop];
	},
	has(_, prop) {
		return prop in _getEnv() || prop in _envShim;
	},
	set(_, prop, value) {
		const env$1 = _getEnv(true);
		env$1[prop] = value;
		return true;
	},
	deleteProperty(_, prop) {
		if (!prop) return false;
		const env$1 = _getEnv(true);
		delete env$1[prop];
		return true;
	},
	ownKeys() {
		const env$1 = _getEnv(true);
		return Object.keys(env$1);
	}
});
typeof process !== "undefined" && process.env && process.env.NODE_ENV;
/**
* Get environment variable with fallback
*/
function getEnvVar(key, fallback) {
	if (typeof process !== "undefined" && process.env) return process.env[key] ?? fallback;
	if (typeof Deno !== "undefined") return Deno.env.get(key) ?? fallback;
	if (typeof Bun !== "undefined") return Bun.env[key] ?? fallback;
	return fallback;
}
Object.freeze({
	get BETTER_AUTH_SECRET() {
		return getEnvVar("BETTER_AUTH_SECRET");
	},
	get AUTH_SECRET() {
		return getEnvVar("AUTH_SECRET");
	},
	get BETTER_AUTH_TELEMETRY() {
		return getEnvVar("BETTER_AUTH_TELEMETRY");
	},
	get BETTER_AUTH_TELEMETRY_ID() {
		return getEnvVar("BETTER_AUTH_TELEMETRY_ID");
	},
	get NODE_ENV() {
		return getEnvVar("NODE_ENV", "development");
	},
	get PACKAGE_VERSION() {
		return getEnvVar("PACKAGE_VERSION", "0.0.0");
	},
	get BETTER_AUTH_TELEMETRY_ENDPOINT() {
		return getEnvVar("BETTER_AUTH_TELEMETRY_ENDPOINT", "https://telemetry.better-auth.com/v1/track");
	}
});
const COLORS_2 = 1;
const COLORS_16 = 4;
const COLORS_256 = 8;
const COLORS_16m = 24;
const TERM_ENVS = {
	eterm: COLORS_16,
	cons25: COLORS_16,
	console: COLORS_16,
	cygwin: COLORS_16,
	dtterm: COLORS_16,
	gnome: COLORS_16,
	hurd: COLORS_16,
	jfbterm: COLORS_16,
	konsole: COLORS_16,
	kterm: COLORS_16,
	mlterm: COLORS_16,
	mosh: COLORS_16m,
	putty: COLORS_16,
	st: COLORS_16,
	"rxvt-unicode-24bit": COLORS_16m,
	terminator: COLORS_16m,
	"xterm-kitty": COLORS_16m
};
const CI_ENVS_MAP = new Map(Object.entries({
	APPVEYOR: COLORS_256,
	BUILDKITE: COLORS_256,
	CIRCLECI: COLORS_16m,
	DRONE: COLORS_256,
	GITEA_ACTIONS: COLORS_16m,
	GITHUB_ACTIONS: COLORS_16m,
	GITLAB_CI: COLORS_256,
	TRAVIS: COLORS_256
}));
const TERM_ENVS_REG_EXP = [
	/ansi/,
	/color/,
	/linux/,
	/direct/,
	/^con[0-9]*x[0-9]/,
	/^rxvt/,
	/^screen/,
	/^xterm/,
	/^vt100/,
	/^vt220/
];
function getColorDepth() {
	if (getEnvVar("FORCE_COLOR") !== void 0) switch (getEnvVar("FORCE_COLOR")) {
		case "":
		case "1":
		case "true": return COLORS_16;
		case "2": return COLORS_256;
		case "3": return COLORS_16m;
		default: return COLORS_2;
	}
	if (getEnvVar("NODE_DISABLE_COLORS") !== void 0 && getEnvVar("NODE_DISABLE_COLORS") !== "" || getEnvVar("NO_COLOR") !== void 0 && getEnvVar("NO_COLOR") !== "" || getEnvVar("TERM") === "dumb") return COLORS_2;
	if (getEnvVar("TMUX")) return COLORS_16m;
	if ("TF_BUILD" in env && "AGENT_NAME" in env) return COLORS_16;
	if ("CI" in env) {
		for (const { 0: envName, 1: colors } of CI_ENVS_MAP) if (envName in env) return colors;
		if (getEnvVar("CI_NAME") === "codeship") return COLORS_256;
		return COLORS_2;
	}
	if ("TEAMCITY_VERSION" in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.exec(getEnvVar("TEAMCITY_VERSION")) !== null ? COLORS_16 : COLORS_2;
	switch (getEnvVar("TERM_PROGRAM")) {
		case "iTerm.app":
			if (!getEnvVar("TERM_PROGRAM_VERSION") || /^[0-2]\./.exec(getEnvVar("TERM_PROGRAM_VERSION")) !== null) return COLORS_256;
			return COLORS_16m;
		case "HyperTerm":
		case "MacTerm": return COLORS_16m;
		case "Apple_Terminal": return COLORS_256;
	}
	if (getEnvVar("COLORTERM") === "truecolor" || getEnvVar("COLORTERM") === "24bit") return COLORS_16m;
	if (getEnvVar("TERM")) {
		if (/truecolor/.exec(getEnvVar("TERM")) !== null) return COLORS_16m;
		if (/^xterm-256/.exec(getEnvVar("TERM")) !== null) return COLORS_256;
		const termEnv = getEnvVar("TERM").toLowerCase();
		if (TERM_ENVS[termEnv]) return TERM_ENVS[termEnv];
		if (TERM_ENVS_REG_EXP.some((term) => term.exec(termEnv) !== null)) return COLORS_16;
	}
	if (getEnvVar("COLORTERM")) return COLORS_16;
	return COLORS_2;
}
const TTY_COLORS = {
	reset: "\x1B[0m",
	bright: "\x1B[1m",
	dim: "\x1B[2m",
	undim: "\x1B[22m",
	underscore: "\x1B[4m",
	blink: "\x1B[5m",
	reverse: "\x1B[7m",
	hidden: "\x1B[8m",
	fg: {
		black: "\x1B[30m",
		red: "\x1B[31m",
		green: "\x1B[32m",
		yellow: "\x1B[33m",
		blue: "\x1B[34m",
		magenta: "\x1B[35m",
		cyan: "\x1B[36m",
		white: "\x1B[37m"
	},
	bg: {
		black: "\x1B[40m",
		red: "\x1B[41m",
		green: "\x1B[42m",
		yellow: "\x1B[43m",
		blue: "\x1B[44m",
		magenta: "\x1B[45m",
		cyan: "\x1B[46m",
		white: "\x1B[47m"
	}
};
const levels = [
	"debug",
	"info",
	"success",
	"warn",
	"error"
];
function shouldPublishLog(currentLogLevel, logLevel) {
	return levels.indexOf(logLevel) >= levels.indexOf(currentLogLevel);
}
const levelColors = {
	info: TTY_COLORS.fg.blue,
	success: TTY_COLORS.fg.green,
	warn: TTY_COLORS.fg.yellow,
	error: TTY_COLORS.fg.red,
	debug: TTY_COLORS.fg.magenta
};
const formatMessage = (level, message, colorsEnabled) => {
	const timestamp = (/* @__PURE__ */ new Date()).toISOString();
	if (colorsEnabled) return `${TTY_COLORS.dim}${timestamp}${TTY_COLORS.reset} ${levelColors[level]}${level.toUpperCase()}${TTY_COLORS.reset} ${TTY_COLORS.bright}[Better Auth]:${TTY_COLORS.reset} ${message}`;
	return `${timestamp} ${level.toUpperCase()} [Better Auth]: ${message}`;
};
const createLogger = (options) => {
	const enabled = options?.disabled !== true;
	const logLevel = options?.level ?? "error";
	const colorsEnabled = options?.disableColors !== void 0 ? !options.disableColors : getColorDepth() !== 1;
	const LogFunc = (level, message, args = []) => {
		if (!enabled || !shouldPublishLog(logLevel, level)) return;
		const formattedMessage = formatMessage(level, message, colorsEnabled);
		if (!options || typeof options.log !== "function") {
			if (level === "error") console.error(formattedMessage, ...args);
			else if (level === "warn") console.warn(formattedMessage, ...args);
			else console.log(formattedMessage, ...args);
			return;
		}
		options.log(level === "success" ? "info" : level, message, ...args);
	};
	return {
		...Object.fromEntries(levels.map((level) => [level, (...[message, ...args]) => LogFunc(level, message, args)])),
		get level() {
			return logLevel;
		}
	};
};
createLogger();
function defineErrorCodes(codes) {
	return codes;
}
function capitalizeFirstLetter(str) {
	return str.charAt(0).toUpperCase() + str.slice(1);
}
defineErrorCodes({
	USER_NOT_FOUND: "User not found",
	FAILED_TO_CREATE_USER: "Failed to create user",
	FAILED_TO_CREATE_SESSION: "Failed to create session",
	FAILED_TO_UPDATE_USER: "Failed to update user",
	FAILED_TO_GET_SESSION: "Failed to get session",
	INVALID_PASSWORD: "Invalid password",
	INVALID_EMAIL: "Invalid email",
	INVALID_EMAIL_OR_PASSWORD: "Invalid email or password",
	SOCIAL_ACCOUNT_ALREADY_LINKED: "Social account already linked",
	PROVIDER_NOT_FOUND: "Provider not found",
	INVALID_TOKEN: "Invalid token",
	ID_TOKEN_NOT_SUPPORTED: "id_token not supported",
	FAILED_TO_GET_USER_INFO: "Failed to get user info",
	USER_EMAIL_NOT_FOUND: "User email not found",
	EMAIL_NOT_VERIFIED: "Email not verified",
	PASSWORD_TOO_SHORT: "Password too short",
	PASSWORD_TOO_LONG: "Password too long",
	USER_ALREADY_EXISTS: "User already exists.",
	USER_ALREADY_EXISTS_USE_ANOTHER_EMAIL: "User already exists. Use another email.",
	EMAIL_CAN_NOT_BE_UPDATED: "Email can not be updated",
	CREDENTIAL_ACCOUNT_NOT_FOUND: "Credential account not found",
	SESSION_EXPIRED: "Session expired. Re-authenticate to perform this action.",
	FAILED_TO_UNLINK_LAST_ACCOUNT: "You can't unlink your last account",
	ACCOUNT_NOT_FOUND: "Account not found",
	USER_ALREADY_HAS_PASSWORD: "User already has a password. Provide that to delete the account."
});
var BetterAuthError = class extends Error {
	constructor(message, cause) {
		super(message);
		this.name = "BetterAuthError";
		this.message = message;
		this.cause = cause;
		this.stack = "";
	}
};
function checkHasPath(url) {
	try {
		return (new URL(url).pathname.replace(/\/+$/, "") || "/") !== "/";
	} catch (error) {
		throw new BetterAuthError(`Invalid base URL: ${url}. Please provide a valid base URL.`);
	}
}
function assertHasProtocol(url) {
	try {
		const parsedUrl = new URL(url);
		if (parsedUrl.protocol !== "http:" && parsedUrl.protocol !== "https:") throw new BetterAuthError(`Invalid base URL: ${url}. URL must include 'http://' or 'https://'`);
	} catch (error) {
		if (error instanceof BetterAuthError) throw error;
		throw new BetterAuthError(`Invalid base URL: ${url}. Please provide a valid base URL.`, String(error));
	}
}
function withPath(url, path = "/api/auth") {
	assertHasProtocol(url);
	if (checkHasPath(url)) return url;
	const trimmedUrl = url.replace(/\/+$/, "");
	if (!path || path === "/") return trimmedUrl;
	path = path.startsWith("/") ? path : `/${path}`;
	return `${trimmedUrl}${path}`;
}
function getBaseURL(url, path, request, loadEnv, trustedProxyHeaders) {
	if (url) return withPath(url, path);
	if (loadEnv !== false) {
		const fromEnv = env.BETTER_AUTH_URL || env.NEXT_PUBLIC_BETTER_AUTH_URL || env.PUBLIC_BETTER_AUTH_URL || env.NUXT_PUBLIC_BETTER_AUTH_URL || env.NUXT_PUBLIC_AUTH_URL || (env.BASE_URL !== "/" ? env.BASE_URL : void 0);
		if (fromEnv) return withPath(fromEnv, path);
	}
	const fromRequest = request?.headers.get("x-forwarded-host");
	const fromRequestProto = request?.headers.get("x-forwarded-proto");
	if (fromRequest && fromRequestProto && trustedProxyHeaders) return withPath(`${fromRequestProto}://${fromRequest}`, path);
	if (request) {
		const url$1 = getOrigin(request.url);
		if (!url$1) throw new BetterAuthError("Could not get origin from request. Please provide a valid base URL.");
		return withPath(url$1, path);
	}
	if (typeof window !== "undefined" && window.location) return withPath(window.location.origin, path);
}
function getOrigin(url) {
	try {
		const parsedUrl = new URL(url);
		return parsedUrl.origin === "null" ? null : parsedUrl.origin;
	} catch (error) {
		return null;
	}
}
const PROTO_POLLUTION_PATTERNS = {
	proto: /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
	constructor: /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
	protoShort: /"__proto__"\s*:/,
	constructorShort: /"constructor"\s*:/
};
const JSON_SIGNATURE = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
const SPECIAL_VALUES = {
	true: true,
	false: false,
	null: null,
	undefined: void 0,
	nan: NaN,
	infinity: Number.POSITIVE_INFINITY,
	"-infinity": Number.NEGATIVE_INFINITY
};
const ISO_DATE_REGEX = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d{1,7}))?(?:Z|([+-])(\d{2}):(\d{2}))$/;
function isValidDate(date) {
	return date instanceof Date && !isNaN(date.getTime());
}
function parseISODate(value) {
	const match = ISO_DATE_REGEX.exec(value);
	if (!match) return null;
	const [, year, month, day, hour, minute, second, ms, offsetSign, offsetHour, offsetMinute] = match;
	let date = new Date(Date.UTC(parseInt(year, 10), parseInt(month, 10) - 1, parseInt(day, 10), parseInt(hour, 10), parseInt(minute, 10), parseInt(second, 10), ms ? parseInt(ms.padEnd(3, "0"), 10) : 0));
	if (offsetSign) {
		const offset = (parseInt(offsetHour, 10) * 60 + parseInt(offsetMinute, 10)) * (offsetSign === "+" ? -1 : 1);
		date.setUTCMinutes(date.getUTCMinutes() + offset);
	}
	return isValidDate(date) ? date : null;
}
function betterJSONParse(value, options = {}) {
	const { strict = false, warnings = false, reviver, parseDates = true } = options;
	if (typeof value !== "string") return value;
	const trimmed = value.trim();
	if (trimmed.length > 0 && trimmed[0] === "\"" && trimmed.endsWith("\"") && !trimmed.slice(1, -1).includes("\"")) return trimmed.slice(1, -1);
	const lowerValue = trimmed.toLowerCase();
	if (lowerValue.length <= 9 && lowerValue in SPECIAL_VALUES) return SPECIAL_VALUES[lowerValue];
	if (!JSON_SIGNATURE.test(trimmed)) {
		if (strict) throw new SyntaxError("[better-json] Invalid JSON");
		return value;
	}
	if (Object.entries(PROTO_POLLUTION_PATTERNS).some(([key, pattern]) => {
		const matches = pattern.test(trimmed);
		if (matches && warnings) console.warn(`[better-json] Detected potential prototype pollution attempt using ${key} pattern`);
		return matches;
	}) && strict) throw new Error("[better-json] Potential prototype pollution attempt detected");
	try {
		const secureReviver = (key, value$1) => {
			if (key === "__proto__" || key === "constructor" && value$1 && typeof value$1 === "object" && "prototype" in value$1) {
				if (warnings) console.warn(`[better-json] Dropping "${key}" key to prevent prototype pollution`);
				return;
			}
			if (parseDates && typeof value$1 === "string") {
				const date = parseISODate(value$1);
				if (date) return date;
			}
			return reviver ? reviver(key, value$1) : value$1;
		};
		return JSON.parse(trimmed, secureReviver);
	} catch (error) {
		if (strict) throw error;
		return value;
	}
}
function parseJSON(value, options = { strict: true }) {
	return betterJSONParse(value, options);
}
let clean = Symbol("clean");
let listenerQueue = [];
let lqIndex = 0;
const QUEUE_ITEMS_PER_LISTENER = 4;
let epoch = 0;
const atom = /* @__NO_SIDE_EFFECTS__ */ (initialValue) => {
	let listeners = [];
	let $atom = {
		get() {
			if (!$atom.lc) $atom.listen(() => {})();
			return $atom.value;
		},
		lc: 0,
		listen(listener) {
			$atom.lc = listeners.push(listener);
			return () => {
				for (let i = lqIndex + QUEUE_ITEMS_PER_LISTENER; i < listenerQueue.length;) if (listenerQueue[i] === listener) listenerQueue.splice(i, QUEUE_ITEMS_PER_LISTENER);
				else i += QUEUE_ITEMS_PER_LISTENER;
				let index = listeners.indexOf(listener);
				if (~index) {
					listeners.splice(index, 1);
					if (!--$atom.lc) $atom.off();
				}
			};
		},
		notify(oldValue, changedKey) {
			epoch++;
			let runListenerQueue = !listenerQueue.length;
			for (let listener of listeners) listenerQueue.push(listener, $atom.value, oldValue, changedKey);
			if (runListenerQueue) {
				for (lqIndex = 0; lqIndex < listenerQueue.length; lqIndex += QUEUE_ITEMS_PER_LISTENER) listenerQueue[lqIndex](listenerQueue[lqIndex + 1], listenerQueue[lqIndex + 2], listenerQueue[lqIndex + 3]);
				listenerQueue.length = 0;
			}
		},
		off() {},
		set(newValue) {
			let oldValue = $atom.value;
			if (oldValue !== newValue) {
				$atom.value = newValue;
				$atom.notify(oldValue);
			}
		},
		subscribe(listener) {
			let unbind = $atom.listen(listener);
			listener($atom.value);
			return unbind;
		},
		value: initialValue
	};
	if (process.env.NODE_ENV !== "production") $atom[clean] = () => {
		listeners = [];
		$atom.lc = 0;
		$atom.off();
	};
	return $atom;
};
const MOUNT = 5;
const UNMOUNT = 6;
const REVERT_MUTATION = 10;
let on = (object, listener, eventKey, mutateStore) => {
	object.events = object.events || {};
	if (!object.events[eventKey + REVERT_MUTATION]) object.events[eventKey + REVERT_MUTATION] = mutateStore((eventProps) => {
		object.events[eventKey].reduceRight((event, l) => (l(event), event), {
			shared: {},
			...eventProps
		});
	});
	object.events[eventKey] = object.events[eventKey] || [];
	object.events[eventKey].push(listener);
	return () => {
		let currentListeners = object.events[eventKey];
		let index = currentListeners.indexOf(listener);
		currentListeners.splice(index, 1);
		if (!currentListeners.length) {
			delete object.events[eventKey];
			object.events[eventKey + REVERT_MUTATION]();
			delete object.events[eventKey + REVERT_MUTATION];
		}
	};
};
let STORE_UNMOUNT_DELAY = 1e3;
let onMount = ($store, initialize) => {
	let listener = (payload) => {
		let destroy = initialize(payload);
		if (destroy) $store.events[UNMOUNT].push(destroy);
	};
	return on($store, listener, MOUNT, (runListeners) => {
		let originListen = $store.listen;
		$store.listen = (...args) => {
			if (!$store.lc && !$store.active) {
				$store.active = true;
				runListeners();
			}
			return originListen(...args);
		};
		let originOff = $store.off;
		$store.events[UNMOUNT] = [];
		$store.off = () => {
			originOff();
			setTimeout(() => {
				if ($store.active && !$store.lc) {
					$store.active = false;
					for (let destroy of $store.events[UNMOUNT]) destroy();
					$store.events[UNMOUNT] = [];
				}
			}, STORE_UNMOUNT_DELAY);
		};
		if (process.env.NODE_ENV !== "production") {
			let originClean = $store[clean];
			$store[clean] = () => {
				for (let destroy of $store.events[UNMOUNT]) destroy();
				$store.events[UNMOUNT] = [];
				$store.active = false;
				originClean();
			};
		}
		return () => {
			$store.listen = originListen;
			$store.off = originOff;
		};
	});
};
function listenKeys($store, keys, listener) {
	let keysSet = new Set(keys).add(void 0);
	return $store.listen((value, oldValue, changed) => {
		if (keysSet.has(changed)) listener(value, oldValue, changed);
	});
}
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
	enumerable: true,
	configurable: true,
	writable: true,
	value
}) : obj[key] = value;
var __spreadValues = (a, b) => {
	for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
	if (__getOwnPropSymbols) {
		for (var prop of __getOwnPropSymbols(b)) if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
	}
	return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var BetterFetchError = class extends Error {
	constructor(status, statusText, error) {
		super(statusText || status.toString(), { cause: error });
		this.status = status;
		this.statusText = statusText;
		this.error = error;
	}
};
var initializePlugins = async (url, options) => {
	var _a, _b, _c, _d, _e, _f;
	let opts = options || {};
	const hooks = {
		onRequest: [options == null ? void 0 : options.onRequest],
		onResponse: [options == null ? void 0 : options.onResponse],
		onSuccess: [options == null ? void 0 : options.onSuccess],
		onError: [options == null ? void 0 : options.onError],
		onRetry: [options == null ? void 0 : options.onRetry]
	};
	if (!options || !(options == null ? void 0 : options.plugins)) return {
		url,
		options: opts,
		hooks
	};
	for (const plugin of (options == null ? void 0 : options.plugins) || []) {
		if (plugin.init) {
			const pluginRes = await ((_a = plugin.init) == null ? void 0 : _a.call(plugin, url.toString(), options));
			opts = pluginRes.options || opts;
			url = pluginRes.url;
		}
		hooks.onRequest.push((_b = plugin.hooks) == null ? void 0 : _b.onRequest);
		hooks.onResponse.push((_c = plugin.hooks) == null ? void 0 : _c.onResponse);
		hooks.onSuccess.push((_d = plugin.hooks) == null ? void 0 : _d.onSuccess);
		hooks.onError.push((_e = plugin.hooks) == null ? void 0 : _e.onError);
		hooks.onRetry.push((_f = plugin.hooks) == null ? void 0 : _f.onRetry);
	}
	return {
		url,
		options: opts,
		hooks
	};
};
var LinearRetryStrategy = class {
	constructor(options) {
		this.options = options;
	}
	shouldAttemptRetry(attempt, response) {
		if (this.options.shouldRetry) return Promise.resolve(attempt < this.options.attempts && this.options.shouldRetry(response));
		return Promise.resolve(attempt < this.options.attempts);
	}
	getDelay() {
		return this.options.delay;
	}
};
var ExponentialRetryStrategy = class {
	constructor(options) {
		this.options = options;
	}
	shouldAttemptRetry(attempt, response) {
		if (this.options.shouldRetry) return Promise.resolve(attempt < this.options.attempts && this.options.shouldRetry(response));
		return Promise.resolve(attempt < this.options.attempts);
	}
	getDelay(attempt) {
		return Math.min(this.options.maxDelay, this.options.baseDelay * 2 ** attempt);
	}
};
function createRetryStrategy(options) {
	if (typeof options === "number") return new LinearRetryStrategy({
		type: "linear",
		attempts: options,
		delay: 1e3
	});
	switch (options.type) {
		case "linear": return new LinearRetryStrategy(options);
		case "exponential": return new ExponentialRetryStrategy(options);
		default: throw new Error("Invalid retry strategy");
	}
}
var getAuthHeader = async (options) => {
	const headers = {};
	const getValue = async (value) => typeof value === "function" ? await value() : value;
	if (options == null ? void 0 : options.auth) {
		if (options.auth.type === "Bearer") {
			const token = await getValue(options.auth.token);
			if (!token) return headers;
			headers["authorization"] = `Bearer ${token}`;
		} else if (options.auth.type === "Basic") {
			const username = getValue(options.auth.username);
			const password = getValue(options.auth.password);
			if (!username || !password) return headers;
			headers["authorization"] = `Basic ${btoa(`${username}:${password}`)}`;
		} else if (options.auth.type === "Custom") {
			const value = getValue(options.auth.value);
			if (!value) return headers;
			headers["authorization"] = `${getValue(options.auth.prefix)} ${value}`;
		}
	}
	return headers;
};
var JSON_RE = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function detectResponseType(request) {
	const _contentType = request.headers.get("content-type");
	const textTypes = /* @__PURE__ */ new Set([
		"image/svg",
		"application/xml",
		"application/xhtml",
		"application/html"
	]);
	if (!_contentType) return "json";
	const contentType = _contentType.split(";").shift() || "";
	if (JSON_RE.test(contentType)) return "json";
	if (textTypes.has(contentType) || contentType.startsWith("text/")) return "text";
	return "blob";
}
function isJSONParsable(value) {
	try {
		JSON.parse(value);
		return true;
	} catch (error) {
		return false;
	}
}
function isJSONSerializable(value) {
	if (value === void 0) return false;
	const t = typeof value;
	if (t === "string" || t === "number" || t === "boolean" || t === null) return true;
	if (t !== "object") return false;
	if (Array.isArray(value)) return true;
	if (value.buffer) return false;
	return value.constructor && value.constructor.name === "Object" || typeof value.toJSON === "function";
}
function jsonParse(text) {
	try {
		return JSON.parse(text);
	} catch (error) {
		return text;
	}
}
function isFunction(value) {
	return typeof value === "function";
}
function getFetch(options) {
	if (options == null ? void 0 : options.customFetchImpl) return options.customFetchImpl;
	if (typeof globalThis !== "undefined" && isFunction(globalThis.fetch)) return globalThis.fetch;
	if (typeof window !== "undefined" && isFunction(window.fetch)) return window.fetch;
	throw new Error("No fetch implementation found");
}
async function getHeaders(opts) {
	const headers = new Headers(opts == null ? void 0 : opts.headers);
	const authHeader = await getAuthHeader(opts);
	for (const [key, value] of Object.entries(authHeader || {})) headers.set(key, value);
	if (!headers.has("content-type")) {
		const t = detectContentType(opts == null ? void 0 : opts.body);
		if (t) headers.set("content-type", t);
	}
	return headers;
}
function detectContentType(body) {
	if (isJSONSerializable(body)) return "application/json";
	return null;
}
function getBody(options) {
	if (!(options == null ? void 0 : options.body)) return null;
	const headers = new Headers(options == null ? void 0 : options.headers);
	if (isJSONSerializable(options.body) && !headers.has("content-type")) {
		for (const [key, value] of Object.entries(options == null ? void 0 : options.body)) if (value instanceof Date) options.body[key] = value.toISOString();
		return JSON.stringify(options.body);
	}
	return options.body;
}
function getMethod$1(url, options) {
	var _a;
	if (options == null ? void 0 : options.method) return options.method.toUpperCase();
	if (url.startsWith("@")) {
		const pMethod = (_a = url.split("@")[1]) == null ? void 0 : _a.split("/")[0];
		if (!methods.includes(pMethod)) return (options == null ? void 0 : options.body) ? "POST" : "GET";
		return pMethod.toUpperCase();
	}
	return (options == null ? void 0 : options.body) ? "POST" : "GET";
}
function getTimeout(options, controller) {
	let abortTimeout;
	if (!(options == null ? void 0 : options.signal) && (options == null ? void 0 : options.timeout)) abortTimeout = setTimeout(() => controller == null ? void 0 : controller.abort(), options == null ? void 0 : options.timeout);
	return {
		abortTimeout,
		clearTimeout: () => {
			if (abortTimeout) clearTimeout(abortTimeout);
		}
	};
}
var ValidationError = class _ValidationError extends Error {
	constructor(issues, message) {
		super(message || JSON.stringify(issues, null, 2));
		this.issues = issues;
		Object.setPrototypeOf(this, _ValidationError.prototype);
	}
};
async function parseStandardSchema(schema, input) {
	let result = await schema["~standard"].validate(input);
	if (result.issues) throw new ValidationError(result.issues);
	return result.value;
}
var methods = [
	"get",
	"post",
	"put",
	"patch",
	"delete"
];
var applySchemaPlugin = (config) => ({
	id: "apply-schema",
	name: "Apply Schema",
	version: "1.0.0",
	async init(url, options) {
		var _a, _b, _c, _d;
		const schema = ((_b = (_a = config.plugins) == null ? void 0 : _a.find((plugin) => {
			var _a2;
			return ((_a2 = plugin.schema) == null ? void 0 : _a2.config) ? url.startsWith(plugin.schema.config.baseURL || "") || url.startsWith(plugin.schema.config.prefix || "") : false;
		})) == null ? void 0 : _b.schema) || config.schema;
		if (schema) {
			let urlKey = url;
			if ((_c = schema.config) == null ? void 0 : _c.prefix) {
				if (urlKey.startsWith(schema.config.prefix)) {
					urlKey = urlKey.replace(schema.config.prefix, "");
					if (schema.config.baseURL) url = url.replace(schema.config.prefix, schema.config.baseURL);
				}
			}
			if ((_d = schema.config) == null ? void 0 : _d.baseURL) {
				if (urlKey.startsWith(schema.config.baseURL)) urlKey = urlKey.replace(schema.config.baseURL, "");
			}
			const keySchema = schema.schema[urlKey];
			if (keySchema) {
				let opts = __spreadProps(__spreadValues({}, options), {
					method: keySchema.method,
					output: keySchema.output
				});
				if (!(options == null ? void 0 : options.disableValidation)) opts = __spreadProps(__spreadValues({}, opts), {
					body: keySchema.input ? await parseStandardSchema(keySchema.input, options == null ? void 0 : options.body) : options == null ? void 0 : options.body,
					params: keySchema.params ? await parseStandardSchema(keySchema.params, options == null ? void 0 : options.params) : options == null ? void 0 : options.params,
					query: keySchema.query ? await parseStandardSchema(keySchema.query, options == null ? void 0 : options.query) : options == null ? void 0 : options.query
				});
				return {
					url,
					options: opts
				};
			}
		}
		return {
			url,
			options
		};
	}
});
var createFetch = (config) => {
	async function $fetch(url, options) {
		const opts = __spreadProps(__spreadValues(__spreadValues({}, config), options), { plugins: [...(config == null ? void 0 : config.plugins) || [], applySchemaPlugin(config || {})] });
		if (config == null ? void 0 : config.catchAllError) try {
			return await betterFetch(url, opts);
		} catch (error) {
			return {
				data: null,
				error: {
					status: 500,
					statusText: "Fetch Error",
					message: "Fetch related error. Captured by catchAllError option. See error property for more details.",
					error
				}
			};
		}
		return await betterFetch(url, opts);
	}
	return $fetch;
};
function getURL2(url, option) {
	let { baseURL, params, query } = option || {
		query: {},
		params: {},
		baseURL: ""
	};
	let basePath = url.startsWith("http") ? url.split("/").slice(0, 3).join("/") : baseURL || "";
	if (url.startsWith("@")) {
		const m = url.toString().split("@")[1].split("/")[0];
		if (methods.includes(m)) url = url.replace(`@${m}/`, "/");
	}
	if (!basePath.endsWith("/")) basePath += "/";
	let [path, urlQuery] = url.replace(basePath, "").split("?");
	const queryParams = new URLSearchParams(urlQuery);
	for (const [key, value] of Object.entries(query || {})) {
		if (value == null) continue;
		queryParams.set(key, String(value));
	}
	if (params) if (Array.isArray(params)) {
		const paramPaths = path.split("/").filter((p) => p.startsWith(":"));
		for (const [index, key] of paramPaths.entries()) {
			const value = params[index];
			path = path.replace(key, value);
		}
	} else for (const [key, value] of Object.entries(params)) path = path.replace(`:${key}`, String(value));
	path = path.split("/").map(encodeURIComponent).join("/");
	if (path.startsWith("/")) path = path.slice(1);
	let queryParamString = queryParams.toString();
	queryParamString = queryParamString.length > 0 ? `?${queryParamString}`.replace(/\+/g, "%20") : "";
	if (!basePath.startsWith("http")) return `${basePath}${path}${queryParamString}`;
	return new URL(`${path}${queryParamString}`, basePath);
}
var betterFetch = async (url, options) => {
	var _a, _b, _c, _d, _e, _f, _g, _h;
	const { hooks, url: __url, options: opts } = await initializePlugins(url, options);
	const fetch$1 = getFetch(opts);
	const controller = new AbortController();
	const signal = (_a = opts.signal) != null ? _a : controller.signal;
	const _url = getURL2(__url, opts);
	const body = getBody(opts);
	const headers = await getHeaders(opts);
	const method = getMethod$1(__url, opts);
	let context = __spreadProps(__spreadValues({}, opts), {
		url: _url,
		headers,
		body,
		method,
		signal
	});
	for (const onRequest of hooks.onRequest) if (onRequest) {
		const res = await onRequest(context);
		if (res instanceof Object) context = res;
	}
	if ("pipeTo" in context && typeof context.pipeTo === "function" || typeof ((_b = options == null ? void 0 : options.body) == null ? void 0 : _b.pipe) === "function") {
		if (!("duplex" in context)) context.duplex = "half";
	}
	const { clearTimeout: clearTimeout2 } = getTimeout(opts, controller);
	let response = await fetch$1(context.url, context);
	clearTimeout2();
	const responseContext = {
		response,
		request: context
	};
	for (const onResponse of hooks.onResponse) if (onResponse) {
		const r = await onResponse(__spreadProps(__spreadValues({}, responseContext), { response: ((_c = options == null ? void 0 : options.hookOptions) == null ? void 0 : _c.cloneResponse) ? response.clone() : response }));
		if (r instanceof Response) response = r;
		else if (r instanceof Object) response = r.response;
	}
	if (response.ok) {
		if (!(context.method !== "HEAD")) return {
			data: "",
			error: null
		};
		const responseType = detectResponseType(response);
		const successContext = {
			data: "",
			response,
			request: context
		};
		if (responseType === "json" || responseType === "text") {
			const text = await response.text();
			successContext.data = await ((_d = context.jsonParser) != null ? _d : jsonParse)(text);
		} else successContext.data = await response[responseType]();
		if (context == null ? void 0 : context.output) {
			if (context.output && !context.disableValidation) successContext.data = await parseStandardSchema(context.output, successContext.data);
		}
		for (const onSuccess of hooks.onSuccess) if (onSuccess) await onSuccess(__spreadProps(__spreadValues({}, successContext), { response: ((_e = options == null ? void 0 : options.hookOptions) == null ? void 0 : _e.cloneResponse) ? response.clone() : response }));
		if (options == null ? void 0 : options.throw) return successContext.data;
		return {
			data: successContext.data,
			error: null
		};
	}
	const parser = (_f = options == null ? void 0 : options.jsonParser) != null ? _f : jsonParse;
	const responseText = await response.text();
	const isJSONResponse = isJSONParsable(responseText);
	const errorObject = isJSONResponse ? await parser(responseText) : null;
	const errorContext = {
		response,
		responseText,
		request: context,
		error: __spreadProps(__spreadValues({}, errorObject), {
			status: response.status,
			statusText: response.statusText
		})
	};
	for (const onError of hooks.onError) if (onError) await onError(__spreadProps(__spreadValues({}, errorContext), { response: ((_g = options == null ? void 0 : options.hookOptions) == null ? void 0 : _g.cloneResponse) ? response.clone() : response }));
	if (options == null ? void 0 : options.retry) {
		const retryStrategy = createRetryStrategy(options.retry);
		const _retryAttempt = (_h = options.retryAttempt) != null ? _h : 0;
		if (await retryStrategy.shouldAttemptRetry(_retryAttempt, response)) {
			for (const onRetry of hooks.onRetry) if (onRetry) await onRetry(responseContext);
			const delay = retryStrategy.getDelay(_retryAttempt);
			await new Promise((resolve) => setTimeout(resolve, delay));
			return await betterFetch(url, __spreadProps(__spreadValues({}, options), { retryAttempt: _retryAttempt + 1 }));
		}
	}
	if (options == null ? void 0 : options.throw) throw new BetterFetchError(response.status, response.statusText, isJSONResponse ? errorObject : responseText);
	return {
		data: null,
		error: __spreadProps(__spreadValues({}, errorObject), {
			status: response.status,
			statusText: response.statusText
		})
	};
};
const kBroadcastChannel = Symbol.for("better-auth:broadcast-channel");
const now$1 = () => Math.floor(Date.now() / 1e3);
var WindowBroadcastChannel = class {
	listeners = /* @__PURE__ */ new Set();
	name;
	constructor(name = "better-auth.message") {
		this.name = name;
	}
	subscribe(listener) {
		this.listeners.add(listener);
		return () => {
			this.listeners.delete(listener);
		};
	}
	post(message) {
		if (typeof window === "undefined") return;
		try {
			localStorage.setItem(this.name, JSON.stringify({
				...message,
				timestamp: now$1()
			}));
		} catch {}
	}
	setup() {
		if (typeof window === "undefined" || typeof window.addEventListener === "undefined") return () => {};
		const handler = (event) => {
			if (event.key !== this.name) return;
			const message = JSON.parse(event.newValue ?? "{}");
			if (message?.event !== "session" || !message?.data) return;
			this.listeners.forEach((listener) => listener(message));
		};
		window.addEventListener("storage", handler);
		return () => {
			window.removeEventListener("storage", handler);
		};
	}
};
function getGlobalBroadcastChannel(name = "better-auth.message") {
	if (!globalThis[kBroadcastChannel]) globalThis[kBroadcastChannel] = new WindowBroadcastChannel(name);
	return globalThis[kBroadcastChannel];
}
const kFocusManager = Symbol.for("better-auth:focus-manager");
var WindowFocusManager = class {
	listeners = /* @__PURE__ */ new Set();
	subscribe(listener) {
		this.listeners.add(listener);
		return () => {
			this.listeners.delete(listener);
		};
	}
	setFocused(focused) {
		this.listeners.forEach((listener) => listener(focused));
	}
	setup() {
		if (typeof window === "undefined" || typeof document === "undefined" || typeof window.addEventListener === "undefined") return () => {};
		const visibilityHandler = () => {
			if (document.visibilityState === "visible") this.setFocused(true);
		};
		document.addEventListener("visibilitychange", visibilityHandler, false);
		return () => {
			document.removeEventListener("visibilitychange", visibilityHandler, false);
		};
	}
};
function getGlobalFocusManager() {
	if (!globalThis[kFocusManager]) globalThis[kFocusManager] = new WindowFocusManager();
	return globalThis[kFocusManager];
}
const kOnlineManager = Symbol.for("better-auth:online-manager");
var WindowOnlineManager = class {
	listeners = /* @__PURE__ */ new Set();
	isOnline = typeof navigator !== "undefined" ? navigator.onLine : true;
	subscribe(listener) {
		this.listeners.add(listener);
		return () => {
			this.listeners.delete(listener);
		};
	}
	setOnline(online) {
		this.isOnline = online;
		this.listeners.forEach((listener) => listener(online));
	}
	setup() {
		if (typeof window === "undefined" || typeof window.addEventListener === "undefined") return () => {};
		const onOnline = () => this.setOnline(true);
		const onOffline = () => this.setOnline(false);
		window.addEventListener("online", onOnline, false);
		window.addEventListener("offline", onOffline, false);
		return () => {
			window.removeEventListener("online", onOnline, false);
			window.removeEventListener("offline", onOffline, false);
		};
	}
};
function getGlobalOnlineManager() {
	if (!globalThis[kOnlineManager]) globalThis[kOnlineManager] = new WindowOnlineManager();
	return globalThis[kOnlineManager];
}
const isServer = () => typeof window === "undefined";
const useAuthQuery = (initializedAtom, path, $fetch, options) => {
	const value = /* @__PURE__ */ atom({
		data: null,
		error: null,
		isPending: true,
		isRefetching: false,
		refetch: (queryParams) => fn(queryParams)
	});
	const fn = async (queryParams) => {
		return new Promise((resolve) => {
			const opts = typeof options === "function" ? options({
				data: value.get().data,
				error: value.get().error,
				isPending: value.get().isPending
			}) : options;
			$fetch(path, {
				...opts,
				query: {
					...opts?.query,
					...queryParams?.query
				},
				async onSuccess(context) {
					value.set({
						data: context.data,
						error: null,
						isPending: false,
						isRefetching: false,
						refetch: value.value.refetch
					});
					await opts?.onSuccess?.(context);
				},
				async onError(context) {
					const { request } = context;
					const retryAttempts = typeof request.retry === "number" ? request.retry : request.retry?.attempts;
					const retryAttempt = request.retryAttempt || 0;
					if (retryAttempts && retryAttempt < retryAttempts) return;
					value.set({
						error: context.error,
						data: null,
						isPending: false,
						isRefetching: false,
						refetch: value.value.refetch
					});
					await opts?.onError?.(context);
				},
				async onRequest(context) {
					const currentValue = value.get();
					value.set({
						isPending: currentValue.data === null,
						data: currentValue.data,
						error: null,
						isRefetching: true,
						refetch: value.value.refetch
					});
					await opts?.onRequest?.(context);
				}
			}).catch((error) => {
				value.set({
					error,
					data: null,
					isPending: false,
					isRefetching: false,
					refetch: value.value.refetch
				});
			}).finally(() => {
				resolve(void 0);
			});
		});
	};
	initializedAtom = Array.isArray(initializedAtom) ? initializedAtom : [initializedAtom];
	let isMounted = false;
	for (const initAtom of initializedAtom) initAtom.subscribe(async () => {
		if (isServer()) return;
		if (isMounted) await fn();
		else onMount(value, () => {
			const timeoutId = setTimeout(async () => {
				if (!isMounted) {
					await fn();
					isMounted = true;
				}
			}, 0);
			return () => {
				value.off();
				initAtom.off();
				clearTimeout(timeoutId);
			};
		});
	});
	return value;
};
const now = () => Math.floor(Date.now() / 1e3);
/**
* Rate limit: don't refetch on focus if a session request was made within this many seconds
*/
const FOCUS_REFETCH_RATE_LIMIT_SECONDS = 5;
function createSessionRefreshManager(opts) {
	const { sessionAtom, sessionSignal, $fetch, options = {} } = opts;
	const refetchInterval = options.sessionOptions?.refetchInterval ?? 0;
	const refetchOnWindowFocus = options.sessionOptions?.refetchOnWindowFocus ?? true;
	const refetchWhenOffline = options.sessionOptions?.refetchWhenOffline ?? false;
	const state = {
		lastSync: 0,
		lastSessionRequest: 0,
		cachedSession: void 0
	};
	const shouldRefetch = () => {
		return refetchWhenOffline || getGlobalOnlineManager().isOnline;
	};
	const triggerRefetch = (event) => {
		if (!shouldRefetch()) return;
		if (event?.event === "storage") {
			state.lastSync = now();
			sessionSignal.set(!sessionSignal.get());
			return;
		}
		const currentSession = sessionAtom.get();
		if (event?.event === "poll") {
			state.lastSessionRequest = now();
			$fetch("/get-session").then((res) => {
				sessionAtom.set({
					...currentSession,
					data: res.data,
					error: res.error || null
				});
				state.lastSync = now();
				sessionSignal.set(!sessionSignal.get());
			}).catch(() => {});
			return;
		}
		if (event?.event === "visibilitychange") {
			if (now() - state.lastSessionRequest < FOCUS_REFETCH_RATE_LIMIT_SECONDS && currentSession?.data !== null && currentSession?.data !== void 0) return;
		}
		if (currentSession?.data === null || currentSession?.data === void 0 || event?.event === "visibilitychange") {
			if (event?.event === "visibilitychange") state.lastSessionRequest = now();
			state.lastSync = now();
			sessionSignal.set(!sessionSignal.get());
		}
	};
	const broadcastSessionUpdate = (trigger) => {
		getGlobalBroadcastChannel().post({
			event: "session",
			data: { trigger },
			clientId: Math.random().toString(36).substring(7)
		});
	};
	const setupPolling = () => {
		if (refetchInterval && refetchInterval > 0) state.pollInterval = setInterval(() => {
			if (sessionAtom.get()?.data) triggerRefetch({ event: "poll" });
		}, refetchInterval * 1e3);
	};
	const setupBroadcast = () => {
		state.unsubscribeBroadcast = getGlobalBroadcastChannel().subscribe(() => {
			triggerRefetch({ event: "storage" });
		});
	};
	const setupFocusRefetch = () => {
		if (!refetchOnWindowFocus) return;
		state.unsubscribeFocus = getGlobalFocusManager().subscribe(() => {
			triggerRefetch({ event: "visibilitychange" });
		});
	};
	const setupOnlineRefetch = () => {
		state.unsubscribeOnline = getGlobalOnlineManager().subscribe((online) => {
			if (online) triggerRefetch({ event: "visibilitychange" });
		});
	};
	const init = () => {
		setupPolling();
		setupBroadcast();
		setupFocusRefetch();
		setupOnlineRefetch();
		getGlobalBroadcastChannel().setup();
		getGlobalFocusManager().setup();
		getGlobalOnlineManager().setup();
	};
	const cleanup = () => {
		if (state.pollInterval) {
			clearInterval(state.pollInterval);
			state.pollInterval = void 0;
		}
		if (state.unsubscribeBroadcast) {
			state.unsubscribeBroadcast();
			state.unsubscribeBroadcast = void 0;
		}
		if (state.unsubscribeFocus) {
			state.unsubscribeFocus();
			state.unsubscribeFocus = void 0;
		}
		if (state.unsubscribeOnline) {
			state.unsubscribeOnline();
			state.unsubscribeOnline = void 0;
		}
		state.lastSync = 0;
		state.lastSessionRequest = 0;
		state.cachedSession = void 0;
	};
	return {
		init,
		cleanup,
		triggerRefetch,
		broadcastSessionUpdate
	};
}
const redirectPlugin = {
	id: "redirect",
	name: "Redirect",
	hooks: { onSuccess(context) {
		if (context.data?.url && context.data?.redirect) {
			if (typeof window !== "undefined" && window.location) {
				if (window.location) try {
					window.location.href = context.data.url;
				} catch {}
			}
		}
	} }
};
function getSessionAtom($fetch, options) {
	const $signal = /* @__PURE__ */ atom(false);
	const session = useAuthQuery($signal, "/get-session", $fetch, { method: "GET" });
	onMount(session, () => {
		const refreshManager = createSessionRefreshManager({
			sessionAtom: session,
			sessionSignal: $signal,
			$fetch,
			options
		});
		refreshManager.init();
		return () => {
			refreshManager.cleanup();
		};
	});
	return {
		session,
		$sessionSignal: $signal
	};
}
const getClientConfig = (options, loadEnv) => {
	const isCredentialsSupported = "credentials" in Request.prototype;
	const baseURL = getBaseURL(options?.baseURL, options?.basePath, void 0, loadEnv) ?? "/api/auth";
	const pluginsFetchPlugins = options?.plugins?.flatMap((plugin) => plugin.fetchPlugins).filter((pl) => pl !== void 0) || [];
	const lifeCyclePlugin = {
		id: "lifecycle-hooks",
		name: "lifecycle-hooks",
		hooks: {
			onSuccess: options?.fetchOptions?.onSuccess,
			onError: options?.fetchOptions?.onError,
			onRequest: options?.fetchOptions?.onRequest,
			onResponse: options?.fetchOptions?.onResponse
		}
	};
	const { onSuccess, onError, onRequest, onResponse, ...restOfFetchOptions } = options?.fetchOptions || {};
	const $fetch = createFetch({
		baseURL,
		...isCredentialsSupported ? { credentials: "include" } : {},
		method: "GET",
		jsonParser(text) {
			if (!text) return null;
			return parseJSON(text, { strict: false });
		},
		customFetchImpl: fetch,
		...restOfFetchOptions,
		plugins: [
			lifeCyclePlugin,
			...restOfFetchOptions.plugins || [],
			...options?.disableDefaultFetchPlugins ? [] : [redirectPlugin],
			...pluginsFetchPlugins
		]
	});
	const { $sessionSignal, session } = getSessionAtom($fetch, options);
	const plugins = options?.plugins || [];
	let pluginsActions = {};
	let pluginsAtoms = {
		$sessionSignal,
		session
	};
	let pluginPathMethods = {
		"/sign-out": "POST",
		"/revoke-sessions": "POST",
		"/revoke-other-sessions": "POST",
		"/delete-user": "POST"
	};
	const atomListeners = [{
		signal: "$sessionSignal",
		matcher(path) {
			return path === "/sign-out" || path === "/update-user" || path === "/sign-up/email" || path === "/sign-in/email" || path === "/delete-user" || path === "/verify-email" || path === "/revoke-sessions" || path === "/revoke-session" || path === "/change-email";
		}
	}];
	for (const plugin of plugins) {
		if (plugin.getAtoms) Object.assign(pluginsAtoms, plugin.getAtoms?.($fetch));
		if (plugin.pathMethods) Object.assign(pluginPathMethods, plugin.pathMethods);
		if (plugin.atomListeners) atomListeners.push(...plugin.atomListeners);
	}
	const $store = {
		notify: (signal) => {
			pluginsAtoms[signal].set(!pluginsAtoms[signal].get());
		},
		listen: (signal, listener) => {
			pluginsAtoms[signal].subscribe(listener);
		},
		atoms: pluginsAtoms
	};
	for (const plugin of plugins) if (plugin.getActions) Object.assign(pluginsActions, plugin.getActions?.($fetch, $store, options));
	return {
		get baseURL() {
			return baseURL;
		},
		pluginsActions,
		pluginsAtoms,
		pluginPathMethods,
		atomListeners,
		$fetch,
		$store
	};
};
function isAtom(value) {
	return typeof value === "object" && value !== null && "get" in value && typeof value.get === "function" && "lc" in value && typeof value.lc === "number";
}
function getMethod(path, knownPathMethods, args) {
	const method = knownPathMethods[path];
	const { fetchOptions, query, ...body } = args || {};
	if (method) return method;
	if (fetchOptions?.method) return fetchOptions.method;
	if (body && Object.keys(body).length > 0) return "POST";
	return "GET";
}
function createDynamicPathProxy(routes, client, knownPathMethods, atoms, atomListeners) {
	function createProxy(path = []) {
		return new Proxy(function() {}, {
			get(_, prop) {
				if (typeof prop !== "string") return;
				if (prop === "then" || prop === "catch" || prop === "finally") return;
				const fullPath = [...path, prop];
				let current = routes;
				for (const segment of fullPath) if (current && typeof current === "object" && segment in current) current = current[segment];
				else {
					current = void 0;
					break;
				}
				if (typeof current === "function") return current;
				if (isAtom(current)) return current;
				return createProxy(fullPath);
			},
			apply: async (_, __, args) => {
				const routePath = "/" + path.map((segment) => segment.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`)).join("/");
				const arg = args[0] || {};
				const fetchOptions = args[1] || {};
				const { query, fetchOptions: argFetchOptions, ...body } = arg;
				const options = {
					...fetchOptions,
					...argFetchOptions
				};
				const method = getMethod(routePath, knownPathMethods, arg);
				return await client(routePath, {
					...options,
					body: method === "GET" ? void 0 : {
						...body,
						...options?.body || {}
					},
					query: query || options?.query,
					method,
					async onSuccess(context) {
						await options?.onSuccess?.(context);
						if (!atomListeners || options.disableSignal) return;
						/**
						* We trigger listeners
						*/
						const matches = atomListeners.filter((s) => s.matcher(routePath));
						if (!matches.length) return;
						for (const match of matches) {
							const signal = atoms[match.signal];
							if (!signal) return;
							/**
							* To avoid race conditions we set the signal in a setTimeout
							*/
							const val = signal.get();
							setTimeout(() => {
								signal.set(!val);
							}, 10);
						}
					}
				});
			}
		});
	}
	return createProxy();
}
const getPasskeyActions = ($fetch, { $listPasskeys, $store }) => {
	const signInPasskey = async (opts, options) => {
		const response = await $fetch("/passkey/generate-authenticate-options", {
			method: "GET",
			throw: false
		});
		if (!response.data) return response;
		try {
			const verified = await $fetch("/passkey/verify-authentication", {
				body: { response: await startAuthentication({
					optionsJSON: response.data,
					useBrowserAutofill: opts?.autoFill
				}) },
				...opts?.fetchOptions,
				...options,
				method: "POST",
				throw: false
			});
			$listPasskeys.set(Math.random());
			$store.notify("$sessionSignal");
			return verified;
		} catch {
			return {
				data: null,
				error: {
					code: "AUTH_CANCELLED",
					message: "auth cancelled",
					status: 400,
					statusText: "BAD_REQUEST"
				}
			};
		}
	};
	const registerPasskey = async (opts, fetchOpts) => {
		const options = await $fetch("/passkey/generate-register-options", {
			method: "GET",
			query: {
				...opts?.authenticatorAttachment && { authenticatorAttachment: opts.authenticatorAttachment },
				...opts?.name && { name: opts.name }
			},
			throw: false
		});
		if (!options.data) return options;
		try {
			const res = await startRegistration({
				optionsJSON: options.data,
				useAutoRegister: opts?.useAutoRegister
			});
			const verified = await $fetch("/passkey/verify-registration", {
				...opts?.fetchOptions,
				...fetchOpts,
				body: {
					response: res,
					name: opts?.name
				},
				method: "POST",
				throw: false
			});
			if (!verified.data) return verified;
			$listPasskeys.set(Math.random());
			return verified;
		} catch (e) {
			if (e instanceof WebAuthnError) {
				if (e.code === "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED") return {
					data: null,
					error: {
						code: e.code,
						message: "previously registered",
						status: 400,
						statusText: "BAD_REQUEST"
					}
				};
				if (e.code === "ERROR_CEREMONY_ABORTED") return {
					data: null,
					error: {
						code: e.code,
						message: "registration cancelled",
						status: 400,
						statusText: "BAD_REQUEST"
					}
				};
				return {
					data: null,
					error: {
						code: e.code,
						message: e.message,
						status: 400,
						statusText: "BAD_REQUEST"
					}
				};
			}
			return {
				data: null,
				error: {
					code: "UNKNOWN_ERROR",
					message: e instanceof Error ? e.message : "unknown error",
					status: 500,
					statusText: "INTERNAL_SERVER_ERROR"
				}
			};
		}
	};
	return {
		signIn: { passkey: signInPasskey },
		passkey: { addPasskey: registerPasskey },
		$Infer: {}
	};
};
const passkeyClient = () => {
	const $listPasskeys = /* @__PURE__ */ atom();
	return {
		id: "passkey",
		$InferServerPlugin: {},
		getActions: ($fetch, $store) => getPasskeyActions($fetch, {
			$listPasskeys,
			$store
		}),
		getAtoms($fetch) {
			return {
				listPasskeys: useAuthQuery($listPasskeys, "/passkey/list-user-passkeys", $fetch, { method: "GET" }),
				$listPasskeys
			};
		},
		pathMethods: {
			"/passkey/register": "POST",
			"/passkey/authenticate": "POST"
		},
		atomListeners: [{
			matcher(path) {
				return path === "/passkey/verify-registration" || path === "/passkey/delete-passkey" || path === "/passkey/update-passkey" || path === "/sign-out";
			},
			signal: "$listPasskeys"
		}, {
			matcher: (path) => path === "/passkey/verify-authentication",
			signal: "$sessionSignal"
		}]
	};
};
function role(statements) {
	return {
		authorize(request, connector = "AND") {
			let success = false;
			for (const [requestedResource, requestedActions] of Object.entries(request)) {
				const allowedActions = statements[requestedResource];
				if (!allowedActions) return {
					success: false,
					error: `You are not allowed to access resource: ${requestedResource}`
				};
				if (Array.isArray(requestedActions)) success = requestedActions.every((requestedAction) => allowedActions.includes(requestedAction));
				else if (typeof requestedActions === "object") {
					const actions = requestedActions;
					if (actions.connector === "OR") success = actions.actions.some((requestedAction) => allowedActions.includes(requestedAction));
					else success = actions.actions.every((requestedAction) => allowedActions.includes(requestedAction));
				} else throw new BetterAuthError("Invalid access control request");
				if (success && connector === "OR") return { success };
				if (!success && connector === "AND") return {
					success: false,
					error: `unauthorized to access resource "${requestedResource}"`
				};
			}
			if (success) return { success };
			return {
				success: false,
				error: "Not authorized"
			};
		},
		statements
	};
}
function createAccessControl(s) {
	return {
		newRole(statements) {
			return role(statements);
		},
		statements: s
	};
}
const defaultAc$1 = createAccessControl({
	user: [
		"create",
		"list",
		"set-role",
		"ban",
		"impersonate",
		"delete",
		"set-password",
		"get",
		"update"
	],
	session: [
		"list",
		"revoke",
		"delete"
	]
});
defaultAc$1.newRole({
	user: [
		"create",
		"list",
		"set-role",
		"ban",
		"impersonate",
		"delete",
		"set-password",
		"get",
		"update"
	],
	session: [
		"list",
		"revoke",
		"delete"
	]
});
defaultAc$1.newRole({
	user: [],
	session: []
});
const defaultAc = createAccessControl({
	organization: ["update", "delete"],
	member: [
		"create",
		"update",
		"delete"
	],
	invitation: ["create", "cancel"],
	team: [
		"create",
		"update",
		"delete"
	],
	ac: [
		"create",
		"read",
		"update",
		"delete"
	]
});
const adminAc = defaultAc.newRole({
	organization: ["update"],
	invitation: ["create", "cancel"],
	member: [
		"create",
		"update",
		"delete"
	],
	team: [
		"create",
		"update",
		"delete"
	],
	ac: [
		"create",
		"read",
		"update",
		"delete"
	]
});
const ownerAc = defaultAc.newRole({
	organization: ["update", "delete"],
	member: [
		"create",
		"update",
		"delete"
	],
	invitation: ["create", "cancel"],
	team: [
		"create",
		"update",
		"delete"
	],
	ac: [
		"create",
		"read",
		"update",
		"delete"
	]
});
const memberAc = defaultAc.newRole({
	organization: [],
	member: [],
	invitation: [],
	team: [],
	ac: ["read"]
});
const defaultRoles = {
	admin: adminAc,
	owner: ownerAc,
	member: memberAc
};
const hasPermissionFn = (input, acRoles) => {
	if (!input.permissions && !input.permission) return false;
	const roles = input.role.split(",");
	const creatorRole = input.options.creatorRole || "owner";
	const isCreator = roles.includes(creatorRole);
	const allowCreatorsAllPermissions = input.allowCreatorAllPermissions || false;
	if (isCreator && allowCreatorsAllPermissions) return true;
	for (const role$1 of roles) if ((acRoles[role$1]?.authorize(input.permissions ?? input.permission))?.success) return true;
	return false;
};
const twoFactorClient = (options) => {
	return {
		id: "two-factor",
		$InferServerPlugin: {},
		atomListeners: [{
			matcher: (path) => path.startsWith("/two-factor/"),
			signal: "$sessionSignal"
		}],
		pathMethods: {
			"/two-factor/disable": "POST",
			"/two-factor/enable": "POST",
			"/two-factor/send-otp": "POST",
			"/two-factor/generate-backup-codes": "POST"
		},
		fetchPlugins: [{
			id: "two-factor",
			name: "two-factor",
			hooks: { async onSuccess(context) {
				if (context.data?.twoFactorRedirect) {
					if (options?.onTwoFactorRedirect) await options.onTwoFactorRedirect();
				}
			} }
		}]
	};
};
const anonymousClient = () => {
	return {
		id: "anonymous",
		$InferServerPlugin: {},
		pathMethods: { "/sign-in/anonymous": "POST" },
		atomListeners: [{
			matcher: (path) => path === "/sign-in/anonymous",
			signal: "$sessionSignal"
		}]
	};
};
const apiKeyClient = () => {
	return {
		id: "api-key",
		$InferServerPlugin: {},
		pathMethods: {
			"/api-key/create": "POST",
			"/api-key/delete": "POST",
			"/api-key/delete-all-expired-api-keys": "POST"
		}
	};
};
const emailOTPClient = () => {
	return {
		id: "email-otp",
		$InferServerPlugin: {},
		atomListeners: [{
			matcher: (path) => path === "/email-otp/verify-email" || path === "/sign-in/email-otp",
			signal: "$sessionSignal"
		}]
	};
};
const genericOAuthClient = () => {
	return {
		id: "generic-oauth-client",
		$InferServerPlugin: {}
	};
};
const magicLinkClient = () => {
	return {
		id: "magic-link",
		$InferServerPlugin: {}
	};
};
const multiSessionClient = (options) => {
	return {
		id: "multi-session",
		$InferServerPlugin: {},
		atomListeners: [{
			matcher(path) {
				return path === "/multi-session/set-active";
			},
			signal: "$sessionSignal"
		}]
	};
};
let isRequestInProgress = null;
function isFedCMSupported() {
	return typeof window !== "undefined" && "IdentityCredential" in window;
}
const oneTapClient = (options) => {
	return {
		id: "one-tap",
		fetchPlugins: [{
			id: "fedcm-signout-handle",
			name: "FedCM Sign-Out Handler",
			hooks: { async onResponse(ctx) {
				if (!ctx.request.url.toString().includes("/sign-out")) return;
				if (options.promptOptions?.fedCM === false || !isFedCMSupported()) return;
				navigator.credentials.preventSilentAccess();
			} }
		}],
		getActions: ($fetch, _) => {
			return { oneTap: async (opts, fetchOptions) => {
				if (isRequestInProgress && !isRequestInProgress.signal.aborted) {
					console.warn("A Google One Tap request is already in progress. Please wait.");
					return;
				}
				if (typeof window === "undefined" || !window.document) {
					console.warn("Google One Tap is only available in browser environments");
					return;
				}
				async function callback(idToken) {
					await $fetch("/one-tap/callback", {
						method: "POST",
						body: { idToken },
						...opts?.fetchOptions,
						...fetchOptions
					});
					if (!opts?.fetchOptions && !fetchOptions || opts?.callbackURL) window.location.href = opts?.callbackURL ?? "/";
				}
				const { autoSelect, cancelOnTapOutside, context } = opts ?? {};
				const contextValue = context ?? options.context ?? "signin";
				const clients = {
					fedCM: async () => {
						try {
							const identityCredential = await navigator.credentials.get({
								identity: {
									context: contextValue,
									providers: [{
										configURL: "https://accounts.google.com/gsi/fedcm.json",
										clientId: options.clientId,
										nonce: opts?.nonce
									}]
								},
								mediation: autoSelect ? "optional" : "required",
								signal: isRequestInProgress?.signal
							});
							if (!identityCredential?.token) {
								opts?.onPromptNotification?.(void 0);
								return;
							}
							try {
								await callback(identityCredential.token);
								return;
							} catch (error) {
								console.error("Error during FedCM callback:", error);
								throw error;
							}
						} catch (error) {
							if (error?.code && (error.code === 19 || error.code === 20)) {
								opts?.onPromptNotification?.(void 0);
								return;
							}
							throw error;
						}
					},
					oneTap: () => {
						return new Promise((resolve, reject) => {
							let isResolved = false;
							const baseDelay = options.promptOptions?.baseDelay ?? 1e3;
							const maxAttempts = options.promptOptions?.maxAttempts ?? 5;
							window.google?.accounts.id.initialize({
								client_id: options.clientId,
								callback: async (response) => {
									isResolved = true;
									try {
										await callback(response.credential);
										resolve();
									} catch (error) {
										console.error("Error during One Tap callback:", error);
										reject(error);
									}
								},
								auto_select: autoSelect,
								cancel_on_tap_outside: cancelOnTapOutside,
								context: contextValue,
								ux_mode: opts?.uxMode || "popup",
								nonce: opts?.nonce,
								itp_support: true,
								...options.additionalOptions
							});
							const handlePrompt = (attempt) => {
								if (isResolved) return;
								window.google?.accounts.id.prompt((notification) => {
									if (isResolved) return;
									if (notification.isDismissedMoment && notification.isDismissedMoment()) if (attempt < maxAttempts) {
										const delay = Math.pow(2, attempt) * baseDelay;
										setTimeout(() => handlePrompt(attempt + 1), delay);
									} else opts?.onPromptNotification?.(notification);
									else if (notification.isSkippedMoment && notification.isSkippedMoment()) if (attempt < maxAttempts) {
										const delay = Math.pow(2, attempt) * baseDelay;
										setTimeout(() => handlePrompt(attempt + 1), delay);
									} else opts?.onPromptNotification?.(notification);
								});
							};
							handlePrompt(0);
						});
					}
				};
				if (isRequestInProgress) isRequestInProgress?.abort();
				isRequestInProgress = new AbortController();
				try {
					const client = options.promptOptions?.fedCM === false || !isFedCMSupported() ? "oneTap" : "fedCM";
					if (client === "oneTap") await loadGoogleScript();
					await clients[client]();
				} catch (error) {
					console.error("Error during Google One Tap flow:", error);
					throw error;
				} finally {
					isRequestInProgress = null;
				}
			} };
		},
		getAtoms($fetch) {
			return {};
		}
	};
};
const loadGoogleScript = () => {
	return new Promise((resolve) => {
		if (window.googleScriptInitialized) {
			resolve();
			return;
		}
		const script = document.createElement("script");
		script.src = "https://accounts.google.com/gsi/client";
		script.async = true;
		script.defer = true;
		script.onload = () => {
			window.googleScriptInitialized = true;
			resolve();
		};
		document.head.appendChild(script);
	});
};
/**
* Using the same `hasPermissionFn` function, but without the need for a `ctx` parameter or the `organizationId` parameter.
*/
const clientSideHasPermission = (input) => {
	return hasPermissionFn(input, input.options.roles || defaultRoles);
};
const organizationClient = (options) => {
	const $listOrg = /* @__PURE__ */ atom(false);
	const $activeOrgSignal = /* @__PURE__ */ atom(false);
	const $activeMemberSignal = /* @__PURE__ */ atom(false);
	const $activeMemberRoleSignal = /* @__PURE__ */ atom(false);
	const roles = {
		admin: adminAc,
		member: memberAc,
		owner: ownerAc,
		...options?.roles
	};
	return {
		id: "organization",
		$InferServerPlugin: {},
		getActions: ($fetch, _$store, co) => ({
			$Infer: {
				ActiveOrganization: {},
				Organization: {},
				Invitation: {},
				Member: {},
				Team: {}
			},
			organization: { checkRolePermission: (data) => {
				return clientSideHasPermission({
					role: data.role,
					options: {
						ac: options?.ac,
						roles
					},
					permissions: data.permissions ?? data.permission
				});
			} }
		}),
		getAtoms: ($fetch) => {
			const listOrganizations = useAuthQuery($listOrg, "/organization/list", $fetch, { method: "GET" });
			return {
				$listOrg,
				$activeOrgSignal,
				$activeMemberSignal,
				$activeMemberRoleSignal,
				activeOrganization: useAuthQuery([$activeOrgSignal], "/organization/get-full-organization", $fetch, () => ({ method: "GET" })),
				listOrganizations,
				activeMember: useAuthQuery([$activeMemberSignal], "/organization/get-active-member", $fetch, { method: "GET" }),
				activeMemberRole: useAuthQuery([$activeMemberRoleSignal], "/organization/get-active-member-role", $fetch, { method: "GET" })
			};
		},
		pathMethods: {
			"/organization/get-full-organization": "GET",
			"/organization/list-user-teams": "GET"
		},
		atomListeners: [
			{
				matcher(path) {
					return path === "/organization/create" || path === "/organization/delete" || path === "/organization/update";
				},
				signal: "$listOrg"
			},
			{
				matcher(path) {
					return path.startsWith("/organization");
				},
				signal: "$activeOrgSignal"
			},
			{
				matcher(path) {
					return path.startsWith("/organization/set-active");
				},
				signal: "$sessionSignal"
			},
			{
				matcher(path) {
					return path.includes("/organization/update-member-role");
				},
				signal: "$activeMemberSignal"
			},
			{
				matcher(path) {
					return path.includes("/organization/update-member-role");
				},
				signal: "$activeMemberRoleSignal"
			}
		]
	};
};
const usernameClient = () => {
	return {
		id: "username",
		$InferServerPlugin: {},
		atomListeners: [{
			matcher: (path) => path === "/sign-in/username",
			signal: "$sessionSignal"
		}]
	};
};
/**
* Subscribe to store changes and get store's value.
*
* Can be used with store builder too.
*
* ```js
* import { useStore } from 'nanostores/react'
*
* import { router } from '../store/router'
*
* export const Layout = () => {
*   let page = useStore(router)
*   if (page.route === 'home') {
*     return <HomePage />
*   } else {
*     return <Error404 />
*   }
* }
* ```
*
* @param store Store instance.
* @returns Store value.
*/
function useStore(store, options = {}) {
	let snapshotRef = useRef(store.get());
	const { keys, deps = [store, keys] } = options;
	let subscribe$1 = useCallback((onChange) => {
		const emitChange = (value) => {
			if (snapshotRef.current === value) return;
			snapshotRef.current = value;
			onChange();
		};
		emitChange(store.value);
		if (keys?.length) return listenKeys(store, keys, emitChange);
		return store.listen(emitChange);
	}, deps);
	let get = () => snapshotRef.current;
	return useSyncExternalStore(subscribe$1, get, get);
}
function getAtomKey(str) {
	return `use${capitalizeFirstLetter(str)}`;
}
function createAuthClient(options) {
	const { pluginPathMethods, pluginsActions, pluginsAtoms, $fetch, $store, atomListeners } = getClientConfig(options);
	let resolvedHooks = {};
	for (const [key, value] of Object.entries(pluginsAtoms)) resolvedHooks[getAtomKey(key)] = () => useStore(value);
	return createDynamicPathProxy({
		...pluginsActions,
		...resolvedHooks,
		$fetch,
		$store
	}, $fetch, pluginPathMethods, pluginsAtoms, atomListeners);
}
function useAuthenticate(options) {
	const { authView = "SIGN_IN", enabled = true } = options ?? {};
	const { hooks: { useSession }, basePath, viewPaths, replace } = useContext(AuthUIContext);
	const { data, isPending, error, refetch } = useSession();
	const sessionData = data;
	useEffect(() => {
		if (!enabled || isPending || sessionData) return;
		const redirectTo = new URLSearchParams(window.location.search).get("redirectTo") || window.location.pathname + window.location.search;
		replace(`${basePath}/${viewPaths[authView]}?redirectTo=${encodeURIComponent(redirectTo)}`);
	}, [
		isPending,
		sessionData,
		basePath,
		viewPaths,
		replace,
		authView,
		enabled
	]);
	return {
		data: sessionData,
		user: sessionData == null ? void 0 : sessionData.user,
		isPending,
		error,
		refetch
	};
}
function Card({ className, ...props }) {
	return /* @__PURE__ */ jsx("div", {
		"data-slot": "card",
		className: cn("bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm", className),
		...props
	});
}
function CardHeader({ className, ...props }) {
	return /* @__PURE__ */ jsx("div", {
		"data-slot": "card-header",
		className: cn("@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6", className),
		...props
	});
}
function CardTitle({ className, ...props }) {
	return /* @__PURE__ */ jsx("div", {
		"data-slot": "card-title",
		className: cn("leading-none font-semibold", className),
		...props
	});
}
function CardDescription({ className, ...props }) {
	return /* @__PURE__ */ jsx("div", {
		"data-slot": "card-description",
		className: cn("text-muted-foreground text-sm", className),
		...props
	});
}
function CardContent({ className, ...props }) {
	return /* @__PURE__ */ jsx("div", {
		"data-slot": "card-content",
		className: cn("px-6", className),
		...props
	});
}
function CardFooter({ className, ...props }) {
	return /* @__PURE__ */ jsx("div", {
		"data-slot": "card-footer",
		className: cn("flex items-center px-6 [.border-t]:pt-6", className),
		...props
	});
}
function Skeleton({ className, ...props }) {
	return /* @__PURE__ */ jsx("div", {
		"data-slot": "skeleton",
		className: cn("bg-accent animate-pulse rounded-md", className),
		...props
	});
}
var buttonVariants = cva("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", {
	variants: {
		variant: {
			default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
			destructive: "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
			outline: "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
			secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
			ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
			link: "text-primary underline-offset-4 hover:underline"
		},
		size: {
			default: "h-9 px-4 py-2 has-[>svg]:px-3",
			sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
			lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
			icon: "size-9"
		}
	},
	defaultVariants: {
		variant: "default",
		size: "default"
	}
});
function Button({ className, variant, size, asChild = false, ...props }) {
	return /* @__PURE__ */ jsx(asChild ? Slot : "button", {
		"data-slot": "button",
		className: cn(buttonVariants({
			variant,
			size,
			className
		})),
		...props
	});
}
function SettingsActionButton({ classNames, actionLabel, disabled, isSubmitting, variant, onClick, ...props }) {
	if (!onClick) isSubmitting = useFormState().isSubmitting;
	return /* @__PURE__ */ jsxs(Button, {
		className: cn("md:ms-auto", classNames == null ? void 0 : classNames.button, variant === "default" && (classNames == null ? void 0 : classNames.primaryButton), variant === "destructive" && (classNames == null ? void 0 : classNames.destructiveButton)),
		disabled: isSubmitting || disabled,
		size: "sm",
		type: onClick ? "button" : "submit",
		variant,
		onClick,
		...props,
		children: [isSubmitting && /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }), actionLabel]
	});
}
function SettingsCardFooter({ className, classNames, actionLabel, disabled, instructions, isPending, isSubmitting, variant, action }) {
	return /* @__PURE__ */ jsx(CardFooter, {
		className: cn("flex flex-col justify-between gap-4 rounded-b-xl md:flex-row", (actionLabel || instructions) && "!py-4 border-t", variant === "destructive" ? "border-destructive/30 bg-destructive/15" : "bg-sidebar", className, classNames == null ? void 0 : classNames.footer),
		children: isPending ? /* @__PURE__ */ jsxs(Fragment$1, { children: [instructions && /* @__PURE__ */ jsx(Skeleton, { className: cn("my-0.5 h-3 w-48 max-w-full md:h-4 md:w-56", classNames == null ? void 0 : classNames.skeleton) }), actionLabel && /* @__PURE__ */ jsx(Skeleton, { className: cn("h-8 w-14 md:ms-auto", classNames == null ? void 0 : classNames.skeleton) })] }) : /* @__PURE__ */ jsxs(Fragment$1, { children: [instructions && /* @__PURE__ */ jsx(CardDescription, {
			className: cn("text-center text-muted-foreground text-xs md:text-start md:text-sm", classNames == null ? void 0 : classNames.instructions),
			children: instructions
		}), actionLabel && /* @__PURE__ */ jsx(SettingsActionButton, {
			classNames,
			actionLabel,
			disabled,
			isSubmitting,
			variant,
			onClick: action
		})] })
	});
}
function SettingsCardHeader({ className, classNames, description, isPending, title }) {
	return /* @__PURE__ */ jsx(CardHeader, {
		className: cn(classNames == null ? void 0 : classNames.header, className),
		children: isPending ? /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(Skeleton, { className: cn("my-0.5 h-5 w-1/3 md:h-5.5", classNames == null ? void 0 : classNames.skeleton) }), description && /* @__PURE__ */ jsx(Skeleton, { className: cn("mt-1.5 mb-0.5 h-3 w-2/3 md:h-3.5", classNames == null ? void 0 : classNames.skeleton) })] }) : /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(CardTitle, {
			className: cn("text-lg md:text-xl", classNames == null ? void 0 : classNames.title),
			children: title
		}), description && /* @__PURE__ */ jsx(CardDescription, {
			className: cn("text-xs md:text-sm", classNames == null ? void 0 : classNames.description),
			children: description
		})] })
	});
}
function SettingsCard({ children, className, classNames, title, description, instructions, actionLabel, disabled, isPending, isSubmitting, optimistic, variant, action, ...props }) {
	return /* @__PURE__ */ jsxs(Card, {
		className: cn("w-full pb-0 text-start", variant === "destructive" && "border-destructive/40", className, classNames == null ? void 0 : classNames.base),
		...props,
		children: [
			/* @__PURE__ */ jsx(SettingsCardHeader, {
				classNames,
				description,
				isPending,
				title
			}),
			children,
			/* @__PURE__ */ jsx(SettingsCardFooter, {
				classNames,
				actionLabel,
				disabled,
				isPending,
				isSubmitting,
				instructions,
				optimistic,
				variant,
				action
			})
		]
	});
}
function SettingsCellSkeleton({ classNames }) {
	return /* @__PURE__ */ jsxs(Card, {
		className: cn("flex-row items-center gap-3 px-4 py-3", classNames == null ? void 0 : classNames.cell),
		children: [/* @__PURE__ */ jsxs("div", {
			className: "flex items-center gap-2",
			children: [/* @__PURE__ */ jsx(Skeleton, { className: cn("size-5 rounded-full", classNames == null ? void 0 : classNames.skeleton) }), /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(Skeleton, { className: cn("h-4 w-24", classNames == null ? void 0 : classNames.skeleton) }) })]
		}), /* @__PURE__ */ jsx(Skeleton, { className: cn("ms-auto size-8 w-12", classNames == null ? void 0 : classNames.skeleton) })]
	});
}
async function resizeAndCropImage(file, name, size, extension) {
	const image = await loadImage(file);
	const canvas = document.createElement("canvas");
	canvas.width = canvas.height = size;
	const ctx = canvas.getContext("2d");
	const minEdge = Math.min(image.width, image.height);
	const sx = (image.width - minEdge) / 2;
	const sy = (image.height - minEdge) / 2;
	const sWidth = minEdge;
	const sHeight = minEdge;
	ctx?.drawImage(image, sx, sy, sWidth, sHeight, 0, 0, size, size);
	const resizedImageBlob = await new Promise((resolve) => canvas.toBlob(resolve, `image/${extension}`));
	return new File([resizedImageBlob], `${name}.${extension}`, { type: `image/${extension}` });
}
async function loadImage(file) {
	return new Promise((resolve, reject) => {
		const image = new Image();
		const reader = new FileReader();
		reader.onload = (e) => {
			var _a;
			image.src = (_a = e.target) == null ? void 0 : _a.result;
		};
		image.onload = () => resolve(image);
		image.onerror = (err) => reject(err);
		reader.readAsDataURL(file);
	});
}
async function fileToBase64(file) {
	return new Promise((resolve, reject) => {
		const reader = new FileReader();
		reader.onloadend = () => resolve(reader.result);
		reader.onerror = reject;
		reader.readAsDataURL(file);
	});
}
function Dialog({ ...props }) {
	return /* @__PURE__ */ jsx(DialogPrimitive.Root, {
		"data-slot": "dialog",
		...props
	});
}
function DialogPortal({ ...props }) {
	return /* @__PURE__ */ jsx(DialogPrimitive.Portal, {
		"data-slot": "dialog-portal",
		...props
	});
}
function DialogOverlay({ className, ...props }) {
	return /* @__PURE__ */ jsx(DialogPrimitive.Overlay, {
		"data-slot": "dialog-overlay",
		className: cn("data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50", className),
		...props
	});
}
function DialogContent({ className, children, showCloseButton = true, ...props }) {
	return /* @__PURE__ */ jsxs(DialogPortal, {
		"data-slot": "dialog-portal",
		children: [/* @__PURE__ */ jsx(DialogOverlay, {}), /* @__PURE__ */ jsxs(DialogPrimitive.Content, {
			"data-slot": "dialog-content",
			className: cn("bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg", className),
			...props,
			children: [children, showCloseButton && /* @__PURE__ */ jsxs(DialogPrimitive.Close, {
				"data-slot": "dialog-close",
				className: "ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
				children: [/* @__PURE__ */ jsx(XIcon, {}), /* @__PURE__ */ jsx("span", {
					className: "sr-only",
					children: "Close"
				})]
			})]
		})]
	});
}
function DialogHeader({ className, ...props }) {
	return /* @__PURE__ */ jsx("div", {
		"data-slot": "dialog-header",
		className: cn("flex flex-col gap-2 text-center sm:text-left", className),
		...props
	});
}
function DialogFooter({ className, ...props }) {
	return /* @__PURE__ */ jsx("div", {
		"data-slot": "dialog-footer",
		className: cn("flex flex-col-reverse gap-2 sm:flex-row sm:justify-end", className),
		...props
	});
}
function DialogTitle({ className, ...props }) {
	return /* @__PURE__ */ jsx(DialogPrimitive.Title, {
		"data-slot": "dialog-title",
		className: cn("text-lg leading-none font-semibold", className),
		...props
	});
}
function DialogDescription({ className, ...props }) {
	return /* @__PURE__ */ jsx(DialogPrimitive.Description, {
		"data-slot": "dialog-description",
		className: cn("text-muted-foreground text-sm", className),
		...props
	});
}
function DropdownMenu({ ...props }) {
	return /* @__PURE__ */ jsx(DropdownMenuPrimitive.Root, {
		"data-slot": "dropdown-menu",
		...props
	});
}
function DropdownMenuTrigger({ ...props }) {
	return /* @__PURE__ */ jsx(DropdownMenuPrimitive.Trigger, {
		"data-slot": "dropdown-menu-trigger",
		...props
	});
}
function DropdownMenuContent({ className, sideOffset = 4, ...props }) {
	return /* @__PURE__ */ jsx(DropdownMenuPrimitive.Portal, { children: /* @__PURE__ */ jsx(DropdownMenuPrimitive.Content, {
		"data-slot": "dropdown-menu-content",
		sideOffset,
		className: cn("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md", className),
		...props
	}) });
}
function DropdownMenuItem({ className, inset, variant = "default", ...props }) {
	return /* @__PURE__ */ jsx(DropdownMenuPrimitive.Item, {
		"data-slot": "dropdown-menu-item",
		"data-inset": inset,
		"data-variant": variant,
		className: cn("focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", className),
		...props
	});
}
function DropdownMenuSeparator({ className, ...props }) {
	return /* @__PURE__ */ jsx(DropdownMenuPrimitive.Separator, {
		"data-slot": "dropdown-menu-separator",
		className: cn("bg-border -mx-1 my-1 h-px", className),
		...props
	});
}
function Label2({ className, ...props }) {
	return /* @__PURE__ */ jsx(LabelPrimitive.Root, {
		"data-slot": "label",
		className: cn("flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50", className),
		...props
	});
}
var Form = FormProvider;
var FormFieldContext = React.createContext({});
var FormField = ({ ...props }) => {
	return /* @__PURE__ */ jsx(FormFieldContext.Provider, {
		value: { name: props.name },
		children: /* @__PURE__ */ jsx(Controller, { ...props })
	});
};
var useFormField = () => {
	const fieldContext = React.useContext(FormFieldContext);
	const itemContext = React.useContext(FormItemContext);
	const { getFieldState } = useFormContext();
	const formState = useFormState({ name: fieldContext.name });
	const fieldState = getFieldState(fieldContext.name, formState);
	if (!fieldContext) throw new Error("useFormField should be used within <FormField>");
	const { id } = itemContext;
	return {
		id,
		name: fieldContext.name,
		formItemId: `${id}-form-item`,
		formDescriptionId: `${id}-form-item-description`,
		formMessageId: `${id}-form-item-message`,
		...fieldState
	};
};
var FormItemContext = React.createContext({});
function FormItem({ className, ...props }) {
	const id = React.useId();
	return /* @__PURE__ */ jsx(FormItemContext.Provider, {
		value: { id },
		children: /* @__PURE__ */ jsx("div", {
			"data-slot": "form-item",
			className: cn("grid gap-2", className),
			...props
		})
	});
}
function FormLabel({ className, ...props }) {
	const { error, formItemId } = useFormField();
	return /* @__PURE__ */ jsx(Label2, {
		"data-slot": "form-label",
		"data-error": !!error,
		className: cn("data-[error=true]:text-destructive", className),
		htmlFor: formItemId,
		...props
	});
}
function FormControl({ ...props }) {
	const { error, formItemId, formDescriptionId, formMessageId } = useFormField();
	return /* @__PURE__ */ jsx(Slot, {
		"data-slot": "form-control",
		id: formItemId,
		"aria-describedby": !error ? `${formDescriptionId}` : `${formDescriptionId} ${formMessageId}`,
		"aria-invalid": !!error,
		...props
	});
}
function FormMessage({ className, ...props }) {
	const { error, formMessageId } = useFormField();
	const body = error ? String((error == null ? void 0 : error.message) ?? "") : props.children;
	if (!body) return null;
	return /* @__PURE__ */ jsx("p", {
		"data-slot": "form-message",
		id: formMessageId,
		className: cn("text-destructive text-sm", className),
		...props,
		children: body
	});
}
function Input({ className, type, ...props }) {
	return /* @__PURE__ */ jsx("input", {
		type,
		"data-slot": "input",
		className: cn("file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]", "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", className),
		...props
	});
}
function Avatar({ className, ...props }) {
	return /* @__PURE__ */ jsx(AvatarPrimitive.Root, {
		"data-slot": "avatar",
		className: cn("relative flex size-8 shrink-0 overflow-hidden rounded-full", className),
		...props
	});
}
function AvatarImage({ className, ...props }) {
	return /* @__PURE__ */ jsx(AvatarPrimitive.Image, {
		"data-slot": "avatar-image",
		className: cn("aspect-square size-full", className),
		...props
	});
}
function AvatarFallback({ className, ...props }) {
	return /* @__PURE__ */ jsx(AvatarPrimitive.Fallback, {
		"data-slot": "avatar-fallback",
		className: cn("bg-muted flex size-full items-center justify-center rounded-full", className),
		...props
	});
}
function OrganizationLogo({ className, classNames, isPending, size, organization, localization: propLocalization, ...props }) {
	const { localization: contextLocalization, avatar } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...propLocalization
	}), [contextLocalization, propLocalization]);
	const name = organization == null ? void 0 : organization.name;
	const src = organization == null ? void 0 : organization.logo;
	if (isPending) return /* @__PURE__ */ jsx(Skeleton, { className: cn("shrink-0 rounded-full", size === "sm" ? "size-6" : size === "lg" ? "size-10" : size === "xl" ? "size-12" : "size-8", className, classNames == null ? void 0 : classNames.base, classNames == null ? void 0 : classNames.skeleton) });
	return /* @__PURE__ */ jsxs(Avatar, {
		className: cn("bg-muted", size === "sm" ? "size-6" : size === "lg" ? "size-10" : size === "xl" ? "size-12" : "size-8", className, classNames == null ? void 0 : classNames.base),
		...props,
		children: [(avatar == null ? void 0 : avatar.Image) ? /* @__PURE__ */ jsx(avatar.Image, {
			alt: name || (localization == null ? void 0 : localization.ORGANIZATION),
			className: classNames == null ? void 0 : classNames.image,
			src: src || ""
		}) : /* @__PURE__ */ jsx(AvatarImage, {
			alt: name || (localization == null ? void 0 : localization.ORGANIZATION),
			className: classNames == null ? void 0 : classNames.image,
			src: src || void 0
		}), /* @__PURE__ */ jsx(AvatarFallback, {
			className: cn("text-foreground", classNames == null ? void 0 : classNames.fallback),
			delayMs: src ? 600 : void 0,
			children: /* @__PURE__ */ jsx(BuildingIcon, { className: cn("size-[50%]", classNames == null ? void 0 : classNames.fallbackIcon) })
		})]
	});
}
function CreateOrganizationDialog({ className, classNames, localization: localizationProp, onOpenChange, ...props }) {
	var _a, _b, _c;
	const { authClient: authClient2, localization: contextLocalization, organization: organizationOptions, navigate, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const [logo, setLogo] = useState(null);
	const [logoPending, setLogoPending] = useState(false);
	const fileInputRef = useRef(null);
	const openFileDialog = () => {
		var _a2;
		return (_a2 = fileInputRef.current) == null ? void 0 : _a2.click();
	};
	const form = useForm({
		resolver: zodResolver(z$1.object({
			logo: z$1.string().optional(),
			name: z$1.string().min(1, { message: `${localization.ORGANIZATION_NAME} ${localization.IS_REQUIRED}` }),
			slug: z$1.string().min(1, { message: `${localization.ORGANIZATION_SLUG} ${localization.IS_REQUIRED}` }).regex(/^[a-z0-9-]+$/, { message: `${localization.ORGANIZATION_SLUG} ${localization.IS_INVALID}` })
		})),
		defaultValues: {
			logo: "",
			name: "",
			slug: ""
		}
	});
	const isSubmitting = form.formState.isSubmitting;
	const handleLogoChange = async (file) => {
		if (!(organizationOptions == null ? void 0 : organizationOptions.logo)) return;
		setLogoPending(true);
		try {
			const resizedFile = await resizeAndCropImage(file, crypto.randomUUID(), organizationOptions.logo.size, organizationOptions.logo.extension);
			let image;
			if (organizationOptions == null ? void 0 : organizationOptions.logo.upload) image = await organizationOptions.logo.upload(resizedFile);
			else image = await fileToBase64(resizedFile);
			setLogo(image || null);
			form.setValue("logo", image || "");
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
		setLogoPending(false);
	};
	const deleteLogo = async () => {
		var _a2;
		setLogoPending(true);
		const currentUrl = logo || void 0;
		if (currentUrl && ((_a2 = organizationOptions == null ? void 0 : organizationOptions.logo) == null ? void 0 : _a2.delete)) await organizationOptions.logo.delete(currentUrl);
		setLogo(null);
		form.setValue("logo", "");
		setLogoPending(false);
	};
	async function onSubmit({ name, slug, logo: logo2 }) {
		try {
			const organization = await authClient2.organization.create({
				name,
				slug,
				logo: logo2,
				fetchOptions: { throw: true }
			});
			if ((organizationOptions == null ? void 0 : organizationOptions.pathMode) === "slug") {
				navigate(`${organizationOptions.basePath}/${organization.slug}`);
				return;
			}
			await authClient2.organization.setActive({ organizationId: organization.id });
			onOpenChange?.(false);
			form.reset();
			setLogo(null);
			toast$1({
				variant: "success",
				message: localization.CREATE_ORGANIZATION_SUCCESS
			});
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
	}
	return /* @__PURE__ */ jsx(Dialog, {
		onOpenChange,
		...props,
		children: /* @__PURE__ */ jsxs(DialogContent, {
			className: (_a = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _a.content,
			children: [/* @__PURE__ */ jsxs(DialogHeader, {
				className: (_b = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _b.header,
				children: [/* @__PURE__ */ jsx(DialogTitle, {
					className: cn("text-lg md:text-xl", classNames == null ? void 0 : classNames.title),
					children: localization.CREATE_ORGANIZATION
				}), /* @__PURE__ */ jsx(DialogDescription, {
					className: cn("text-xs md:text-sm", classNames == null ? void 0 : classNames.description),
					children: localization.ORGANIZATIONS_INSTRUCTIONS
				})]
			}), /* @__PURE__ */ jsx(Form, {
				...form,
				children: /* @__PURE__ */ jsxs("form", {
					onSubmit: form.handleSubmit(onSubmit),
					className: "space-y-6",
					children: [
						(organizationOptions == null ? void 0 : organizationOptions.logo) && /* @__PURE__ */ jsx(FormField, {
							control: form.control,
							name: "logo",
							render: () => /* @__PURE__ */ jsxs(FormItem, { children: [
								/* @__PURE__ */ jsx("input", {
									ref: fileInputRef,
									accept: "image/*",
									disabled: logoPending,
									hidden: true,
									type: "file",
									onChange: (e) => {
										var _a2;
										const file = (_a2 = e.target.files) == null ? void 0 : _a2.item(0);
										if (file) handleLogoChange(file);
										e.target.value = "";
									}
								}),
								/* @__PURE__ */ jsx(FormLabel, { children: localization.LOGO }),
								/* @__PURE__ */ jsxs("div", {
									className: "flex items-center gap-4",
									children: [/* @__PURE__ */ jsxs(DropdownMenu, { children: [/* @__PURE__ */ jsx(DropdownMenuTrigger, {
										asChild: true,
										children: /* @__PURE__ */ jsx(Button, {
											className: "size-fit rounded-full",
											size: "icon",
											type: "button",
											variant: "ghost",
											children: /* @__PURE__ */ jsx(OrganizationLogo, {
												className: "size-16",
												isPending: logoPending,
												localization,
												organization: {
													name: form.watch("name"),
													logo
												}
											})
										})
									}), /* @__PURE__ */ jsxs(DropdownMenuContent, {
										align: "start",
										onCloseAutoFocus: (e) => e.preventDefault(),
										children: [/* @__PURE__ */ jsxs(DropdownMenuItem, {
											onClick: openFileDialog,
											disabled: logoPending,
											children: [/* @__PURE__ */ jsx(UploadCloudIcon, {}), localization.UPLOAD_LOGO]
										}), logo && /* @__PURE__ */ jsxs(DropdownMenuItem, {
											onClick: deleteLogo,
											disabled: logoPending,
											variant: "destructive",
											children: [/* @__PURE__ */ jsx(Trash2Icon, {}), localization.DELETE_LOGO]
										})]
									})] }), /* @__PURE__ */ jsxs(Button, {
										disabled: logoPending,
										variant: "outline",
										onClick: openFileDialog,
										type: "button",
										children: [logoPending && /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }), localization.UPLOAD]
									})]
								}),
								/* @__PURE__ */ jsx(FormMessage, {})
							] })
						}),
						/* @__PURE__ */ jsx(FormField, {
							control: form.control,
							name: "name",
							render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
								/* @__PURE__ */ jsx(FormLabel, { children: localization.ORGANIZATION_NAME }),
								/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(Input, {
									placeholder: localization.ORGANIZATION_NAME_PLACEHOLDER,
									...field
								}) }),
								/* @__PURE__ */ jsx(FormMessage, {})
							] })
						}),
						/* @__PURE__ */ jsx(FormField, {
							control: form.control,
							name: "slug",
							render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
								/* @__PURE__ */ jsx(FormLabel, { children: localization.ORGANIZATION_SLUG }),
								/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(Input, {
									placeholder: localization.ORGANIZATION_SLUG_PLACEHOLDER,
									...field
								}) }),
								/* @__PURE__ */ jsx(FormMessage, {})
							] })
						}),
						/* @__PURE__ */ jsxs(DialogFooter, {
							className: (_c = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _c.footer,
							children: [/* @__PURE__ */ jsx(Button, {
								type: "button",
								variant: "outline",
								onClick: () => onOpenChange == null ? void 0 : onOpenChange(false),
								className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.outlineButton),
								children: localization.CANCEL
							}), /* @__PURE__ */ jsxs(Button, {
								type: "submit",
								className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.primaryButton),
								disabled: isSubmitting,
								children: [isSubmitting && /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }), localization.CREATE_ORGANIZATION]
							})]
						})
					]
				})
			})]
		})
	});
}
function OrganizationCellView({ className, classNames, isPending, size, organization, localization: propLocalization }) {
	const { localization: contextLocalization } = useContext(AuthUIContext);
	const localization = {
		...contextLocalization,
		...propLocalization
	};
	return /* @__PURE__ */ jsxs("div", {
		className: cn("flex items-center gap-2 truncate", className, classNames == null ? void 0 : classNames.base),
		children: [/* @__PURE__ */ jsx(OrganizationLogo, {
			className: cn(size !== "sm" && "my-0.5"),
			classNames: classNames == null ? void 0 : classNames.avatar,
			isPending,
			localization,
			organization,
			size
		}), /* @__PURE__ */ jsx("div", {
			className: cn("flex flex-col truncate text-left leading-tight", classNames == null ? void 0 : classNames.content),
			children: isPending ? /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(Skeleton, { className: cn("max-w-full", size === "lg" ? "h-4.5 w-32" : "h-3.5 w-24", classNames == null ? void 0 : classNames.title, classNames == null ? void 0 : classNames.skeleton) }), size !== "sm" && /* @__PURE__ */ jsx(Skeleton, { className: cn("mt-1.5 max-w-full", size === "lg" ? "h-3.5 w-24" : "h-3 w-16", classNames == null ? void 0 : classNames.subtitle, classNames == null ? void 0 : classNames.skeleton) })] }) : /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx("span", {
				className: cn("truncate font-semibold", size === "lg" ? "text-base" : "text-sm", classNames == null ? void 0 : classNames.title),
				children: (organization == null ? void 0 : organization.name) || (localization == null ? void 0 : localization.ORGANIZATION)
			}), size !== "sm" && (organization == null ? void 0 : organization.slug) && /* @__PURE__ */ jsx("span", {
				className: cn("truncate opacity-70", size === "lg" ? "text-sm" : "text-xs", classNames == null ? void 0 : classNames.subtitle),
				children: organization.slug
			})] })
		})]
	});
}
function LeaveOrganizationDialog({ organization, className, classNames, localization: localizationProp, onOpenChange, ...props }) {
	var _a, _b, _c;
	const { authClient: authClient2, hooks: { useListOrganizations }, localization: contextLocalization, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const { refetch: refetchOrganizations } = useListOrganizations();
	const [isLeaving, setIsLeaving] = useState(false);
	const handleLeaveOrganization = async () => {
		setIsLeaving(true);
		try {
			await authClient2.organization.leave({
				organizationId: organization.id,
				fetchOptions: { throw: true }
			});
			await (refetchOrganizations == null ? void 0 : refetchOrganizations());
			toast$1({
				variant: "success",
				message: localization.LEAVE_ORGANIZATION_SUCCESS
			});
			onOpenChange?.(false);
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
		setIsLeaving(false);
	};
	return /* @__PURE__ */ jsx(Dialog, {
		onOpenChange,
		...props,
		children: /* @__PURE__ */ jsxs(DialogContent, {
			className: (_a = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _a.content,
			onOpenAutoFocus: (e) => e.preventDefault(),
			children: [
				/* @__PURE__ */ jsxs(DialogHeader, {
					className: (_b = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _b.header,
					children: [/* @__PURE__ */ jsx(DialogTitle, {
						className: cn("text-lg md:text-xl", classNames == null ? void 0 : classNames.title),
						children: localization.LEAVE_ORGANIZATION
					}), /* @__PURE__ */ jsx(DialogDescription, {
						className: cn("text-xs md:text-sm", classNames == null ? void 0 : classNames.description),
						children: localization.LEAVE_ORGANIZATION_CONFIRM
					})]
				}),
				/* @__PURE__ */ jsx(Card, {
					className: cn("my-2 flex-row p-4", className, classNames == null ? void 0 : classNames.cell),
					children: /* @__PURE__ */ jsx(OrganizationCellView, {
						organization,
						localization
					})
				}),
				/* @__PURE__ */ jsxs(DialogFooter, {
					className: (_c = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _c.footer,
					children: [/* @__PURE__ */ jsx(Button, {
						type: "button",
						variant: "outline",
						onClick: () => onOpenChange == null ? void 0 : onOpenChange(false),
						className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.outlineButton),
						disabled: isLeaving,
						children: localization.CANCEL
					}), /* @__PURE__ */ jsxs(Button, {
						type: "button",
						variant: "destructive",
						onClick: handleLeaveOrganization,
						className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.destructiveButton),
						disabled: isLeaving,
						children: [isLeaving && /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }), localization.LEAVE_ORGANIZATION]
					})]
				})
			]
		})
	});
}
function OrganizationCell({ className, classNames, organization, localization: localizationProp }) {
	var _a;
	const { authClient: authClient2, localization: contextLocalization, organization: organizationOptions, navigate, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const { pathMode } = organizationOptions || {};
	const [isLeaveDialogOpen, setIsLeaveDialogOpen] = useState(false);
	const [isManagingOrganization, setIsManagingOrganization] = useState(false);
	const handleManageOrganization = useCallback(async () => {
		var _a2;
		setIsManagingOrganization(true);
		if (pathMode === "slug") {
			navigate(`${organizationOptions == null ? void 0 : organizationOptions.basePath}/${organization.slug}/${organizationOptions == null ? void 0 : organizationOptions.viewPaths.SETTINGS}`);
			return;
		}
		try {
			await authClient2.organization.setActive({
				organizationId: organization.id,
				fetchOptions: { throw: true }
			});
			navigate(`${organizationOptions == null ? void 0 : organizationOptions.basePath}/${(_a2 = organizationOptions == null ? void 0 : organizationOptions.viewPaths) == null ? void 0 : _a2.SETTINGS}`);
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
			setIsManagingOrganization(false);
		}
	}, [
		authClient2,
		organization.id,
		organizationOptions == null ? void 0 : organizationOptions.basePath,
		(_a = organizationOptions == null ? void 0 : organizationOptions.viewPaths) == null ? void 0 : _a.SETTINGS,
		organization.slug,
		pathMode,
		navigate,
		toast$1,
		localization,
		localizeErrors
	]);
	return /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsxs(Card, {
		className: cn("flex-row p-4", className, classNames == null ? void 0 : classNames.cell),
		children: [/* @__PURE__ */ jsx(OrganizationCellView, {
			organization,
			localization
		}), /* @__PURE__ */ jsxs(DropdownMenu, { children: [/* @__PURE__ */ jsx(DropdownMenuTrigger, {
			asChild: true,
			children: /* @__PURE__ */ jsx(Button, {
				className: cn("relative ms-auto", classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.outlineButton),
				disabled: isManagingOrganization,
				size: "icon",
				type: "button",
				variant: "outline",
				children: isManagingOrganization ? /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }) : /* @__PURE__ */ jsx(EllipsisIcon, { className: classNames == null ? void 0 : classNames.icon })
			})
		}), /* @__PURE__ */ jsxs(DropdownMenuContent, { children: [/* @__PURE__ */ jsxs(DropdownMenuItem, {
			onClick: handleManageOrganization,
			disabled: isManagingOrganization,
			children: [/* @__PURE__ */ jsx(SettingsIcon, { className: classNames == null ? void 0 : classNames.icon }), localization.MANAGE_ORGANIZATION]
		}), /* @__PURE__ */ jsxs(DropdownMenuItem, {
			onClick: () => setIsLeaveDialogOpen(true),
			variant: "destructive",
			children: [/* @__PURE__ */ jsx(LogOutIcon, { className: classNames == null ? void 0 : classNames.icon }), localization.LEAVE_ORGANIZATION]
		})] })] })]
	}), /* @__PURE__ */ jsx(LeaveOrganizationDialog, {
		open: isLeaveDialogOpen,
		onOpenChange: setIsLeaveDialogOpen,
		organization,
		localization
	})] });
}
function OrganizationsCard({ className, classNames, localization, ...props }) {
	const { hooks: { useListOrganizations }, localization: contextLocalization } = useContext(AuthUIContext);
	localization = useMemo(() => ({
		...contextLocalization,
		...localization
	}), [contextLocalization, localization]);
	const isHydrated = useIsHydrated();
	const { data: organizations, isPending: organizationsPending } = useListOrganizations();
	const isPending = !isHydrated || organizationsPending;
	const [createDialogOpen, setCreateDialogOpen] = useState(false);
	return /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(SettingsCard, {
		className,
		classNames,
		title: localization.ORGANIZATIONS,
		description: localization.ORGANIZATIONS_DESCRIPTION,
		instructions: localization.ORGANIZATIONS_INSTRUCTIONS,
		actionLabel: localization.CREATE_ORGANIZATION,
		action: () => setCreateDialogOpen(true),
		isPending,
		...props,
		children: /* @__PURE__ */ jsxs(CardContent, {
			className: cn("grid gap-4", classNames == null ? void 0 : classNames.content),
			children: [isPending && /* @__PURE__ */ jsx(SettingsCellSkeleton, {}), organizations == null ? void 0 : organizations.map((organization) => /* @__PURE__ */ jsx(OrganizationCell, {
				classNames,
				organization,
				localization
			}, organization.id))]
		})
	}), /* @__PURE__ */ jsx(CreateOrganizationDialog, {
		classNames,
		localization,
		open: createDialogOpen,
		onOpenChange: setCreateDialogOpen
	})] });
}
function getGravatarUrl(email, options) {
	if (!email) return null;
	try {
		const normalizedEmail = email.trim().toLowerCase();
		let url = `https://gravatar.com/avatar/${bytesToHex(sha256(new TextEncoder().encode(normalizedEmail)))}${(options == null ? void 0 : options.jpg) ? ".jpg" : ""}`;
		const params = new URLSearchParams();
		if (options == null ? void 0 : options.size) params.append("s", Math.min(Math.max(options.size, 1), 2048).toString());
		if (options == null ? void 0 : options.d) params.append("d", options.d);
		if (options == null ? void 0 : options.forceDefault) params.append("f", "y");
		const queryString = params.toString();
		if (queryString) url += `?${queryString}`;
		return url;
	} catch (error) {
		console.error("Error generating Gravatar URL:", error);
		return null;
	}
}
function UserAvatar({ className, classNames, isPending, size, user, localization: propLocalization, ...props }) {
	const { localization: contextLocalization, gravatar, avatar } = useContext(AuthUIContext);
	const localization = {
		...contextLocalization,
		...propLocalization
	};
	const name = (user == null ? void 0 : user.displayName) || (user == null ? void 0 : user.name) || (user == null ? void 0 : user.fullName) || (user == null ? void 0 : user.firstName) || (user == null ? void 0 : user.displayUsername) || (user == null ? void 0 : user.username) || (user == null ? void 0 : user.email);
	const userImage = (user == null ? void 0 : user.image) || (user == null ? void 0 : user.avatar) || (user == null ? void 0 : user.avatarUrl);
	const gravatarUrl = gravatar && (user == null ? void 0 : user.email) ? getGravatarUrl(user.email, gravatar === true ? void 0 : gravatar) : null;
	const src = gravatar ? gravatarUrl : userImage;
	if (isPending) return /* @__PURE__ */ jsx(Skeleton, { className: cn("shrink-0 rounded-full", size === "sm" ? "size-6" : size === "lg" ? "size-10" : size === "xl" ? "size-12" : "size-8", className, classNames == null ? void 0 : classNames.base, classNames == null ? void 0 : classNames.skeleton) });
	return /* @__PURE__ */ jsxs(Avatar, {
		className: cn("bg-muted", size === "sm" ? "size-6" : size === "lg" ? "size-10" : size === "xl" ? "size-12" : "size-8", className, classNames == null ? void 0 : classNames.base),
		...props,
		children: [(avatar == null ? void 0 : avatar.Image) ? /* @__PURE__ */ jsx(avatar.Image, {
			alt: name || (localization == null ? void 0 : localization.USER),
			className: classNames == null ? void 0 : classNames.image,
			src: src || ""
		}) : /* @__PURE__ */ jsx(AvatarImage, {
			alt: name || (localization == null ? void 0 : localization.USER),
			className: classNames == null ? void 0 : classNames.image,
			src: src || void 0
		}), /* @__PURE__ */ jsx(AvatarFallback, {
			className: cn("text-foreground uppercase", classNames == null ? void 0 : classNames.fallback),
			delayMs: src ? 600 : void 0,
			children: firstTwoCharacters(name) || /* @__PURE__ */ jsx(UserRoundIcon, { className: cn("size-[50%]", classNames == null ? void 0 : classNames.fallbackIcon) })
		})]
	});
}
var firstTwoCharacters = (name) => name == null ? void 0 : name.slice(0, 2);
function UserInvitationsCard({ className, classNames, localization: localizationProp, ...props }) {
	const { hooks: { useListUserInvitations, useListOrganizations }, localization: contextLocalization } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const { data: invitations, refetch: refetchInvitations } = useListUserInvitations();
	const { refetch: refetchOrganizations } = useListOrganizations();
	const handleRefresh = async () => {
		await (refetchInvitations == null ? void 0 : refetchInvitations());
		await (refetchOrganizations == null ? void 0 : refetchOrganizations());
	};
	const pendingInvitations = invitations == null ? void 0 : invitations.filter((invitation) => invitation.status === "pending");
	if (!(pendingInvitations == null ? void 0 : pendingInvitations.length)) return null;
	return /* @__PURE__ */ jsx(SettingsCard, {
		className,
		classNames,
		title: localization.PENDING_INVITATIONS,
		description: localization.PENDING_USER_INVITATIONS_DESCRIPTION || localization.PENDING_INVITATIONS_DESCRIPTION,
		...props,
		children: /* @__PURE__ */ jsx(CardContent, {
			className: cn("grid gap-4", classNames == null ? void 0 : classNames.content),
			children: pendingInvitations.map((invitation) => /* @__PURE__ */ jsx(UserInvitationRow, {
				classNames,
				invitation: {
					id: invitation.id,
					email: invitation.email,
					role: invitation.role,
					status: invitation.status,
					expiresAt: invitation.expiresAt
				},
				onChanged: handleRefresh
			}, invitation.id))
		})
	});
}
function UserInvitationRow({ classNames, invitation, onChanged }) {
	const { authClient: authClient2, organization: organizationOptions, localization: contextLocalization, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	const localization = contextLocalization;
	const { lang } = useLang();
	const [isLoading, setIsLoading] = useState(false);
	const role$1 = [...[
		{
			role: "owner",
			label: localization.OWNER
		},
		{
			role: "admin",
			label: localization.ADMIN
		},
		{
			role: "member",
			label: localization.MEMBER
		}
	], ...(organizationOptions == null ? void 0 : organizationOptions.customRoles) || []].find((r) => r.role === invitation.role);
	const handleAccept = async () => {
		setIsLoading(true);
		try {
			await authClient2.organization.acceptInvitation({
				invitationId: invitation.id,
				fetchOptions: { throw: true }
			});
			await (onChanged == null ? void 0 : onChanged());
			toast$1({
				variant: "success",
				message: localization.INVITATION_ACCEPTED
			});
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
		setIsLoading(false);
	};
	const handleReject = async () => {
		setIsLoading(true);
		try {
			await authClient2.organization.rejectInvitation({
				invitationId: invitation.id,
				fetchOptions: { throw: true }
			});
			await (onChanged == null ? void 0 : onChanged());
			toast$1({
				variant: "success",
				message: localization.INVITATION_REJECTED
			});
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
		setIsLoading(false);
	};
	return /* @__PURE__ */ jsxs(Card, {
		className: cn("flex-row items-center p-4", classNames == null ? void 0 : classNames.cell),
		children: [
			/* @__PURE__ */ jsxs("div", {
				className: "flex flex-1 items-center gap-2",
				children: [/* @__PURE__ */ jsx(UserAvatar, {
					className: "my-0.5",
					user: { email: invitation.email },
					localization
				}), /* @__PURE__ */ jsxs("div", {
					className: "grid flex-1 text-left leading-tight",
					children: [/* @__PURE__ */ jsx("span", {
						className: "truncate font-semibold text-sm",
						children: invitation.email
					}), /* @__PURE__ */ jsxs("span", {
						className: "truncate text-muted-foreground text-xs",
						children: [
							localization.EXPIRES,
							" ",
							invitation.expiresAt.toLocaleDateString(lang ?? "en")
						]
					})]
				})]
			}),
			/* @__PURE__ */ jsx("span", {
				className: "truncate text-sm opacity-70",
				children: role$1 == null ? void 0 : role$1.label
			}),
			/* @__PURE__ */ jsx("div", {
				className: "flex items-center gap-2",
				children: /* @__PURE__ */ jsxs(DropdownMenu, { children: [/* @__PURE__ */ jsx(DropdownMenuTrigger, {
					asChild: true,
					children: /* @__PURE__ */ jsx(Button, {
						className: cn("relative ms-auto", classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.outlineButton),
						disabled: isLoading,
						size: "icon",
						type: "button",
						variant: "outline",
						children: isLoading ? /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }) : /* @__PURE__ */ jsx(EllipsisIcon, { className: classNames == null ? void 0 : classNames.icon })
					})
				}), /* @__PURE__ */ jsxs(DropdownMenuContent, {
					onCloseAutoFocus: (e) => e.preventDefault(),
					children: [/* @__PURE__ */ jsxs(DropdownMenuItem, {
						onClick: handleAccept,
						disabled: isLoading,
						children: [/* @__PURE__ */ jsx(CheckIcon, { className: classNames == null ? void 0 : classNames.icon }), localization.ACCEPT]
					}), /* @__PURE__ */ jsxs(DropdownMenuItem, {
						onClick: handleReject,
						disabled: isLoading,
						variant: "destructive",
						children: [/* @__PURE__ */ jsx(XIcon, { className: classNames == null ? void 0 : classNames.icon }), localization.REJECT]
					})]
				})] })
			})
		]
	});
}
function UserView({ className, classNames, isPending, size, user, localization: propLocalization }) {
	const { localization: contextLocalization } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...propLocalization
	}), [contextLocalization, propLocalization]);
	return /* @__PURE__ */ jsxs("div", {
		className: cn("flex items-center gap-2", className, classNames == null ? void 0 : classNames.base),
		children: [/* @__PURE__ */ jsx(UserAvatar, {
			className: cn(size !== "sm" && "my-0.5"),
			classNames: classNames == null ? void 0 : classNames.avatar,
			isPending,
			size,
			user,
			localization
		}), /* @__PURE__ */ jsx("div", {
			className: cn("grid flex-1 text-start leading-tight", classNames == null ? void 0 : classNames.content),
			children: isPending ? /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(Skeleton, { className: cn("max-w-full", size === "lg" ? "h-4.5 w-32" : "h-3.5 w-24", classNames == null ? void 0 : classNames.title, classNames == null ? void 0 : classNames.skeleton) }), size !== "sm" && /* @__PURE__ */ jsx(Skeleton, { className: cn("mt-1.5 max-w-full", size === "lg" ? "h-3.5 w-40" : "h-3 w-32", classNames == null ? void 0 : classNames.subtitle, classNames == null ? void 0 : classNames.skeleton) })] }) : /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx("span", {
				className: cn("truncate font-semibold", size === "lg" ? "text-base" : "text-sm", classNames == null ? void 0 : classNames.title),
				children: (user == null ? void 0 : user.displayName) || (user == null ? void 0 : user.name) || (user == null ? void 0 : user.fullName) || (user == null ? void 0 : user.firstName) || (user == null ? void 0 : user.displayUsername) || (user == null ? void 0 : user.username) || (user == null ? void 0 : user.email) || (localization == null ? void 0 : localization.USER)
			}), !(user == null ? void 0 : user.isAnonymous) && size !== "sm" && ((user == null ? void 0 : user.name) || (user == null ? void 0 : user.username)) && /* @__PURE__ */ jsx("span", {
				className: cn("truncate opacity-70", size === "lg" ? "text-sm" : "text-xs", classNames == null ? void 0 : classNames.subtitle),
				children: user == null ? void 0 : user.email
			})] })
		})]
	});
}
function AccountCell({ className, classNames, deviceSession, localization, refetch }) {
	const { basePath, localization: contextLocalization, hooks: { useSession }, mutators: { revokeDeviceSession, setActiveSession }, toast: toast$1, viewPaths, navigate, localizeErrors } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const { data: sessionData } = useSession();
	const [isLoading, setIsLoading] = useState(false);
	const handleRevoke = async () => {
		setIsLoading(true);
		try {
			await revokeDeviceSession({ sessionToken: deviceSession.session.token });
			refetch?.();
		} catch (error) {
			setIsLoading(false);
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
	};
	const handleSetActiveSession = async () => {
		setIsLoading(true);
		try {
			await setActiveSession({ sessionToken: deviceSession.session.token });
			refetch?.();
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
		setIsLoading(false);
	};
	const isCurrentSession = deviceSession.session.id === (sessionData == null ? void 0 : sessionData.session.id);
	return /* @__PURE__ */ jsxs(Card, {
		className: cn("flex-row p-4", className, classNames == null ? void 0 : classNames.cell),
		children: [/* @__PURE__ */ jsx(UserView, {
			user: deviceSession.user,
			localization
		}), /* @__PURE__ */ jsxs(DropdownMenu, { children: [/* @__PURE__ */ jsx(DropdownMenuTrigger, {
			asChild: true,
			children: /* @__PURE__ */ jsx(Button, {
				className: cn("relative ms-auto", classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.outlineButton),
				disabled: isLoading,
				size: "icon",
				type: "button",
				variant: "outline",
				children: isLoading ? /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }) : /* @__PURE__ */ jsx(EllipsisIcon, { className: classNames == null ? void 0 : classNames.icon })
			})
		}), /* @__PURE__ */ jsxs(DropdownMenuContent, { children: [!isCurrentSession && /* @__PURE__ */ jsxs(DropdownMenuItem, {
			onClick: handleSetActiveSession,
			children: [/* @__PURE__ */ jsx(RepeatIcon, { className: classNames == null ? void 0 : classNames.icon }), localization.SWITCH_ACCOUNT]
		}), /* @__PURE__ */ jsxs(DropdownMenuItem, {
			onClick: () => {
				if (isCurrentSession) {
					navigate(`${basePath}/${viewPaths.SIGN_OUT}`);
					return;
				}
				handleRevoke();
			},
			variant: "destructive",
			children: [isCurrentSession ? /* @__PURE__ */ jsx(LogOutIcon, { className: classNames == null ? void 0 : classNames.icon }) : /* @__PURE__ */ jsx(UserX2Icon, { className: classNames == null ? void 0 : classNames.icon }), isCurrentSession ? localization.SIGN_OUT : localization.REVOKE]
		})] })] })]
	});
}
function AccountsCard({ className, classNames, localization }) {
	const { basePath, hooks: { useListDeviceSessions, useSession }, localization: contextLocalization, viewPaths, navigate } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const { data: deviceSessions, isPending, refetch } = useListDeviceSessions();
	const { data: sessionData } = useSession();
	const otherDeviceSessions = (deviceSessions || []).filter((ds) => ds.session.id !== (sessionData == null ? void 0 : sessionData.session.id));
	return /* @__PURE__ */ jsx(SettingsCard, {
		className,
		classNames,
		title: localization.ACCOUNTS,
		description: localization.ACCOUNTS_DESCRIPTION,
		actionLabel: localization.ADD_ACCOUNT,
		instructions: localization.ACCOUNTS_INSTRUCTIONS,
		isPending,
		action: () => navigate(`${basePath}/${viewPaths.SIGN_IN}`),
		children: (deviceSessions == null ? void 0 : deviceSessions.length) ? /* @__PURE__ */ jsxs(CardContent, {
			className: cn("grid gap-4", classNames == null ? void 0 : classNames.content),
			children: [sessionData && /* @__PURE__ */ jsx(AccountCell, {
				classNames,
				deviceSession: sessionData,
				localization,
				refetch
			}), otherDeviceSessions.map((deviceSession) => /* @__PURE__ */ jsx(AccountCell, {
				classNames,
				deviceSession,
				localization,
				refetch
			}, deviceSession.session.id))]
		}) : null
	});
}
function UpdateAvatarCard({ className, classNames, localization, ...props }) {
	const { hooks: { useSession }, mutators: { updateUser }, localization: authLocalization2, optimistic, avatar, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	localization = {
		...authLocalization2,
		...localization
	};
	const { data: sessionData, isPending, refetch } = useSession();
	const fileInputRef = useRef(null);
	const [loading, setLoading] = useState(false);
	const handleAvatarChange = async (file) => {
		if (!sessionData || !avatar) return;
		setLoading(true);
		const resizedFile = await resizeAndCropImage(file, crypto.randomUUID(), avatar.size, avatar.extension);
		let image;
		if (avatar.upload) image = await avatar.upload(resizedFile);
		else image = await fileToBase64(resizedFile);
		if (!image) {
			setLoading(false);
			return;
		}
		if (optimistic && !avatar.upload) setLoading(false);
		try {
			await updateUser({ image });
			await (refetch == null ? void 0 : refetch());
			if (avatar.upload && avatar.delete && sessionData.user.image) try {
				await avatar.delete(sessionData.user.image);
			} catch (error) {
				console.error("Failed to delete old avatar:", error);
			}
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
		setLoading(false);
	};
	const handleDeleteAvatar = async () => {
		if (!sessionData) return;
		setLoading(true);
		try {
			if (sessionData.user.image && (avatar == null ? void 0 : avatar.delete)) await avatar.delete(sessionData.user.image);
			await updateUser({ image: null });
			await (refetch == null ? void 0 : refetch());
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
		setLoading(false);
	};
	const openFileDialog = () => {
		var _a;
		return (_a = fileInputRef.current) == null ? void 0 : _a.click();
	};
	return /* @__PURE__ */ jsxs(Card, {
		className: cn("w-full pb-0 text-start", className, classNames == null ? void 0 : classNames.base),
		...props,
		children: [
			/* @__PURE__ */ jsx("input", {
				ref: fileInputRef,
				accept: "image/*",
				disabled: loading,
				hidden: true,
				type: "file",
				onChange: (e) => {
					var _a;
					const file = (_a = e.target.files) == null ? void 0 : _a.item(0);
					if (file) handleAvatarChange(file);
					e.target.value = "";
				}
			}),
			/* @__PURE__ */ jsxs("div", {
				className: "flex justify-between",
				children: [/* @__PURE__ */ jsx(SettingsCardHeader, {
					className: "grow self-start",
					title: localization.AVATAR,
					description: localization.AVATAR_DESCRIPTION,
					isPending,
					classNames
				}), /* @__PURE__ */ jsxs(DropdownMenu, { children: [/* @__PURE__ */ jsx(DropdownMenuTrigger, {
					asChild: true,
					children: /* @__PURE__ */ jsx(Button, {
						className: "me-6 size-fit rounded-full",
						size: "icon",
						variant: "ghost",
						children: /* @__PURE__ */ jsx(UserAvatar, {
							isPending: isPending || loading,
							className: "size-20 text-2xl",
							classNames: classNames == null ? void 0 : classNames.avatar,
							user: sessionData == null ? void 0 : sessionData.user,
							localization
						}, sessionData == null ? void 0 : sessionData.user.image)
					})
				}), /* @__PURE__ */ jsxs(DropdownMenuContent, {
					align: "end",
					onCloseAutoFocus: (e) => e.preventDefault(),
					children: [/* @__PURE__ */ jsxs(DropdownMenuItem, {
						onClick: openFileDialog,
						disabled: loading,
						children: [/* @__PURE__ */ jsx(UploadCloudIcon, {}), localization.UPLOAD_AVATAR]
					}), (sessionData == null ? void 0 : sessionData.user.image) && /* @__PURE__ */ jsxs(DropdownMenuItem, {
						onClick: handleDeleteAvatar,
						disabled: loading,
						variant: "destructive",
						children: [/* @__PURE__ */ jsx(Trash2Icon, {}), localization.DELETE_AVATAR]
					})]
				})] })]
			}),
			/* @__PURE__ */ jsx(SettingsCardFooter, {
				className: "!py-5",
				instructions: localization.AVATAR_INSTRUCTIONS,
				classNames,
				isPending,
				isSubmitting: loading
			})
		]
	});
}
function Checkbox({ className, ...props }) {
	return /* @__PURE__ */ jsx(CheckboxPrimitive.Root, {
		"data-slot": "checkbox",
		className: cn("peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50", className),
		...props,
		children: /* @__PURE__ */ jsx(CheckboxPrimitive.Indicator, {
			"data-slot": "checkbox-indicator",
			className: "flex items-center justify-center text-current transition-none",
			children: /* @__PURE__ */ jsx(CheckIcon, { className: "size-3.5" })
		})
	});
}
function Textarea({ className, ...props }) {
	return /* @__PURE__ */ jsx("textarea", {
		"data-slot": "textarea",
		className: cn("border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", className),
		...props
	});
}
function UpdateFieldCard({ className, classNames, description, instructions, localization: localizationProp, name, placeholder, required, label, type, multiline, value, validate }) {
	const { hooks: { useSession }, mutators: { updateUser }, localization: contextLocalization, optimistic, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const { isPending } = useSession();
	let fieldSchema = z$1.unknown();
	if (type === "number") fieldSchema = required ? z$1.preprocess((val) => !val ? void 0 : Number(val), z$1.number({ message: `${label} ${localization.IS_INVALID}` })) : z$1.coerce.number({ message: `${label} ${localization.IS_INVALID}` }).optional();
	else if (type === "boolean") fieldSchema = required ? z$1.coerce.boolean({ message: `${label} ${localization.IS_INVALID}` }).refine((val) => val === true, { message: `${label} ${localization.IS_REQUIRED}` }) : z$1.coerce.boolean({ message: `${label} ${localization.IS_INVALID}` });
	else fieldSchema = required ? z$1.string().min(1, `${label} ${localization.IS_REQUIRED}`) : z$1.string().optional();
	const form = useForm({
		resolver: zodResolver(z$1.object({ [name]: fieldSchema })),
		values: { [name]: value || "" }
	});
	const { isSubmitting } = form.formState;
	const updateField = async (values) => {
		await new Promise((resolve) => setTimeout(resolve));
		const newValue = values[name];
		if (value === newValue) {
			toast$1({
				variant: "error",
				message: `${label} ${localization.IS_THE_SAME}`
			});
			return;
		}
		if (validate && typeof newValue === "string" && !await validate(newValue)) {
			form.setError(name, { message: `${label} ${localization.IS_INVALID}` });
			return;
		}
		try {
			await updateUser({ [name]: newValue });
			toast$1({
				variant: "success",
				message: `${label} ${localization.UPDATED_SUCCESSFULLY}`
			});
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
	};
	return /* @__PURE__ */ jsx(Form, {
		...form,
		children: /* @__PURE__ */ jsx("form", {
			onSubmit: form.handleSubmit(updateField),
			children: /* @__PURE__ */ jsx(SettingsCard, {
				className,
				classNames,
				description,
				instructions,
				isPending,
				title: label,
				actionLabel: localization.SAVE,
				optimistic,
				children: /* @__PURE__ */ jsx(CardContent, {
					className: classNames == null ? void 0 : classNames.content,
					children: type === "boolean" ? /* @__PURE__ */ jsx(FormField, {
						control: form.control,
						name,
						render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, {
							className: "flex",
							children: [
								/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(Checkbox, {
									checked: field.value,
									onCheckedChange: field.onChange,
									disabled: isSubmitting,
									className: classNames == null ? void 0 : classNames.checkbox
								}) }),
								/* @__PURE__ */ jsx(FormLabel, {
									className: classNames == null ? void 0 : classNames.label,
									children: label
								}),
								/* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })
							]
						})
					}) : isPending ? /* @__PURE__ */ jsx(Skeleton, { className: cn("h-9 w-full", classNames == null ? void 0 : classNames.skeleton) }) : /* @__PURE__ */ jsx(FormField, {
						control: form.control,
						name,
						render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [/* @__PURE__ */ jsx(FormControl, { children: type === "number" ? /* @__PURE__ */ jsx(Input, {
							className: classNames == null ? void 0 : classNames.input,
							type: "number",
							placeholder: placeholder || (typeof label === "string" ? label : ""),
							disabled: isSubmitting,
							...field,
							value: field.value
						}) : multiline ? /* @__PURE__ */ jsx(Textarea, {
							className: classNames == null ? void 0 : classNames.input,
							placeholder: placeholder || (typeof label === "string" ? label : ""),
							disabled: isSubmitting,
							...field,
							value: field.value
						}) : /* @__PURE__ */ jsx(Input, {
							className: classNames == null ? void 0 : classNames.input,
							type: "text",
							placeholder: placeholder || (typeof label === "string" ? label : ""),
							disabled: isSubmitting,
							...field,
							value: field.value
						}) }), /* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })] })
					})
				})
			})
		})
	});
}
function UpdateNameCard({ className, classNames, localization, ...props }) {
	const { hooks: { useSession }, localization: contextLocalization, nameRequired } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const { data: sessionData } = useSession();
	return /* @__PURE__ */ jsx(UpdateFieldCard, {
		className,
		classNames,
		value: sessionData == null ? void 0 : sessionData.user.name,
		description: localization.NAME_DESCRIPTION,
		name: "name",
		instructions: localization.NAME_INSTRUCTIONS,
		label: localization.NAME,
		localization,
		placeholder: localization.NAME_PLACEHOLDER,
		required: nameRequired,
		...props
	});
}
function UpdateUsernameCard({ className, classNames, localization, ...props }) {
	var _a, _b;
	const { hooks: { useSession }, localization: contextLocalization } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const { data: sessionData } = useSession();
	return /* @__PURE__ */ jsx(UpdateFieldCard, {
		className,
		classNames,
		value: ((_a = sessionData == null ? void 0 : sessionData.user) == null ? void 0 : _a.displayUsername) || ((_b = sessionData == null ? void 0 : sessionData.user) == null ? void 0 : _b.username),
		description: localization.USERNAME_DESCRIPTION,
		name: "username",
		instructions: localization.USERNAME_INSTRUCTIONS,
		label: localization.USERNAME,
		localization,
		placeholder: localization.USERNAME_PLACEHOLDER,
		required: true,
		...props
	});
}
function ChangeEmailCard({ className, classNames, localization, ...props }) {
	const { authClient: authClient2, emailVerification, hooks: { useSession }, localization: contextLocalization, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const { data: sessionData, isPending, refetch } = useSession();
	const [resendDisabled, setResendDisabled] = useState(false);
	const form = useForm({
		resolver: zodResolver(z$1.object({ email: z$1.string().email({ message: localization.INVALID_EMAIL }) })),
		values: { email: (sessionData == null ? void 0 : sessionData.user.email) || "" }
	});
	const resendForm = useForm();
	const { isSubmitting } = form.formState;
	const changeEmail = async ({ email }) => {
		if (email === (sessionData == null ? void 0 : sessionData.user.email)) {
			await new Promise((resolve) => setTimeout(resolve));
			toast$1({
				variant: "error",
				message: localization.EMAIL_IS_THE_SAME
			});
			return;
		}
		try {
			await authClient2.changeEmail({
				newEmail: email,
				callbackURL: window.location.pathname,
				fetchOptions: { throw: true }
			});
			if (sessionData == null ? void 0 : sessionData.user.emailVerified) toast$1({
				variant: "success",
				message: localization.EMAIL_VERIFY_CHANGE
			});
			else {
				await (refetch == null ? void 0 : refetch());
				toast$1({
					variant: "success",
					message: `${localization.EMAIL} ${localization.UPDATED_SUCCESSFULLY}`
				});
			}
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
	};
	const resendVerification = async () => {
		if (!sessionData) return;
		const email = sessionData.user.email;
		setResendDisabled(true);
		try {
			await authClient2.sendVerificationEmail({
				email,
				fetchOptions: { throw: true }
			});
			toast$1({
				variant: "success",
				message: localization.EMAIL_VERIFICATION
			});
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
			setResendDisabled(false);
			throw error;
		}
	};
	return /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(Form, {
		...form,
		children: /* @__PURE__ */ jsx("form", {
			noValidate: true,
			onSubmit: form.handleSubmit(changeEmail),
			children: /* @__PURE__ */ jsx(SettingsCard, {
				className,
				classNames,
				description: localization.EMAIL_DESCRIPTION,
				instructions: localization.EMAIL_INSTRUCTIONS,
				isPending,
				title: localization.EMAIL,
				actionLabel: localization.SAVE,
				...props,
				children: /* @__PURE__ */ jsx(CardContent, {
					className: classNames == null ? void 0 : classNames.content,
					children: isPending ? /* @__PURE__ */ jsx(Skeleton, { className: cn("h-9 w-full", classNames == null ? void 0 : classNames.skeleton) }) : /* @__PURE__ */ jsx(FormField, {
						control: form.control,
						name: "email",
						render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(Input, {
							className: classNames == null ? void 0 : classNames.input,
							placeholder: localization.EMAIL_PLACEHOLDER,
							type: "email",
							disabled: isSubmitting,
							...field
						}) }), /* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })] })
					})
				})
			})
		})
	}), emailVerification && (sessionData == null ? void 0 : sessionData.user) && !(sessionData == null ? void 0 : sessionData.user.emailVerified) && /* @__PURE__ */ jsx(Form, {
		...resendForm,
		children: /* @__PURE__ */ jsx("form", {
			onSubmit: resendForm.handleSubmit(resendVerification),
			children: /* @__PURE__ */ jsx(SettingsCard, {
				className,
				classNames,
				title: localization.VERIFY_YOUR_EMAIL,
				description: localization.VERIFY_YOUR_EMAIL_DESCRIPTION,
				actionLabel: localization.RESEND_VERIFICATION_EMAIL,
				disabled: resendDisabled,
				...props
			})
		})
	})] });
}
function AccountSettingsCards({ className, classNames, localization }) {
	var _a, _b, _c;
	const { additionalFields, avatar, changeEmail, credentials, hooks: { useSession }, multiSession, account: accountOptions } = useContext(AuthUIContext);
	const { data: sessionData } = useSession();
	return /* @__PURE__ */ jsxs("div", {
		className: cn("flex w-full flex-col gap-4 md:gap-6", className, classNames == null ? void 0 : classNames.cards),
		children: [
			((_a = accountOptions == null ? void 0 : accountOptions.fields) == null ? void 0 : _a.includes("image")) && avatar && /* @__PURE__ */ jsx(UpdateAvatarCard, {
				classNames: classNames == null ? void 0 : classNames.card,
				localization
			}),
			(credentials == null ? void 0 : credentials.username) && /* @__PURE__ */ jsx(UpdateUsernameCard, {
				classNames: classNames == null ? void 0 : classNames.card,
				localization
			}),
			((_b = accountOptions == null ? void 0 : accountOptions.fields) == null ? void 0 : _b.includes("name")) && /* @__PURE__ */ jsx(UpdateNameCard, {
				classNames: classNames == null ? void 0 : classNames.card,
				localization
			}),
			changeEmail && /* @__PURE__ */ jsx(ChangeEmailCard, {
				classNames: classNames == null ? void 0 : classNames.card,
				localization
			}),
			(_c = accountOptions == null ? void 0 : accountOptions.fields) == null ? void 0 : _c.map((field) => {
				if (field === "image") return null;
				if (field === "name") return null;
				const additionalField = additionalFields == null ? void 0 : additionalFields[field];
				if (!additionalField) return null;
				const { label, description, instructions, placeholder, required, type, multiline, validate } = additionalField;
				const defaultValue = sessionData == null ? void 0 : sessionData.user[field];
				return /* @__PURE__ */ jsx(UpdateFieldCard, {
					classNames: classNames == null ? void 0 : classNames.card,
					value: defaultValue,
					description,
					name: field,
					instructions,
					label,
					localization,
					placeholder,
					required,
					type,
					multiline,
					validate
				}, field);
			}),
			multiSession && /* @__PURE__ */ jsx(AccountsCard, {
				classNames: classNames == null ? void 0 : classNames.card,
				localization
			})
		]
	});
}
function ApiKeyDeleteDialog({ classNames, apiKey, localization, refetch, onOpenChange, ...props }) {
	var _a, _b, _c;
	const { localization: contextLocalization, mutators: { deleteApiKey }, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const { lang } = useLang();
	const [isLoading, setIsLoading] = useState(false);
	const handleDelete = async () => {
		setIsLoading(true);
		try {
			await deleteApiKey({ keyId: apiKey.id });
			await (refetch == null ? void 0 : refetch());
			onOpenChange?.(false);
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
		setIsLoading(false);
	};
	const formatExpiration = () => {
		if (!apiKey.expiresAt) return localization.NEVER_EXPIRES;
		const expiresDate = new Date(apiKey.expiresAt);
		return `${localization.EXPIRES} ${expiresDate.toLocaleDateString(lang ?? "en", {
			month: "short",
			day: "numeric",
			year: "numeric"
		})}`;
	};
	return /* @__PURE__ */ jsx(Dialog, {
		onOpenChange,
		...props,
		children: /* @__PURE__ */ jsxs(DialogContent, {
			onOpenAutoFocus: (e) => e.preventDefault(),
			className: (_a = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _a.content,
			children: [
				/* @__PURE__ */ jsxs(DialogHeader, {
					className: (_b = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _b.header,
					children: [/* @__PURE__ */ jsxs(DialogTitle, {
						className: cn("text-lg md:text-xl", classNames == null ? void 0 : classNames.title),
						children: [
							localization.DELETE,
							" ",
							localization.API_KEY
						]
					}), /* @__PURE__ */ jsx(DialogDescription, {
						className: cn("text-xs md:text-sm", classNames == null ? void 0 : classNames.description),
						children: localization.DELETE_API_KEY_CONFIRM
					})]
				}),
				/* @__PURE__ */ jsxs(Card, {
					className: cn("my-2 flex-row items-center gap-3 px-4 py-3", classNames == null ? void 0 : classNames.cell),
					children: [/* @__PURE__ */ jsx(KeyRoundIcon, { className: cn("size-4", classNames == null ? void 0 : classNames.icon) }), /* @__PURE__ */ jsxs("div", {
						className: "flex flex-col",
						children: [/* @__PURE__ */ jsxs("div", {
							className: "flex items-center gap-2",
							children: [/* @__PURE__ */ jsx("span", {
								className: "font-semibold text-sm",
								children: apiKey.name
							}), /* @__PURE__ */ jsxs("span", {
								className: "text-muted-foreground text-sm",
								children: [apiKey.start, "******"]
							})]
						}), /* @__PURE__ */ jsx("div", {
							className: "text-muted-foreground text-xs",
							children: formatExpiration()
						})]
					})]
				}),
				/* @__PURE__ */ jsxs(DialogFooter, {
					className: (_c = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _c.footer,
					children: [/* @__PURE__ */ jsx(Button, {
						type: "button",
						variant: "secondary",
						onClick: () => onOpenChange == null ? void 0 : onOpenChange(false),
						disabled: isLoading,
						className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.secondaryButton),
						children: localization.CANCEL
					}), /* @__PURE__ */ jsxs(Button, {
						type: "button",
						variant: "destructive",
						onClick: handleDelete,
						disabled: isLoading,
						className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.destructiveButton),
						children: [isLoading && /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }), localization.DELETE]
					})]
				})
			]
		})
	});
}
function ApiKeyCell({ className, classNames, apiKey, localization, refetch }) {
	const { localization: contextLocalization } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const { lang } = useLang();
	const [showDeleteDialog, setShowDeleteDialog] = useState(false);
	const formatExpiration = () => {
		if (!apiKey.expiresAt) return localization.NEVER_EXPIRES;
		const expiresDate = new Date(apiKey.expiresAt);
		return `${localization.EXPIRES} ${expiresDate.toLocaleDateString(lang ?? "en", {
			month: "short",
			day: "numeric",
			year: "numeric"
		})}`;
	};
	return /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsxs(Card, {
		className: cn("flex-row items-center gap-3 truncate px-4 py-3", className, classNames == null ? void 0 : classNames.cell),
		children: [
			/* @__PURE__ */ jsx(KeyRoundIcon, { className: cn("size-4 flex-shrink-0", classNames == null ? void 0 : classNames.icon) }),
			/* @__PURE__ */ jsxs("div", {
				className: "flex flex-col truncate",
				children: [/* @__PURE__ */ jsxs("div", {
					className: "flex items-center gap-2",
					children: [/* @__PURE__ */ jsx("span", {
						className: "truncate font-semibold text-sm",
						children: apiKey.name
					}), /* @__PURE__ */ jsxs("span", {
						className: "flex-1 truncate text-muted-foreground text-sm",
						children: [apiKey.start, "******"]
					})]
				}), /* @__PURE__ */ jsx("div", {
					className: "truncate text-muted-foreground text-xs",
					children: formatExpiration()
				})]
			}),
			/* @__PURE__ */ jsx(Button, {
				className: cn("relative ms-auto", classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.outlineButton),
				size: "sm",
				variant: "outline",
				onClick: () => setShowDeleteDialog(true),
				children: localization.DELETE
			})
		]
	}), /* @__PURE__ */ jsx(ApiKeyDeleteDialog, {
		classNames,
		apiKey,
		localization,
		open: showDeleteDialog,
		onOpenChange: setShowDeleteDialog,
		refetch
	})] });
}
function ApiKeyDisplayDialog({ classNames, apiKey, localization, onOpenChange, ...props }) {
	var _a, _b, _c;
	const { localization: contextLocalization } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const [copied, setCopied] = useState(false);
	const handleCopy = () => {
		navigator.clipboard.writeText(apiKey);
		setCopied(true);
		setTimeout(() => setCopied(false), 2e3);
	};
	return /* @__PURE__ */ jsx(Dialog, {
		onOpenChange,
		...props,
		children: /* @__PURE__ */ jsxs(DialogContent, {
			onOpenAutoFocus: (e) => e.preventDefault(),
			className: (_a = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _a.content,
			children: [
				/* @__PURE__ */ jsxs(DialogHeader, {
					className: (_b = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _b.header,
					children: [/* @__PURE__ */ jsx(DialogTitle, {
						className: cn("text-lg md:text-xl", classNames == null ? void 0 : classNames.title),
						children: localization.API_KEY_CREATED
					}), /* @__PURE__ */ jsx(DialogDescription, {
						className: cn("text-xs md:text-sm", classNames == null ? void 0 : classNames.description),
						children: localization.CREATE_API_KEY_SUCCESS
					})]
				}),
				/* @__PURE__ */ jsx("div", {
					className: "break-all rounded-md bg-muted p-4 font-mono text-sm",
					children: apiKey
				}),
				/* @__PURE__ */ jsxs(DialogFooter, {
					className: (_c = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _c.footer,
					children: [/* @__PURE__ */ jsx(Button, {
						type: "button",
						variant: "outline",
						onClick: handleCopy,
						disabled: copied,
						className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.outlineButton),
						children: copied ? /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(CheckIcon, { className: classNames == null ? void 0 : classNames.icon }), localization.COPIED_TO_CLIPBOARD] }) : /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(CopyIcon, { className: classNames == null ? void 0 : classNames.icon }), localization.COPY_TO_CLIPBOARD] })
					}), /* @__PURE__ */ jsx(Button, {
						type: "button",
						variant: "default",
						onClick: () => onOpenChange == null ? void 0 : onOpenChange(false),
						className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.primaryButton),
						children: localization.DONE
					})]
				})
			]
		})
	});
}
function PersonalAccountView({ className, classNames, isPending, size, user, localization: propLocalization }) {
	const { localization: contextLocalization } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...propLocalization
	}), [contextLocalization, propLocalization]);
	return /* @__PURE__ */ jsxs("div", {
		className: cn("flex items-center gap-2", className, classNames == null ? void 0 : classNames.base),
		children: [/* @__PURE__ */ jsx(UserAvatar, {
			className: cn(size !== "sm" && "my-0.5"),
			classNames: classNames == null ? void 0 : classNames.avatar,
			isPending,
			localization,
			size,
			user
		}), /* @__PURE__ */ jsx("div", {
			className: cn("grid flex-1 text-left leading-tight", classNames == null ? void 0 : classNames.content),
			children: isPending ? /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(Skeleton, { className: cn("max-w-full", size === "lg" ? "h-4.5 w-32" : "h-3.5 w-24", classNames == null ? void 0 : classNames.title, classNames == null ? void 0 : classNames.skeleton) }), size !== "sm" && /* @__PURE__ */ jsx(Skeleton, { className: cn("mt-1.5 max-w-full", size === "lg" ? "h-3.5 w-40" : "h-3 w-32", classNames == null ? void 0 : classNames.subtitle, classNames == null ? void 0 : classNames.skeleton) })] }) : /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx("span", {
				className: cn("truncate font-semibold", size === "lg" ? "text-base" : "text-sm", classNames == null ? void 0 : classNames.title),
				children: (user == null ? void 0 : user.displayName) || (user == null ? void 0 : user.name) || (user == null ? void 0 : user.fullName) || (user == null ? void 0 : user.firstName) || (user == null ? void 0 : user.displayUsername) || (user == null ? void 0 : user.username) || (user == null ? void 0 : user.email) || (localization == null ? void 0 : localization.USER)
			}), size !== "sm" && /* @__PURE__ */ jsx("span", {
				className: cn("truncate opacity-70", size === "lg" ? "text-sm" : "text-xs", classNames == null ? void 0 : classNames.subtitle),
				children: localization == null ? void 0 : localization.PERSONAL_ACCOUNT
			})] })
		})]
	});
}
function Select({ ...props }) {
	return /* @__PURE__ */ jsx(SelectPrimitive.Root, {
		"data-slot": "select",
		...props
	});
}
function SelectValue({ ...props }) {
	return /* @__PURE__ */ jsx(SelectPrimitive.Value, {
		"data-slot": "select-value",
		...props
	});
}
function SelectTrigger({ className, size = "default", children, ...props }) {
	return /* @__PURE__ */ jsxs(SelectPrimitive.Trigger, {
		"data-slot": "select-trigger",
		"data-size": size,
		className: cn("border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", className),
		...props,
		children: [children, /* @__PURE__ */ jsx(SelectPrimitive.Icon, {
			asChild: true,
			children: /* @__PURE__ */ jsx(ChevronDownIcon, { className: "size-4 opacity-50" })
		})]
	});
}
function SelectContent({ className, children, position = "popper", ...props }) {
	return /* @__PURE__ */ jsx(SelectPrimitive.Portal, { children: /* @__PURE__ */ jsxs(SelectPrimitive.Content, {
		"data-slot": "select-content",
		className: cn("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md", position === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1", className),
		position,
		...props,
		children: [
			/* @__PURE__ */ jsx(SelectScrollUpButton, {}),
			/* @__PURE__ */ jsx(SelectPrimitive.Viewport, {
				className: cn("p-1", position === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"),
				children
			}),
			/* @__PURE__ */ jsx(SelectScrollDownButton, {})
		]
	}) });
}
function SelectItem({ className, children, ...props }) {
	return /* @__PURE__ */ jsxs(SelectPrimitive.Item, {
		"data-slot": "select-item",
		className: cn("focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2", className),
		...props,
		children: [/* @__PURE__ */ jsx("span", {
			className: "absolute right-2 flex size-3.5 items-center justify-center",
			children: /* @__PURE__ */ jsx(SelectPrimitive.ItemIndicator, { children: /* @__PURE__ */ jsx(CheckIcon, { className: "size-4" }) })
		}), /* @__PURE__ */ jsx(SelectPrimitive.ItemText, { children })]
	});
}
function SelectScrollUpButton({ className, ...props }) {
	return /* @__PURE__ */ jsx(SelectPrimitive.ScrollUpButton, {
		"data-slot": "select-scroll-up-button",
		className: cn("flex cursor-default items-center justify-center py-1", className),
		...props,
		children: /* @__PURE__ */ jsx(ChevronUpIcon, { className: "size-4" })
	});
}
function SelectScrollDownButton({ className, ...props }) {
	return /* @__PURE__ */ jsx(SelectPrimitive.ScrollDownButton, {
		"data-slot": "select-scroll-down-button",
		className: cn("flex cursor-default items-center justify-center py-1", className),
		...props,
		children: /* @__PURE__ */ jsx(ChevronDownIcon, { className: "size-4" })
	});
}
function CreateApiKeyDialog({ classNames, localization, onSuccess, refetch, organizationId, onOpenChange, ...props }) {
	var _a, _b, _c;
	const { authClient: authClient2, apiKey, hooks: { useListOrganizations, useSession }, localization: contextLocalization, organization: contextOrganization, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const { lang } = useLang();
	let organizations;
	if (contextOrganization) {
		const { data } = useListOrganizations();
		organizations = data;
	}
	const { data: sessionData } = useSession();
	const user = sessionData == null ? void 0 : sessionData.user;
	const showOrganizationSelect = contextOrganization == null ? void 0 : contextOrganization.apiKey;
	const form = useForm({
		resolver: zodResolver(z$1.object({
			name: z$1.string().min(1, `${localization.NAME} ${localization.IS_REQUIRED}`),
			expiresInDays: z$1.string().optional(),
			organizationId: showOrganizationSelect ? z$1.string().min(1, `${localization.ORGANIZATION} ${localization.IS_REQUIRED}`) : z$1.string().optional()
		})),
		values: {
			name: "",
			expiresInDays: "none",
			organizationId: organizationId ?? "personal"
		}
	});
	const { isSubmitting } = form.formState;
	const onSubmit = async (values) => {
		try {
			const expiresIn = values.expiresInDays && values.expiresInDays !== "none" ? Number.parseInt(values.expiresInDays) * 60 * 60 * 24 : void 0;
			const selectedOrgId = values.organizationId === "personal" ? void 0 : values.organizationId;
			const metadata = {
				...typeof apiKey === "object" ? apiKey.metadata : {},
				...contextOrganization && selectedOrgId ? { organizationId: selectedOrgId } : {}
			};
			const result = await authClient2.apiKey.create({
				name: values.name,
				expiresIn,
				prefix: typeof apiKey === "object" ? apiKey.prefix : void 0,
				metadata: Object.keys(metadata).length > 0 ? metadata : void 0,
				fetchOptions: { throw: true }
			});
			await (refetch == null ? void 0 : refetch());
			onSuccess(result.key);
			onOpenChange?.(false);
			form.reset();
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
	};
	const rtf = new Intl.RelativeTimeFormat(lang ?? "en");
	return /* @__PURE__ */ jsx(Dialog, {
		onOpenChange,
		...props,
		children: /* @__PURE__ */ jsxs(DialogContent, {
			onOpenAutoFocus: (e) => e.preventDefault(),
			className: (_a = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _a.content,
			children: [/* @__PURE__ */ jsxs(DialogHeader, {
				className: (_b = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _b.header,
				children: [/* @__PURE__ */ jsx(DialogTitle, {
					className: cn("text-lg md:text-xl", classNames == null ? void 0 : classNames.title),
					children: localization.CREATE_API_KEY
				}), /* @__PURE__ */ jsx(DialogDescription, {
					className: cn("text-xs md:text-sm", classNames == null ? void 0 : classNames.description),
					children: localization.CREATE_API_KEY_DESCRIPTION
				})]
			}), /* @__PURE__ */ jsx(Form, {
				...form,
				children: /* @__PURE__ */ jsxs("form", {
					onSubmit: form.handleSubmit(onSubmit),
					className: "space-y-6",
					children: [
						showOrganizationSelect && /* @__PURE__ */ jsx(FormField, {
							control: form.control,
							name: "organizationId",
							render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, {
								className: "w-full",
								children: [
									/* @__PURE__ */ jsx(FormLabel, {
										className: classNames == null ? void 0 : classNames.label,
										children: localization.ORGANIZATION
									}),
									/* @__PURE__ */ jsxs(Select, {
										onValueChange: field.onChange,
										value: field.value,
										disabled: isSubmitting,
										children: [/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(SelectTrigger, {
											className: cn("w-full p-2", classNames == null ? void 0 : classNames.input),
											children: /* @__PURE__ */ jsx(SelectValue, { placeholder: localization.ORGANIZATION })
										}) }), /* @__PURE__ */ jsxs(SelectContent, {
											className: "w-[--radix-select-trigger-width]",
											children: [/* @__PURE__ */ jsx(SelectItem, {
												value: "personal",
												className: "p-2",
												children: /* @__PURE__ */ jsx(PersonalAccountView, {
													user,
													localization,
													size: "sm"
												})
											}), organizations == null ? void 0 : organizations.map((org) => /* @__PURE__ */ jsx(SelectItem, {
												value: org.id,
												className: "p-2",
												children: /* @__PURE__ */ jsx(OrganizationCellView, {
													organization: org,
													localization,
													size: "sm"
												})
											}, org.id))]
										})]
									}),
									/* @__PURE__ */ jsx(FormMessage, {})
								]
							})
						}),
						/* @__PURE__ */ jsxs("div", {
							className: "flex gap-4",
							children: [/* @__PURE__ */ jsx(FormField, {
								control: form.control,
								name: "name",
								render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, {
									className: "flex-1",
									children: [
										/* @__PURE__ */ jsx(FormLabel, {
											className: classNames == null ? void 0 : classNames.label,
											children: localization.NAME
										}),
										/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(Input, {
											className: classNames == null ? void 0 : classNames.input,
											placeholder: localization.API_KEY_NAME_PLACEHOLDER,
											autoFocus: true,
											disabled: isSubmitting,
											...field
										}) }),
										/* @__PURE__ */ jsx(FormMessage, {})
									]
								})
							}), /* @__PURE__ */ jsx(FormField, {
								control: form.control,
								name: "expiresInDays",
								render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
									/* @__PURE__ */ jsx(FormLabel, {
										className: classNames == null ? void 0 : classNames.label,
										children: localization.EXPIRES
									}),
									/* @__PURE__ */ jsxs(Select, {
										onValueChange: field.onChange,
										defaultValue: field.value,
										disabled: isSubmitting,
										children: [/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(SelectTrigger, {
											className: classNames == null ? void 0 : classNames.input,
											children: /* @__PURE__ */ jsx(SelectValue, { placeholder: localization.NO_EXPIRATION })
										}) }), /* @__PURE__ */ jsxs(SelectContent, { children: [/* @__PURE__ */ jsx(SelectItem, {
											value: "none",
											children: localization.NO_EXPIRATION
										}), [
											1,
											7,
											30,
											60,
											90,
											180,
											365
										].map((days) => /* @__PURE__ */ jsx(SelectItem, {
											value: days.toString(),
											children: days === 365 ? rtf.format(1, "year") : rtf.format(days, "day")
										}, days))] })]
									}),
									/* @__PURE__ */ jsx(FormMessage, {})
								] })
							})]
						}),
						/* @__PURE__ */ jsxs(DialogFooter, {
							className: (_c = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _c.footer,
							children: [/* @__PURE__ */ jsx(Button, {
								type: "button",
								variant: "outline",
								onClick: () => onOpenChange == null ? void 0 : onOpenChange(false),
								className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.outlineButton),
								disabled: isSubmitting,
								children: localization.CANCEL
							}), /* @__PURE__ */ jsxs(Button, {
								type: "submit",
								variant: "default",
								className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.primaryButton),
								disabled: isSubmitting,
								children: [isSubmitting && /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }), localization.CREATE_API_KEY]
							})]
						})
					]
				})
			})]
		})
	});
}
function ApiKeysCard({ className, classNames, localization, organizationId, ...props }) {
	const { hooks: { useListApiKeys }, localization: contextLocalization } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const { data: apiKeys, isPending, refetch } = useListApiKeys();
	const filteredApiKeys = useMemo(() => {
		return apiKeys == null ? void 0 : apiKeys.filter((apiKey) => {
			var _a;
			return organizationId === ((_a = apiKey.metadata) == null ? void 0 : _a.organizationId);
		});
	}, [apiKeys, organizationId]);
	const [createDialogOpen, setCreateDialogOpen] = useState(false);
	const [displayDialogOpen, setDisplayDialogOpen] = useState(false);
	const [createdApiKey, setCreatedApiKey] = useState("");
	const handleCreateApiKey = (apiKey) => {
		setCreatedApiKey(apiKey);
		setDisplayDialogOpen(true);
	};
	return /* @__PURE__ */ jsxs(Fragment$1, { children: [
		/* @__PURE__ */ jsx(SettingsCard, {
			className,
			classNames,
			actionLabel: localization.CREATE_API_KEY,
			description: localization.API_KEYS_DESCRIPTION,
			instructions: localization.API_KEYS_INSTRUCTIONS,
			isPending,
			title: localization.API_KEYS,
			action: () => setCreateDialogOpen(true),
			...props,
			children: filteredApiKeys && filteredApiKeys.length > 0 && /* @__PURE__ */ jsx(CardContent, {
				className: cn("grid gap-4", classNames == null ? void 0 : classNames.content),
				children: filteredApiKeys == null ? void 0 : filteredApiKeys.map((apiKey) => /* @__PURE__ */ jsx(ApiKeyCell, {
					classNames,
					apiKey,
					localization,
					refetch
				}, apiKey.id))
			})
		}),
		/* @__PURE__ */ jsx(CreateApiKeyDialog, {
			classNames,
			localization,
			open: createDialogOpen,
			onOpenChange: setCreateDialogOpen,
			onSuccess: handleCreateApiKey,
			refetch,
			organizationId
		}),
		/* @__PURE__ */ jsx(ApiKeyDisplayDialog, {
			classNames,
			apiKey: createdApiKey,
			localization,
			open: displayDialogOpen,
			onOpenChange: setDisplayDialogOpen
		})
	] });
}
function DeleteAccountDialog({ classNames, accounts, localization, onOpenChange, ...props }) {
	var _a, _b, _c;
	const { authClient: authClient2, basePath, baseURL, deleteUser, freshAge, hooks: { useSession }, localization: contextLocalization, viewPaths, navigate, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const { data: sessionData } = useSession();
	const session = sessionData == null ? void 0 : sessionData.session;
	const user = sessionData == null ? void 0 : sessionData.user;
	const isFresh = session ? Date.now() - new Date(session == null ? void 0 : session.createdAt).getTime() < freshAge * 1e3 : false;
	const credentialsLinked = accounts == null ? void 0 : accounts.some((acc) => acc.providerId === "credential");
	const form = useForm({
		resolver: zodResolver(z$1.object({ password: credentialsLinked ? z$1.string().min(1, { message: localization.PASSWORD_REQUIRED }) : z$1.string().optional() })),
		defaultValues: { password: "" }
	});
	const { isSubmitting } = form.formState;
	const deleteAccount = async ({ password }) => {
		const params = {};
		if (credentialsLinked) params.password = password;
		else if (!isFresh) {
			navigate(`${basePath}/${viewPaths.SIGN_OUT}`);
			return;
		}
		if (deleteUser == null ? void 0 : deleteUser.verification) params.callbackURL = `${baseURL}${basePath}/${viewPaths.SIGN_OUT}`;
		try {
			await authClient2.deleteUser({
				...params,
				fetchOptions: { throw: true }
			});
			if (deleteUser == null ? void 0 : deleteUser.verification) toast$1({
				variant: "success",
				message: localization.DELETE_ACCOUNT_VERIFY
			});
			else {
				toast$1({
					variant: "success",
					message: localization.DELETE_ACCOUNT_SUCCESS
				});
				navigate(`${basePath}/${viewPaths.SIGN_OUT}`);
			}
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
		onOpenChange?.(false);
	};
	return /* @__PURE__ */ jsx(Dialog, {
		onOpenChange,
		...props,
		children: /* @__PURE__ */ jsxs(DialogContent, {
			className: cn("sm:max-w-md", (_a = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _a.content),
			children: [
				/* @__PURE__ */ jsxs(DialogHeader, {
					className: (_b = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _b.header,
					children: [/* @__PURE__ */ jsx(DialogTitle, {
						className: cn("text-lg md:text-xl", classNames == null ? void 0 : classNames.title),
						children: localization == null ? void 0 : localization.DELETE_ACCOUNT
					}), /* @__PURE__ */ jsx(DialogDescription, {
						className: cn("text-xs md:text-sm", classNames == null ? void 0 : classNames.description),
						children: isFresh ? localization == null ? void 0 : localization.DELETE_ACCOUNT_INSTRUCTIONS : localization == null ? void 0 : localization.SESSION_NOT_FRESH
					})]
				}),
				/* @__PURE__ */ jsx(Card, {
					className: cn("my-2 flex-row p-4", classNames == null ? void 0 : classNames.cell),
					children: /* @__PURE__ */ jsx(UserView, {
						user,
						localization
					})
				}),
				/* @__PURE__ */ jsx(Form, {
					...form,
					children: /* @__PURE__ */ jsxs("form", {
						onSubmit: form.handleSubmit(deleteAccount),
						className: "grid gap-6",
						children: [credentialsLinked && /* @__PURE__ */ jsx(FormField, {
							control: form.control,
							name: "password",
							render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
								/* @__PURE__ */ jsx(FormLabel, {
									className: classNames == null ? void 0 : classNames.label,
									children: localization == null ? void 0 : localization.PASSWORD
								}),
								/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(Input, {
									autoComplete: "current-password",
									placeholder: localization == null ? void 0 : localization.PASSWORD_PLACEHOLDER,
									type: "password",
									className: classNames == null ? void 0 : classNames.input,
									...field
								}) }),
								/* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })
							] })
						}), /* @__PURE__ */ jsxs(DialogFooter, {
							className: (_c = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _c.footer,
							children: [/* @__PURE__ */ jsx(Button, {
								type: "button",
								variant: "secondary",
								className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.secondaryButton),
								onClick: () => onOpenChange == null ? void 0 : onOpenChange(false),
								children: localization.CANCEL
							}), /* @__PURE__ */ jsxs(Button, {
								className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.destructiveButton),
								disabled: isSubmitting,
								variant: "destructive",
								type: "submit",
								children: [isSubmitting && /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }), isFresh ? localization == null ? void 0 : localization.DELETE_ACCOUNT : localization == null ? void 0 : localization.SIGN_OUT]
							})]
						})]
					})
				})
			]
		})
	});
}
function DeleteAccountCard({ className, classNames, accounts, isPending, localization, skipHook }) {
	const { hooks: { useListAccounts }, localization: contextLocalization } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const [showDialog, setShowDialog] = useState(false);
	if (!skipHook) {
		const result = useListAccounts();
		accounts = result.data;
		isPending = result.isPending;
	}
	return /* @__PURE__ */ jsxs("div", { children: [/* @__PURE__ */ jsx(SettingsCard, {
		className,
		classNames,
		actionLabel: localization == null ? void 0 : localization.DELETE_ACCOUNT,
		description: localization == null ? void 0 : localization.DELETE_ACCOUNT_DESCRIPTION,
		isPending,
		title: localization == null ? void 0 : localization.DELETE_ACCOUNT,
		variant: "destructive",
		action: () => setShowDialog(true)
	}), /* @__PURE__ */ jsx(DeleteAccountDialog, {
		classNames,
		accounts,
		localization,
		open: showDialog,
		onOpenChange: setShowDialog
	})] });
}
function SessionFreshnessDialog({ classNames, localization, title, description, onOpenChange, ...props }) {
	var _a, _b, _c;
	const { basePath, localization: contextLocalization, viewPaths, navigate } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const handleSignOut = () => {
		navigate(`${basePath}/${viewPaths.SIGN_OUT}`);
		onOpenChange?.(false);
	};
	return /* @__PURE__ */ jsx(Dialog, {
		onOpenChange,
		...props,
		children: /* @__PURE__ */ jsxs(DialogContent, {
			className: cn("sm:max-w-md", (_a = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _a.content),
			children: [/* @__PURE__ */ jsxs(DialogHeader, {
				className: (_b = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _b.header,
				children: [/* @__PURE__ */ jsx(DialogTitle, {
					className: cn("text-lg md:text-xl", classNames == null ? void 0 : classNames.title),
					children: title || (localization == null ? void 0 : localization.SESSION_EXPIRED) || "Session Expired"
				}), /* @__PURE__ */ jsx(DialogDescription, {
					className: cn("text-xs md:text-sm", classNames == null ? void 0 : classNames.description),
					children: description || (localization == null ? void 0 : localization.SESSION_NOT_FRESH)
				})]
			}), /* @__PURE__ */ jsxs(DialogFooter, {
				className: (_c = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _c.footer,
				children: [/* @__PURE__ */ jsx(Button, {
					type: "button",
					variant: "secondary",
					className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.secondaryButton),
					onClick: () => onOpenChange == null ? void 0 : onOpenChange(false),
					children: localization.CANCEL
				}), /* @__PURE__ */ jsx(Button, {
					className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.primaryButton),
					variant: "default",
					onClick: handleSignOut,
					children: localization == null ? void 0 : localization.SIGN_OUT
				})]
			})]
		})
	});
}
function PasskeyCell({ className, classNames, localization, passkey }) {
	const { freshAge, hooks: { useSession, useListPasskeys }, localization: contextLocalization, mutators: { deletePasskey }, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const { refetch } = useListPasskeys();
	const { data: sessionData } = useSession();
	const session = sessionData == null ? void 0 : sessionData.session;
	const isFresh = session ? Date.now() - new Date(session == null ? void 0 : session.createdAt).getTime() < freshAge * 1e3 : false;
	const [showFreshnessDialog, setShowFreshnessDialog] = useState(false);
	const [isLoading, setIsLoading] = useState(false);
	const handleDeletePasskey = async () => {
		if (!isFresh) {
			setShowFreshnessDialog(true);
			return;
		}
		setIsLoading(true);
		try {
			await deletePasskey({ id: passkey.id });
			refetch?.();
		} catch (error) {
			setIsLoading(false);
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
	};
	return /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(SessionFreshnessDialog, {
		open: showFreshnessDialog,
		onOpenChange: setShowFreshnessDialog,
		classNames,
		localization
	}), /* @__PURE__ */ jsxs(Card, {
		className: cn("flex-row items-center p-4", className, classNames == null ? void 0 : classNames.cell),
		children: [/* @__PURE__ */ jsxs("div", {
			className: "flex items-center gap-3",
			children: [/* @__PURE__ */ jsx(FingerprintIcon, { className: cn("size-4", classNames == null ? void 0 : classNames.icon) }), /* @__PURE__ */ jsx("span", {
				className: "text-sm",
				children: new Date(passkey.createdAt).toLocaleString()
			})]
		}), /* @__PURE__ */ jsxs(Button, {
			className: cn("relative ms-auto", classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.outlineButton),
			disabled: isLoading,
			size: "sm",
			variant: "outline",
			onClick: handleDeletePasskey,
			children: [isLoading && /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }), localization.DELETE]
		})]
	})] });
}
function PasskeysCard({ className, classNames, localization }) {
	const { authClient: authClient2, freshAge, hooks: { useListPasskeys, useSession }, localization: authLocalization2, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	localization = {
		...authLocalization2,
		...localization
	};
	const { data: passkeys, isPending, refetch } = useListPasskeys();
	const { data: sessionData } = useSession();
	const session = sessionData == null ? void 0 : sessionData.session;
	const isFresh = session ? Date.now() - new Date(session == null ? void 0 : session.createdAt).getTime() < freshAge * 1e3 : false;
	const [showFreshnessDialog, setShowFreshnessDialog] = useState(false);
	const addPasskey = async () => {
		if (!isFresh) {
			setShowFreshnessDialog(true);
			return;
		}
		try {
			await authClient2.passkey.addPasskey({ fetchOptions: { throw: true } });
			await (refetch == null ? void 0 : refetch());
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
	};
	const form = useForm();
	return /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(SessionFreshnessDialog, {
		open: showFreshnessDialog,
		onOpenChange: setShowFreshnessDialog,
		classNames,
		localization
	}), /* @__PURE__ */ jsx(Form, {
		...form,
		children: /* @__PURE__ */ jsx("form", {
			onSubmit: form.handleSubmit(addPasskey),
			children: /* @__PURE__ */ jsx(SettingsCard, {
				className,
				classNames,
				actionLabel: localization.ADD_PASSKEY,
				description: localization.PASSKEYS_DESCRIPTION,
				instructions: localization.PASSKEYS_INSTRUCTIONS,
				isPending,
				title: localization.PASSKEYS,
				children: passkeys && passkeys.length > 0 && /* @__PURE__ */ jsx(CardContent, {
					className: cn("grid gap-4", classNames == null ? void 0 : classNames.content),
					children: passkeys == null ? void 0 : passkeys.map((passkey) => /* @__PURE__ */ jsx(PasskeyCell, {
						classNames,
						localization,
						passkey
					}, passkey.id))
				})
			})
		})
	})] });
}
var AppleIcon = ({ className }) => /* @__PURE__ */ jsx("svg", {
	className,
	viewBox: "0 0 32 32",
	xmlns: "http://www.w3.org/2000/svg",
	children: /* @__PURE__ */ jsx("path", {
		d: "M9.438 31.401a7 7 0 0 1-1.656-1.536a20 20 0 0 1-1.422-1.938a18.9 18.9 0 0 1-2.375-4.849c-.667-2-.99-3.917-.99-5.792c0-2.094.453-3.922 1.339-5.458a7.7 7.7 0 0 1 2.797-2.906a7.45 7.45 0 0 1 3.786-1.12q.705.002 1.51.198c.385.109.854.281 1.427.495c.729.281 1.13.453 1.266.495c.427.156.786.224 1.068.224c.214 0 .516-.068.859-.172c.193-.068.557-.188 1.078-.411c.516-.188.922-.349 1.245-.469c.495-.146.974-.281 1.401-.349a6.7 6.7 0 0 1 1.531-.063a9 9 0 0 1 2.589.557c1.359.547 2.458 1.401 3.276 2.615a6.4 6.4 0 0 0-.969.734a8.2 8.2 0 0 0-1.641 2.005a6.8 6.8 0 0 0-.859 3.359c.021 1.443.391 2.714 1.12 3.813a7.2 7.2 0 0 0 2.047 2.047c.417.281.776.474 1.12.604c-.161.5-.333.984-.536 1.464a19 19 0 0 1-1.667 3.083c-.578.839-1.031 1.464-1.375 1.88c-.536.635-1.052 1.12-1.573 1.458c-.573.38-1.25.583-1.938.583a4.4 4.4 0 0 1-1.38-.167c-.385-.13-.766-.271-1.141-.432a9 9 0 0 0-1.203-.453a6.3 6.3 0 0 0-3.099-.005c-.417.12-.818.26-1.214.432c-.557.234-.927.391-1.141.458c-.427.125-.87.203-1.318.229c-.693 0-1.339-.198-1.979-.599zm9.14-24.615c-.906.453-1.771.646-2.63.583c-.135-.865 0-1.75.359-2.719a7.3 7.3 0 0 1 1.333-2.24A7.1 7.1 0 0 1 19.812.733q1.319-.68 2.521-.734c.104.906 0 1.797-.333 2.76a8 8 0 0 1-1.333 2.344a6.8 6.8 0 0 1-2.115 1.682z",
		fill: "currentColor"
	})
});
var DiscordIcon = ({ className }) => /* @__PURE__ */ jsx("svg", {
	className,
	viewBox: "0 0 256 199",
	xmlns: "http://www.w3.org/2000/svg",
	children: /* @__PURE__ */ jsx("path", {
		d: "M216.856 16.597A208.5 208.5 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046q-29.538-4.442-58.533 0c-1.832-4.4-4.55-9.933-6.846-14.046a207.8 207.8 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161 161 0 0 0 79.735 175.3a136.4 136.4 0 0 1-21.846-10.632a109 109 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a132 132 0 0 0 5.355 4.237a136 136 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848c21.142-6.58 42.646-16.637 64.815-33.213c5.316-56.288-9.08-105.09-38.056-148.36M85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2s23.236 11.804 23.015 26.2c.02 14.375-10.148 26.18-23.015 26.18m85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2c0 14.375-10.148 26.18-23.015 26.18",
		fill: "#5865f2"
	})
});
var DropboxIcon = ({ className }) => /* @__PURE__ */ jsx("svg", {
	className,
	viewBox: "0 0 256 218",
	xmlns: "http://www.w3.org/2000/svg",
	children: /* @__PURE__ */ jsx("path", {
		d: "M63.995 0L0 40.771l63.995 40.772L128 40.771zM192 0l-64 40.775l64 40.775l64.001-40.775zM0 122.321l63.995 40.772L128 122.321L63.995 81.55zM192 81.55l-64 40.775l64 40.774l64-40.774zM64 176.771l64.005 40.772L192 176.771L128.005 136z",
		fill: "#0061ff"
	})
});
var FacebookIcon = ({ className }) => /* @__PURE__ */ jsxs("svg", {
	className,
	viewBox: "0 0 256 256",
	xmlns: "http://www.w3.org/2000/svg",
	children: [/* @__PURE__ */ jsx("path", {
		d: "M256 128C256 57.308 198.692 0 128 0S0 57.308 0 128c0 63.888 46.808 116.843 108 126.445V165H75.5v-37H108V99.8c0-32.08 19.11-49.8 48.348-49.8C170.352 50 185 52.5 185 52.5V84h-16.14C152.959 84 148 93.867 148 103.99V128h35.5l-5.675 37H148v89.445c61.192-9.602 108-62.556 108-126.445",
		fill: "#1877f2"
	}), /* @__PURE__ */ jsx("path", {
		d: "m177.825 165l5.675-37H148v-24.01C148 93.866 152.959 84 168.86 84H185V52.5S170.352 50 156.347 50C127.11 50 108 67.72 108 99.8V128H75.5v37H108v89.445A129 129 0 0 0 128 256a129 129 0 0 0 20-1.555V165z",
		fill: "#fff"
	})]
});
var GitHubIcon = ({ className }) => /* @__PURE__ */ jsx("svg", {
	className,
	viewBox: "0 0 24 24",
	xmlns: "http://www.w3.org/2000/svg",
	children: /* @__PURE__ */ jsx("path", {
		d: "M12 .297c-6.63 0-12 5.373-12 12c0 5.303 3.438 9.8 8.205 11.385c.6.113.82-.258.82-.577c0-.285-.01-1.04-.015-2.04c-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729c1.205.084 1.838 1.236 1.838 1.236c1.07 1.835 2.809 1.305 3.495.998c.108-.776.417-1.305.76-1.605c-2.665-.3-5.466-1.332-5.466-5.93c0-1.31.465-2.38 1.235-3.22c-.135-.303-.54-1.523.105-3.176c0 0 1.005-.322 3.3 1.23c.96-.267 1.98-.399 3-.405c1.02.006 2.04.138 3 .405c2.28-1.552 3.285-1.23 3.285-1.23c.645 1.653.24 2.873.12 3.176c.765.84 1.23 1.91 1.23 3.22c0 4.61-2.805 5.625-5.475 5.92c.42.36.81 1.096.81 2.22c0 1.606-.015 2.896-.015 3.286c0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12",
		fill: "currentColor"
	})
});
var GitLabIcon = ({ className }) => /* @__PURE__ */ jsxs("svg", {
	className,
	viewBox: "0 0 256 236",
	xmlns: "http://www.w3.org/2000/svg",
	children: [
		/* @__PURE__ */ jsx("path", {
			d: "m128.075 236.075l47.104-144.97H80.97z",
			fill: "#e24329"
		}),
		/* @__PURE__ */ jsx("path", {
			d: "M128.075 236.074L80.97 91.104H14.956z",
			fill: "#fc6d26"
		}),
		/* @__PURE__ */ jsx("path", {
			d: "M14.956 91.104L.642 135.16a9.75 9.75 0 0 0 3.542 10.903l123.891 90.012z",
			fill: "#fca326"
		}),
		/* @__PURE__ */ jsx("path", {
			d: "M14.956 91.105H80.97L52.601 3.79c-1.46-4.493-7.816-4.492-9.275 0z",
			fill: "#e24329"
		}),
		/* @__PURE__ */ jsx("path", {
			d: "m128.075 236.074l47.104-144.97h66.015z",
			fill: "#fc6d26"
		}),
		/* @__PURE__ */ jsx("path", {
			d: "m241.194 91.104l14.314 44.056a9.75 9.75 0 0 1-3.543 10.903l-123.89 90.012z",
			fill: "#fca326"
		}),
		/* @__PURE__ */ jsx("path", {
			d: "M241.194 91.105h-66.015l28.37-87.315c1.46-4.493 7.816-4.492 9.275 0z",
			fill: "#e24329"
		})
	]
});
var GoogleIcon = ({ className }) => /* @__PURE__ */ jsxs("svg", {
	className,
	viewBox: "0 0 256 262",
	xmlns: "http://www.w3.org/2000/svg",
	children: [
		/* @__PURE__ */ jsx("path", {
			d: "M255.878 133.451c0-10.734-.871-18.567-2.756-26.69H130.55v48.448h71.947c-1.45 12.04-9.283 30.172-26.69 42.356l-.244 1.622l38.755 30.023l2.685.268c24.659-22.774 38.875-56.282 38.875-96.027",
			fill: "#4285f4"
		}),
		/* @__PURE__ */ jsx("path", {
			d: "M130.55 261.1c35.248 0 64.839-11.605 86.453-31.622l-41.196-31.913c-11.024 7.688-25.82 13.055-45.257 13.055c-34.523 0-63.824-22.773-74.269-54.25l-1.531.13l-40.298 31.187l-.527 1.465C35.393 231.798 79.49 261.1 130.55 261.1",
			fill: "#34a853"
		}),
		/* @__PURE__ */ jsx("path", {
			d: "M56.281 156.37c-2.756-8.123-4.351-16.827-4.351-25.82c0-8.994 1.595-17.697 4.206-25.82l-.073-1.73L15.26 71.312l-1.335.635C5.077 89.644 0 109.517 0 130.55s5.077 40.905 13.925 58.602z",
			fill: "#fbbc05"
		}),
		/* @__PURE__ */ jsx("path", {
			d: "M130.55 50.479c24.514 0 41.05 10.589 50.479 19.438l36.844-35.974C195.245 12.91 165.798 0 130.55 0C79.49 0 35.393 29.301 13.925 71.947l42.211 32.783c10.59-31.477 39.891-54.251 74.414-54.251",
			fill: "#eb4335"
		})
	]
});
var HuggingFaceIcon = ({ className }) => /* @__PURE__ */ jsx("svg", {
	className,
	xmlns: "http://www.w3.org/2000/svg",
	viewBox: "0 0 24 24",
	children: /* @__PURE__ */ jsx("path", {
		fill: "currentColor",
		d: "M12.025 1.13c-5.77 0-10.449 4.647-10.449 10.378c0 1.112.178 2.181.503 3.185c.064-.222.203-.444.416-.577a.96.96 0 0 1 .524-.15c.293 0 .584.124.84.284c.278.173.48.408.71.694c.226.282.458.611.684.951v-.014c.017-.324.106-.622.264-.874s.403-.487.762-.543c.3-.047.596.06.787.203s.31.313.4.467c.15.257.212.468.233.542c.01.026.653 1.552 1.657 2.54c.616.605 1.01 1.223 1.082 1.912c.055.537-.096 1.059-.38 1.572c.637.121 1.294.187 1.967.187c.657 0 1.298-.063 1.921-.178c-.287-.517-.44-1.041-.384-1.581c.07-.69.465-1.307 1.081-1.913c1.004-.987 1.647-2.513 1.657-2.539c.021-.074.083-.285.233-.542c.09-.154.208-.323.4-.467a1.08 1.08 0 0 1 .787-.203c.359.056.604.29.762.543s.247.55.265.874v.015c.225-.34.457-.67.683-.952c.23-.286.432-.52.71-.694c.257-.16.547-.284.84-.285a.97.97 0 0 1 .524.151c.228.143.373.388.43.625l.006.04a10.3 10.3 0 0 0 .534-3.273c0-5.731-4.678-10.378-10.449-10.378M8.327 6.583a1.5 1.5 0 0 1 .713.174a1.487 1.487 0 0 1 .617 2.013c-.183.343-.762-.214-1.102-.094c-.38.134-.532.914-.917.71a1.487 1.487 0 0 1 .69-2.803m7.486 0a1.487 1.487 0 0 1 .689 2.803c-.385.204-.536-.576-.916-.71c-.34-.12-.92.437-1.103.094a1.487 1.487 0 0 1 .617-2.013a1.5 1.5 0 0 1 .713-.174m-10.68 1.55a.96.96 0 1 1 0 1.921a.96.96 0 0 1 0-1.92m13.838 0a.96.96 0 1 1 0 1.92a.96.96 0 0 1 0-1.92M8.489 11.458c.588.01 1.965 1.157 3.572 1.164c1.607-.007 2.984-1.155 3.572-1.164c.196-.003.305.12.305.454c0 .886-.424 2.328-1.563 3.202c-.22-.756-1.396-1.366-1.63-1.32q-.011.001-.02.006l-.044.026l-.01.008l-.03.024q-.018.017-.035.036l-.032.04a1 1 0 0 0-.058.09l-.014.025q-.049.088-.11.19a1 1 0 0 1-.083.116a1.2 1.2 0 0 1-.173.18q-.035.029-.075.058a1.3 1.3 0 0 1-.251-.243a1 1 0 0 1-.076-.107c-.124-.193-.177-.363-.337-.444c-.034-.016-.104-.008-.2.022q-.094.03-.216.087q-.06.028-.125.063l-.13.074q-.067.04-.136.086a3 3 0 0 0-.135.096a3 3 0 0 0-.26.219a2 2 0 0 0-.12.121a2 2 0 0 0-.106.128l-.002.002a2 2 0 0 0-.09.132l-.001.001a1.2 1.2 0 0 0-.105.212q-.013.036-.024.073c-1.139-.875-1.563-2.317-1.563-3.203c0-.334.109-.457.305-.454m.836 10.354c.824-1.19.766-2.082-.365-3.194c-1.13-1.112-1.789-2.738-1.789-2.738s-.246-.945-.806-.858s-.97 1.499.202 2.362c1.173.864-.233 1.45-.685.64c-.45-.812-1.683-2.896-2.322-3.295s-1.089-.175-.938.647s2.822 2.813 2.562 3.244s-1.176-.506-1.176-.506s-2.866-2.567-3.49-1.898s.473 1.23 2.037 2.16c1.564.932 1.686 1.178 1.464 1.53s-3.675-2.511-4-1.297c-.323 1.214 3.524 1.567 3.287 2.405c-.238.839-2.71-1.587-3.216-.642c-.506.946 3.49 2.056 3.522 2.064c1.29.33 4.568 1.028 5.713-.624m5.349 0c-.824-1.19-.766-2.082.365-3.194c1.13-1.112 1.789-2.738 1.789-2.738s.246-.945.806-.858s.97 1.499-.202 2.362c-1.173.864.233 1.45.685.64c.451-.812 1.683-2.896 2.322-3.295s1.089-.175.938.647s-2.822 2.813-2.562 3.244s1.176-.506 1.176-.506s2.866-2.567 3.49-1.898s-.473 1.23-2.037 2.16c-1.564.932-1.686 1.178-1.464 1.53s3.675-2.511 4-1.297c.323 1.214-3.524 1.567-3.287 2.405c.238.839 2.71-1.587 3.216-.642c.506.946-3.49 2.056-3.522 2.064c-1.29.33-4.568 1.028-5.713-.624"
	})
});
var KickIcon = ({ className }) => /* @__PURE__ */ jsx("svg", {
	className,
	xmlns: "http://www.w3.org/2000/svg",
	width: 24,
	height: 24,
	viewBox: "0 0 24 24",
	children: /* @__PURE__ */ jsx("path", {
		fill: "currentColor",
		d: "M1.333 0h8v5.333H12V2.667h2.667V0h8v8H20v2.667h-2.667v2.666H20V16h2.667v8h-8v-2.667H12v-2.666H9.333V24h-8Z"
	})
});
var LinearIcon = ({ className }) => /* @__PURE__ */ jsx("svg", {
	className,
	xmlns: "http://www.w3.org/2000/svg",
	viewBox: "0 0 24 24",
	children: /* @__PURE__ */ jsx("path", {
		fill: "currentColor",
		d: "M2.886 4.18A11.98 11.98 0 0 1 11.99 0C18.624 0 24 5.376 24 12.009c0 3.64-1.62 6.903-4.18 9.105L2.887 4.18ZM1.817 5.626l16.556 16.556q-.787.496-1.65.866L.951 7.277q.371-.863.866-1.65ZM.322 9.163l14.515 14.515q-1.066.26-2.195.322L0 11.358a12 12 0 0 1 .322-2.195m-.17 4.862l9.823 9.824a12.02 12.02 0 0 1-9.824-9.824Z"
	})
});
var LinkedInIcon = ({ className }) => /* @__PURE__ */ jsxs("svg", {
	className,
	viewBox: "0 0 128 128",
	xmlns: "http://www.w3.org/2000/svg",
	children: [/* @__PURE__ */ jsx("path", {
		d: "M116 3H12a8.91 8.91 0 0 0-9 8.8v104.42a8.91 8.91 0 0 0 9 8.78h104a8.93 8.93 0 0 0 9-8.81V11.77A8.93 8.93 0 0 0 116 3",
		fill: "#0076b2"
	}), /* @__PURE__ */ jsx("path", {
		d: "M21.06 48.73h18.11V107H21.06zm9.06-29a10.5 10.5 0 1 1-10.5 10.49a10.5 10.5 0 0 1 10.5-10.49m20.41 29h17.36v8h.24c2.42-4.58 8.32-9.41 17.13-9.41C103.6 47.28 107 59.35 107 75v32H88.89V78.65c0-6.75-.12-15.44-9.41-15.44s-10.87 7.36-10.87 15V107H50.53z",
		fill: "#fff"
	})]
});
var MicrosoftIcon = ({ className }) => /* @__PURE__ */ jsxs("svg", {
	className,
	viewBox: "0 0 256 256",
	xmlns: "http://www.w3.org/2000/svg",
	children: [
		/* @__PURE__ */ jsx("path", {
			d: "M121.666 121.666H0V0h121.666z",
			fill: "#f1511b"
		}),
		/* @__PURE__ */ jsx("path", {
			d: "M256 121.666H134.335V0H256z",
			fill: "#80cc28"
		}),
		/* @__PURE__ */ jsx("path", {
			d: "M121.663 256.002H0V134.336h121.663z",
			fill: "#00adef"
		}),
		/* @__PURE__ */ jsx("path", {
			d: "M256 256.002H134.335V134.336H256z",
			fill: "#fbbc09"
		})
	]
});
var NotionIcon = ({ className }) => /* @__PURE__ */ jsx("svg", {
	className,
	xmlns: "http://www.w3.org/2000/svg",
	viewBox: "0 0 24 24",
	children: /* @__PURE__ */ jsx("path", {
		fill: "currentColor",
		d: "M4.459 4.208c.746.606 1.026.56 2.428.466l13.215-.793c.28 0 .047-.28-.046-.326L17.86 1.968c-.42-.326-.981-.7-2.055-.607L3.01 2.295c-.466.046-.56.28-.374.466zm.793 3.08v13.904c0 .747.373 1.027 1.214.98l14.523-.84c.841-.046.935-.56.935-1.167V6.354c0-.606-.233-.933-.748-.887l-15.177.887c-.56.047-.747.327-.747.933zm14.337.745c.093.42 0 .84-.42.888l-.7.14v10.264c-.608.327-1.168.514-1.635.514c-.748 0-.935-.234-1.495-.933l-4.577-7.186v6.952L12.21 19s0 .84-1.168.84l-3.222.186c-.093-.186 0-.653.327-.746l.84-.233V9.854L7.822 9.76c-.094-.42.14-1.026.793-1.073l3.456-.233l4.764 7.279v-6.44l-1.215-.139c-.093-.514.28-.887.747-.933zM1.936 1.035l13.31-.98c1.634-.14 2.055-.047 3.082.7l4.249 2.986c.7.513.934.653.934 1.213v16.378c0 1.026-.373 1.634-1.68 1.726l-15.458.934c-.98.047-1.448-.093-1.962-.747l-3.129-4.06c-.56-.747-.793-1.306-.793-1.96V2.667c0-.839.374-1.54 1.447-1.632"
	})
});
var RedditIcon = ({ className }) => /* @__PURE__ */ jsxs("svg", {
	className,
	viewBox: "0 0 256 256",
	xmlns: "http://www.w3.org/2000/svg",
	children: [/* @__PURE__ */ jsx("circle", {
		cx: "128",
		cy: "128",
		fill: "#ff4500",
		r: "128"
	}), /* @__PURE__ */ jsx("path", {
		d: "M213.15 129.22c0-10.376-8.391-18.617-18.617-18.617a18.74 18.74 0 0 0-12.97 5.189c-12.818-9.157-30.368-15.107-49.9-15.87l8.544-39.981l27.773 5.95c.307 7.02 6.104 12.667 13.278 12.667c7.324 0 13.275-5.95 13.275-13.278c0-7.324-5.95-13.275-13.275-13.275c-5.188 0-9.768 3.052-11.904 7.478l-30.976-6.562c-.916-.154-1.832 0-2.443.458c-.763.458-1.22 1.22-1.371 2.136l-9.464 44.558c-19.837.612-37.692 6.562-50.662 15.872a18.74 18.74 0 0 0-12.971-5.188c-10.377 0-18.617 8.391-18.617 18.617c0 7.629 4.577 14.037 10.988 16.939a33.6 33.6 0 0 0-.458 5.646c0 28.686 33.42 52.036 74.621 52.036c41.202 0 74.622-23.196 74.622-52.036a35 35 0 0 0-.458-5.646c6.408-2.902 10.985-9.464 10.985-17.093M85.272 142.495c0-7.324 5.95-13.275 13.278-13.275c7.324 0 13.275 5.95 13.275 13.275s-5.95 13.278-13.275 13.278c-7.327.15-13.278-5.953-13.278-13.278m74.317 35.251c-9.156 9.157-26.553 9.768-31.588 9.768c-5.188 0-22.584-.765-31.59-9.768c-1.371-1.373-1.371-3.51 0-4.883c1.374-1.371 3.51-1.371 4.884 0c5.8 5.8 18.008 7.782 26.706 7.782s21.058-1.983 26.704-7.782c1.374-1.371 3.51-1.371 4.884 0c1.22 1.373 1.22 3.51 0 4.883m-2.443-21.822c-7.325 0-13.275-5.95-13.275-13.275s5.95-13.275 13.275-13.275c7.327 0 13.277 5.95 13.277 13.275c0 7.17-5.95 13.275-13.277 13.275",
		fill: "#fff"
	})]
});
var RobloxIcon = ({ className }) => /* @__PURE__ */ jsx("svg", {
	className,
	viewBox: "0 0 24 24",
	xmlns: "http://www.w3.org/2000/svg",
	children: /* @__PURE__ */ jsx("path", {
		d: "M18.926 23.998L0 18.892L5.075.002L24 5.108ZM15.348 10.09l-5.282-1.453l-1.414 5.273l5.282 1.453z",
		fill: "currentColor"
	})
});
var SlackIcon = ({ className }) => /* @__PURE__ */ jsx("svg", {
	className,
	xmlns: "http://www.w3.org/2000/svg",
	viewBox: "0 0 24 24",
	children: /* @__PURE__ */ jsx("path", {
		fill: "currentColor",
		d: "M6 15a2 2 0 0 1-2 2a2 2 0 0 1-2-2a2 2 0 0 1 2-2h2zm1 0a2 2 0 0 1 2-2a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2a2 2 0 0 1-2-2zm2-8a2 2 0 0 1-2-2a2 2 0 0 1 2-2a2 2 0 0 1 2 2v2zm0 1a2 2 0 0 1 2 2a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2a2 2 0 0 1 2-2zm8 2a2 2 0 0 1 2-2a2 2 0 0 1 2 2a2 2 0 0 1-2 2h-2zm-1 0a2 2 0 0 1-2 2a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2a2 2 0 0 1 2 2zm-2 8a2 2 0 0 1 2 2a2 2 0 0 1-2 2a2 2 0 0 1-2-2v-2zm0-1a2 2 0 0 1-2-2a2 2 0 0 1 2-2h5a2 2 0 0 1 2 2a2 2 0 0 1-2 2z"
	})
});
var SpotifyIcon = ({ className }) => /* @__PURE__ */ jsx("svg", {
	className,
	viewBox: "0 0 256 256",
	xmlns: "http://www.w3.org/2000/svg",
	children: /* @__PURE__ */ jsx("path", {
		d: "M128 0C57.308 0 0 57.309 0 128c0 70.696 57.309 128 128 128c70.697 0 128-57.304 128-128C256 57.314 198.697.007 127.998.007zm58.699 184.614c-2.293 3.76-7.215 4.952-10.975 2.644c-30.053-18.357-67.885-22.515-112.44-12.335a7.98 7.98 0 0 1-9.552-6.007a7.97 7.97 0 0 1 6-9.553c48.76-11.14 90.583-6.344 124.323 14.276c3.76 2.308 4.952 7.215 2.644 10.975m15.667-34.853c-2.89 4.695-9.034 6.178-13.726 3.289c-34.406-21.148-86.853-27.273-127.548-14.92c-5.278 1.594-10.852-1.38-12.454-6.649c-1.59-5.278 1.386-10.842 6.655-12.446c46.485-14.106 104.275-7.273 143.787 17.007c4.692 2.89 6.175 9.034 3.286 13.72zm1.345-36.293C162.457 88.964 94.394 86.71 55.007 98.666c-6.325 1.918-13.014-1.653-14.93-7.978c-1.917-6.328 1.65-13.012 7.98-14.935C93.27 62.027 168.434 64.68 215.929 92.876c5.702 3.376 7.566 10.724 4.188 16.405c-3.362 5.69-10.73 7.565-16.4 4.187z",
		fill: "#1ed760"
	})
});
var TikTokIcon = ({ className }) => /* @__PURE__ */ jsxs("svg", {
	className,
	viewBox: "0 0 256 290",
	xmlns: "http://www.w3.org/2000/svg",
	children: [
		/* @__PURE__ */ jsx("path", {
			d: "M189.72 104.421c18.678 13.345 41.56 21.197 66.273 21.197v-47.53a67 67 0 0 1-13.918-1.456v37.413c-24.711 0-47.59-7.851-66.272-21.195v96.996c0 48.523-39.356 87.855-87.9 87.855c-18.113 0-34.949-5.473-48.934-14.86c15.962 16.313 38.222 26.432 62.848 26.432c48.548 0 87.905-39.332 87.905-87.857v-96.995zm17.17-47.952c-9.546-10.423-15.814-23.893-17.17-38.785v-6.113h-13.189c3.32 18.927 14.644 35.097 30.358 44.898M69.673 225.607a40 40 0 0 1-8.203-24.33c0-22.192 18.001-40.186 40.21-40.186a40.3 40.3 0 0 1 12.197 1.883v-48.593c-4.61-.631-9.262-.9-13.912-.801v37.822a40.3 40.3 0 0 0-12.203-1.882c-22.208 0-40.208 17.992-40.208 40.187c0 15.694 8.997 29.281 22.119 35.9",
			fill: "#ff004f"
		}),
		/* @__PURE__ */ jsx("path", { d: "M175.803 92.849c18.683 13.344 41.56 21.195 66.272 21.195V76.631c-13.794-2.937-26.005-10.141-35.186-20.162c-15.715-9.802-27.038-25.972-30.358-44.898h-34.643v189.843c-.079 22.132-18.049 40.052-40.21 40.052c-13.058 0-24.66-6.221-32.007-15.86c-13.12-6.618-22.118-20.206-22.118-35.898c0-22.193 18-40.187 40.208-40.187c4.255 0 8.356.662 12.203 1.882v-37.822c-47.692.985-86.047 39.933-86.047 87.834c0 23.912 9.551 45.589 25.053 61.428c13.985 9.385 30.82 14.86 48.934 14.86c48.545 0 87.9-39.335 87.9-87.857z" }),
		/* @__PURE__ */ jsx("path", {
			d: "M242.075 76.63V66.516a66.3 66.3 0 0 1-35.186-10.047a66.47 66.47 0 0 0 35.186 20.163M176.53 11.57a68 68 0 0 1-.728-5.457V0h-47.834v189.845c-.076 22.13-18.046 40.05-40.208 40.05a40.06 40.06 0 0 1-18.09-4.287c7.347 9.637 18.949 15.857 32.007 15.857c22.16 0 40.132-17.918 40.21-40.05V11.571zM99.966 113.58v-10.769a89 89 0 0 0-12.061-.818C39.355 101.993 0 141.327 0 189.845c0 30.419 15.467 57.227 38.971 72.996c-15.502-15.838-25.053-37.516-25.053-61.427c0-47.9 38.354-86.848 86.048-87.833",
			fill: "#00f2ea"
		})
	]
});
var TwitchIcon = ({ className }) => /* @__PURE__ */ jsxs("svg", {
	className,
	version: "1.1",
	viewBox: "0 0 2400 2800",
	x: "0px",
	xmlSpace: "preserve",
	xmlns: "http://www.w3.org/2000/svg",
	xmlnsXlink: "http://www.w3.org/1999/xlink",
	y: "0px",
	children: [
		/* @__PURE__ */ jsx("style", {
			type: "text/css",
			children: `
                .st0{fill:#FFFFFF}
                .st1{fill:#9146FF}
            `
		}),
		/* @__PURE__ */ jsx("title", { children: "Asset 2" }),
		/* @__PURE__ */ jsxs("g", { children: [/* @__PURE__ */ jsx("polygon", {
			className: "st0",
			points: "2200,1300 1800,1700 1400,1700 1050,2050 1050,1700 600,1700 600,200 2200,200"
		}), /* @__PURE__ */ jsx("g", { children: /* @__PURE__ */ jsxs("g", { children: [
			/* @__PURE__ */ jsx("path", {
				className: "st1",
				d: "M500,0L0,500v1800h600v500l500-500h400l900-900V0H500z M2200,1300l-400,400h-400l-350,350v-350H600V200h1600V1300z"
			}),
			/* @__PURE__ */ jsx("rect", {
				className: "st1",
				height: "600",
				width: "200",
				x: "1700",
				y: "550"
			}),
			/* @__PURE__ */ jsx("rect", {
				className: "st1",
				height: "600",
				width: "200",
				x: "1150",
				y: "550"
			})
		] }) })] })
	]
});
var VercelIcon = ({ className }) => /* @__PURE__ */ jsx("svg", {
	"data-testid": "geist-icon",
	height: "16",
	"stroke-linejoin": "round",
	viewBox: "0 0 16 16",
	width: "16",
	className,
	style: { color: "currentcolor" },
	children: /* @__PURE__ */ jsx("path", {
		"fill-rule": "evenodd",
		"clip-rule": "evenodd",
		d: "M8 1L16 15H0L8 1Z",
		fill: "currentColor"
	})
});
var VKIcon = ({ className }) => /* @__PURE__ */ jsx("svg", {
	className,
	viewBox: "0 0 576 512",
	xmlns: "http://www.w3.org/2000/svg",
	children: /* @__PURE__ */ jsx("path", {
		d: "M545 117.7c3.7-12.5 0-21.7-17.8-21.7h-58.9c-15 0-21.9 7.9-25.6 16.7c0 0-30 73.1-72.4 120.5c-13.7 13.7-20 18.1-27.5 18.1c-3.7 0-9.4-4.4-9.4-16.9V117.7c0-15-4.2-21.7-16.6-21.7h-92.6c-9.4 0-15 7-15 13.5c0 14.2 21.2 17.5 23.4 57.5v86.8c0 19-3.4 22.5-10.9 22.5c-20 0-68.6-73.4-97.4-157.4c-5.8-16.3-11.5-22.9-26.6-22.9H38.8c-16.8 0-20.2 7.9-20.2 16.7c0 15.6 20 93.1 93.1 195.5C160.4 378.1 229 416 291.4 416c37.5 0 42.1-8.4 42.1-22.9c0-66.8-3.4-73.1 15.4-73.1c8.7 0 23.7 4.4 58.7 38.1c40 40 46.6 57.9 69 57.9h58.9c16.8 0 25.3-8.4 20.4-25c-11.2-34.9-86.9-106.7-90.3-111.5c-8.7-11.2-6.2-16.2 0-26.2c.1-.1 72-101.3 79.4-135.6",
		fill: "currentColor"
	})
});
var XIcon3 = ({ className }) => /* @__PURE__ */ jsx("svg", {
	className,
	viewBox: "0 0 512 512",
	xmlns: "http://www.w3.org/2000/svg",
	children: /* @__PURE__ */ jsx("path", {
		d: "M389.2 48h70.6L305.6 224.2L487 464H345L233.7 318.6L106.5 464H35.8l164.9-188.5L26.8 48h145.6l100.5 132.9zm-24.8 373.8h39.1L151.1 88h-42z",
		fill: "currentColor"
	})
});
var ZoomIcon = ({ className }) => /* @__PURE__ */ jsx("svg", {
	className,
	xmlns: "http://www.w3.org/2000/svg",
	width: 512,
	height: 117,
	viewBox: "0 0 512 117",
	children: /* @__PURE__ */ jsx("path", {
		fill: "#0b5cff",
		d: "M107.472 114.706H16.348c-5.968 0-11.791-3.203-14.557-8.589C-1.41 99.858-.247 92.434 4.702 87.63L68.17 24.164H22.607C10.088 24.164.044 13.974.044 1.6h83.992c5.968 0 11.79 3.203 14.556 8.589c3.203 6.259 2.038 13.683-2.911 18.486L32.214 92.143h52.55c12.518 0 22.708 10.19 22.708 22.563M468.183 0c-13.1 0-24.746 5.677-32.898 14.702C427.134 5.677 415.488 0 402.388 0c-24.164 0-43.961 20.67-43.961 44.834v69.872c12.518 0 22.562-10.19 22.562-22.563V44.689c0-11.646 9.025-21.544 20.67-21.98c12.228-.437 22.272 9.315 22.272 21.397v48.037c0 12.519 10.19 22.563 22.563 22.563V44.543c0-11.645 9.025-21.544 20.67-21.98c12.228-.437 22.272 9.316 22.272 21.398v48.036c0 12.52 10.19 22.563 22.563 22.563V44.69C512.144 20.67 492.347 0 468.183 0M221.595 58.226c0 32.17-26.056 58.226-58.226 58.226s-58.226-26.056-58.226-58.226S131.199 0 163.369 0s58.226 26.056 58.226 58.226m-22.563 0c0-19.651-16.012-35.663-35.663-35.663s-35.664 16.012-35.664 35.663c0 19.652 16.013 35.664 35.664 35.664s35.663-16.012 35.663-35.664m148.04 0c0 32.17-26.056 58.226-58.226 58.226S230.62 90.396 230.62 58.226S256.676 0 288.846 0s58.227 26.056 58.227 58.226m-22.562 0c0-19.651-16.012-35.663-35.664-35.663c-19.65 0-35.663 16.012-35.663 35.663c0 19.652 16.012 35.664 35.663 35.664c19.652 0 35.664-16.012 35.664-35.664"
	})
});
var socialProviders = [
	{
		provider: "apple",
		name: "Apple",
		icon: AppleIcon
	},
	{
		provider: "discord",
		name: "Discord",
		icon: DiscordIcon
	},
	{
		provider: "dropbox",
		name: "Dropbox",
		icon: DropboxIcon
	},
	{
		provider: "facebook",
		name: "Facebook",
		icon: FacebookIcon
	},
	{
		provider: "github",
		name: "GitHub",
		icon: GitHubIcon
	},
	{
		provider: "gitlab",
		name: "GitLab",
		icon: GitLabIcon
	},
	{
		provider: "google",
		name: "Google",
		icon: GoogleIcon
	},
	{
		provider: "huggingface",
		name: "Hugging Face",
		icon: HuggingFaceIcon
	},
	{
		provider: "kick",
		name: "Kick",
		icon: KickIcon
	},
	{
		provider: "linear",
		name: "Linear",
		icon: LinearIcon
	},
	{
		provider: "linkedin",
		name: "LinkedIn",
		icon: LinkedInIcon
	},
	{
		provider: "microsoft",
		name: "Microsoft",
		icon: MicrosoftIcon
	},
	{
		provider: "notion",
		name: "Notion",
		icon: NotionIcon
	},
	{
		provider: "reddit",
		name: "Reddit",
		icon: RedditIcon
	},
	{
		provider: "roblox",
		name: "Roblox",
		icon: RobloxIcon
	},
	{
		provider: "slack",
		name: "Slack",
		icon: SlackIcon
	},
	{
		provider: "spotify",
		name: "Spotify",
		icon: SpotifyIcon
	},
	{
		provider: "tiktok",
		name: "TikTok",
		icon: TikTokIcon
	},
	{
		provider: "twitch",
		name: "Twitch",
		icon: TwitchIcon
	},
	{
		provider: "vercel",
		name: "Vercel",
		icon: VercelIcon
	},
	{
		provider: "vk",
		name: "VK",
		icon: VKIcon
	},
	{
		provider: "twitter",
		name: "X",
		icon: XIcon3
	},
	{
		provider: "zoom",
		name: "Zoom",
		icon: ZoomIcon
	}
];
function ProviderCell({ className, classNames, account, localization, other, provider, refetch }) {
	const { authClient: authClient2, basePath, baseURL, localization: contextLocalization, mutators: { unlinkAccount }, viewPaths, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const [isLoading, setIsLoading] = useState(false);
	const handleLink = async () => {
		setIsLoading(true);
		const callbackURL = `${baseURL}${basePath}/${viewPaths.CALLBACK}?redirectTo=${encodeURIComponent(window.location.pathname)}`;
		try {
			if (other) await authClient2.oauth2.link({
				providerId: provider.provider,
				callbackURL,
				fetchOptions: { throw: true }
			});
			else await authClient2.linkSocial({
				provider: provider.provider,
				callbackURL,
				fetchOptions: { throw: true }
			});
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
			setIsLoading(false);
		}
	};
	const handleUnlink = async () => {
		setIsLoading(true);
		try {
			await unlinkAccount({
				accountId: account == null ? void 0 : account.accountId,
				providerId: provider.provider
			});
			await (refetch == null ? void 0 : refetch());
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
		setIsLoading(false);
	};
	return /* @__PURE__ */ jsxs(Card, {
		className: cn("flex-row items-center gap-3 px-4 py-3", className, classNames == null ? void 0 : classNames.cell),
		children: [
			provider.icon && /* @__PURE__ */ jsx(provider.icon, { className: cn("size-4", classNames == null ? void 0 : classNames.icon) }),
			/* @__PURE__ */ jsxs("div", {
				className: "flex-col",
				children: [/* @__PURE__ */ jsx("div", {
					className: "text-sm",
					children: provider.name
				}), account && /* @__PURE__ */ jsx(AccountInfo, { account })]
			}),
			/* @__PURE__ */ jsxs(Button, {
				className: cn("relative ms-auto", classNames == null ? void 0 : classNames.button),
				disabled: isLoading,
				size: "sm",
				type: "button",
				variant: account ? "outline" : "default",
				onClick: account ? handleUnlink : handleLink,
				children: [isLoading && /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }), account ? localization.UNLINK : localization.LINK]
			})
		]
	});
}
function AccountInfo({ account }) {
	const { hooks: { useAccountInfo } } = useContext(AuthUIContext);
	const { data: accountInfo, isPending } = useAccountInfo({ query: { accountId: account.accountId } });
	if (isPending) return /* @__PURE__ */ jsx(Skeleton, { className: "my-0.5 h-3 w-28" });
	if (!accountInfo) return null;
	return /* @__PURE__ */ jsx("div", {
		className: "text-muted-foreground text-xs",
		children: accountInfo == null ? void 0 : accountInfo.user.email
	});
}
function ProvidersCard({ className, classNames, accounts, isPending, localization, skipHook, refetch }) {
	var _a, _b, _c;
	const { hooks: { useListAccounts }, localization: contextLocalization, social, genericOAuth } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	if (!skipHook) {
		const result = useListAccounts();
		accounts = result.data;
		isPending = result.isPending;
		refetch = result.refetch;
	}
	return /* @__PURE__ */ jsx(SettingsCard, {
		className,
		classNames,
		title: localization.PROVIDERS,
		description: localization.PROVIDERS_DESCRIPTION,
		isPending,
		children: /* @__PURE__ */ jsx(CardContent, {
			className: cn("grid gap-4", classNames == null ? void 0 : classNames.content),
			children: isPending ? (_a = social == null ? void 0 : social.providers) == null ? void 0 : _a.map((provider) => /* @__PURE__ */ jsx(SettingsCellSkeleton, { classNames }, provider)) : /* @__PURE__ */ jsxs(Fragment$1, { children: [
				accounts == null ? void 0 : accounts.map((account) => {
					var _a2;
					const socialProvider = socialProviders.find((sp) => sp.provider === account.providerId);
					const genericOAuthProvider = (_a2 = genericOAuth == null ? void 0 : genericOAuth.providers) == null ? void 0 : _a2.find((gp) => gp.provider === account.providerId);
					const provider = socialProvider || genericOAuthProvider;
					if (!provider) return null;
					return /* @__PURE__ */ jsx(ProviderCell, {
						classNames,
						account,
						provider,
						refetch,
						other: !socialProvider
					}, account.providerId);
				}),
				(_b = social == null ? void 0 : social.providers) == null ? void 0 : _b.map((provider) => {
					const socialProvider = socialProviders.find((socialProvider2) => socialProvider2.provider === provider);
					if (!socialProvider) return null;
					return /* @__PURE__ */ jsx(ProviderCell, {
						classNames,
						provider: socialProvider,
						refetch
					}, provider);
				}),
				(_c = genericOAuth == null ? void 0 : genericOAuth.providers) == null ? void 0 : _c.map((provider) => /* @__PURE__ */ jsx(ProviderCell, {
					classNames,
					account: accounts == null ? void 0 : accounts.find((acc) => acc.providerId === provider.provider),
					provider,
					refetch,
					other: true
				}, provider.provider))
			] })
		})
	});
}
function PasswordInput({ className, enableToggle, onChange, ...props }) {
	const [disabled, setDisabled] = useState(true);
	const [isVisible, setIsVisible] = useState(false);
	return /* @__PURE__ */ jsxs("div", {
		className: "relative",
		children: [/* @__PURE__ */ jsx(Input, {
			className: cn(enableToggle && "pr-10", className),
			...props,
			type: isVisible && enableToggle ? "text" : "password",
			onChange: (event) => {
				setDisabled(!event.target.value);
				onChange?.(event);
			}
		}), enableToggle && /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(Button, {
			className: "!bg-transparent absolute top-0 right-0",
			disabled,
			size: "icon",
			type: "button",
			variant: "ghost",
			onClick: () => setIsVisible(!isVisible),
			children: isVisible ? /* @__PURE__ */ jsx(EyeIcon, {}) : /* @__PURE__ */ jsx(EyeOffIcon, {})
		}), /* @__PURE__ */ jsx("style", { children: `
                        .hide-password-toggle::-ms-reveal,
                        .hide-password-toggle::-ms-clear {
                            visibility: hidden;
                            pointer-events: none;
                            display: none;
                        }
                    ` })] })]
	});
}
function InputFieldSkeleton({ classNames }) {
	return /* @__PURE__ */ jsxs("div", {
		className: "flex flex-col gap-1.5",
		children: [/* @__PURE__ */ jsx(Skeleton, { className: cn("h-4 w-32", classNames == null ? void 0 : classNames.skeleton) }), /* @__PURE__ */ jsx(Skeleton, { className: cn("h-9 w-full", classNames == null ? void 0 : classNames.skeleton) })]
	});
}
function ChangePasswordCard({ className, classNames, accounts, isPending, localization, skipHook, passwordValidation }) {
	const { authClient: authClient2, basePath, baseURL, credentials, hooks: { useSession, useListAccounts }, localization: contextLocalization, viewPaths, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	const confirmPasswordEnabled = credentials == null ? void 0 : credentials.confirmPassword;
	const contextPasswordValidation = credentials == null ? void 0 : credentials.passwordValidation;
	localization = {
		...contextLocalization,
		...localization
	};
	passwordValidation = {
		...contextPasswordValidation,
		...passwordValidation
	};
	const { data: sessionData } = useSession();
	if (!skipHook) {
		const result = useListAccounts();
		accounts = result.data;
		isPending = result.isPending;
	}
	const form = useForm({
		resolver: zodResolver(z$1.object({
			currentPassword: getPasswordSchema(passwordValidation, localization),
			newPassword: getPasswordSchema(passwordValidation, {
				PASSWORD_REQUIRED: localization.NEW_PASSWORD_REQUIRED,
				PASSWORD_TOO_SHORT: localization.PASSWORD_TOO_SHORT,
				PASSWORD_TOO_LONG: localization.PASSWORD_TOO_LONG,
				INVALID_PASSWORD: localization.INVALID_PASSWORD
			}),
			confirmPassword: confirmPasswordEnabled ? getPasswordSchema(passwordValidation, {
				PASSWORD_REQUIRED: localization.CONFIRM_PASSWORD_REQUIRED,
				PASSWORD_TOO_SHORT: localization.PASSWORD_TOO_SHORT,
				PASSWORD_TOO_LONG: localization.PASSWORD_TOO_LONG,
				INVALID_PASSWORD: localization.INVALID_PASSWORD
			}) : z$1.string().optional()
		}).refine((data) => !confirmPasswordEnabled || data.newPassword === data.confirmPassword, {
			message: localization.PASSWORDS_DO_NOT_MATCH,
			path: ["confirmPassword"]
		})),
		defaultValues: {
			currentPassword: "",
			newPassword: "",
			confirmPassword: ""
		}
	});
	const setPasswordForm = useForm();
	const { isSubmitting } = form.formState;
	const setPassword = async () => {
		if (!sessionData) return;
		const email = sessionData == null ? void 0 : sessionData.user.email;
		try {
			await authClient2.requestPasswordReset({
				email,
				redirectTo: `${baseURL}${basePath}/${viewPaths.RESET_PASSWORD}`,
				fetchOptions: { throw: true }
			});
			toast$1({
				variant: "success",
				message: localization.FORGOT_PASSWORD_EMAIL
			});
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
	};
	const changePassword = async ({ currentPassword, newPassword }) => {
		try {
			await authClient2.changePassword({
				currentPassword,
				newPassword,
				revokeOtherSessions: true,
				fetchOptions: { throw: true }
			});
			toast$1({
				variant: "success",
				message: localization.CHANGE_PASSWORD_SUCCESS
			});
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
		form.reset();
	};
	const credentialsLinked = accounts == null ? void 0 : accounts.some((acc) => acc.providerId === "credential");
	if (!isPending && !credentialsLinked) return /* @__PURE__ */ jsx(Form, {
		...setPasswordForm,
		children: /* @__PURE__ */ jsx("form", {
			onSubmit: setPasswordForm.handleSubmit(setPassword),
			children: /* @__PURE__ */ jsx(SettingsCard, {
				title: localization.SET_PASSWORD,
				description: localization.SET_PASSWORD_DESCRIPTION,
				actionLabel: localization.SET_PASSWORD,
				isPending,
				className,
				classNames
			})
		})
	});
	return /* @__PURE__ */ jsx(Form, {
		...form,
		children: /* @__PURE__ */ jsx("form", {
			onSubmit: form.handleSubmit(changePassword),
			children: /* @__PURE__ */ jsx(SettingsCard, {
				className,
				classNames,
				actionLabel: localization.SAVE,
				description: localization.CHANGE_PASSWORD_DESCRIPTION,
				instructions: localization.CHANGE_PASSWORD_INSTRUCTIONS,
				isPending,
				title: localization.CHANGE_PASSWORD,
				children: /* @__PURE__ */ jsx(CardContent, {
					className: cn("grid gap-6", classNames == null ? void 0 : classNames.content),
					children: isPending || !accounts ? /* @__PURE__ */ jsxs(Fragment$1, { children: [
						/* @__PURE__ */ jsx(InputFieldSkeleton, { classNames }),
						/* @__PURE__ */ jsx(InputFieldSkeleton, { classNames }),
						confirmPasswordEnabled && /* @__PURE__ */ jsx(InputFieldSkeleton, { classNames })
					] }) : /* @__PURE__ */ jsxs(Fragment$1, { children: [
						/* @__PURE__ */ jsx(FormField, {
							control: form.control,
							name: "currentPassword",
							render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
								/* @__PURE__ */ jsx(FormLabel, {
									className: classNames == null ? void 0 : classNames.label,
									children: localization.CURRENT_PASSWORD
								}),
								/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(PasswordInput, {
									className: classNames == null ? void 0 : classNames.input,
									autoComplete: "current-password",
									placeholder: localization.CURRENT_PASSWORD_PLACEHOLDER,
									disabled: isSubmitting,
									...field
								}) }),
								/* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })
							] })
						}),
						/* @__PURE__ */ jsx(FormField, {
							control: form.control,
							name: "newPassword",
							render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
								/* @__PURE__ */ jsx(FormLabel, {
									className: classNames == null ? void 0 : classNames.label,
									children: localization.NEW_PASSWORD
								}),
								/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(PasswordInput, {
									className: classNames == null ? void 0 : classNames.input,
									autoComplete: "new-password",
									disabled: isSubmitting,
									placeholder: localization.NEW_PASSWORD_PLACEHOLDER,
									enableToggle: true,
									...field
								}) }),
								/* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })
							] })
						}),
						confirmPasswordEnabled && /* @__PURE__ */ jsx(FormField, {
							control: form.control,
							name: "confirmPassword",
							render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
								/* @__PURE__ */ jsx(FormLabel, {
									className: classNames == null ? void 0 : classNames.label,
									children: localization.CONFIRM_PASSWORD
								}),
								/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(PasswordInput, {
									className: classNames == null ? void 0 : classNames.input,
									autoComplete: "new-password",
									placeholder: localization.CONFIRM_PASSWORD_PLACEHOLDER,
									disabled: isSubmitting,
									enableToggle: true,
									...field
								}) }),
								/* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })
							] })
						})
					] })
				})
			})
		})
	});
}
function SessionCell({ className, classNames, localization, session, refetch }) {
	var _a, _b;
	const { basePath, hooks: { useSession }, localization: contextLocalization, mutators: { revokeSession }, viewPaths, navigate, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const { data: sessionData } = useSession();
	const isCurrentSession = session.id === ((_a = sessionData == null ? void 0 : sessionData.session) == null ? void 0 : _a.id);
	const [isLoading, setIsLoading] = useState(false);
	const handleRevoke = async () => {
		setIsLoading(true);
		if (isCurrentSession) {
			navigate(`${basePath}/${viewPaths.SIGN_OUT}`);
			return;
		}
		try {
			await revokeSession({ token: session.token });
			refetch?.();
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
			setIsLoading(false);
		}
	};
	const parser = UAParser(session.userAgent);
	const isMobile = parser.device.type === "mobile";
	return /* @__PURE__ */ jsxs(Card, {
		className: cn("flex-row items-center gap-3 px-4 py-3", className, classNames == null ? void 0 : classNames.cell),
		children: [
			isMobile ? /* @__PURE__ */ jsx(SmartphoneIcon, { className: cn("size-4", classNames == null ? void 0 : classNames.icon) }) : /* @__PURE__ */ jsx(LaptopIcon, { className: cn("size-4", classNames == null ? void 0 : classNames.icon) }),
			/* @__PURE__ */ jsxs("div", {
				className: "flex flex-col",
				children: [/* @__PURE__ */ jsx("span", {
					className: "font-semibold text-sm",
					children: isCurrentSession ? localization.CURRENT_SESSION : session == null ? void 0 : session.ipAddress
				}), /* @__PURE__ */ jsx("span", {
					className: "text-muted-foreground text-xs",
					children: ((_b = session.userAgent) == null ? void 0 : _b.includes("tauri-plugin-http")) ? localization.APP : parser.os.name && parser.browser.name ? `${parser.os.name}, ${parser.browser.name}` : parser.os.name || parser.browser.name || session.userAgent || localization.UNKNOWN
				})]
			}),
			/* @__PURE__ */ jsxs(Button, {
				className: cn("relative ms-auto", classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.outlineButton),
				disabled: isLoading,
				size: "sm",
				variant: "outline",
				onClick: handleRevoke,
				children: [isLoading && /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }), isCurrentSession ? localization.SIGN_OUT : localization.REVOKE]
			})
		]
	});
}
function SessionsCard({ className, classNames, localization }) {
	const { hooks: { useListSessions }, localization: contextLocalization } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const { data: sessions, isPending, refetch } = useListSessions();
	return /* @__PURE__ */ jsx(SettingsCard, {
		className,
		classNames,
		description: localization.SESSIONS_DESCRIPTION,
		isPending,
		title: localization.SESSIONS,
		children: /* @__PURE__ */ jsx(CardContent, {
			className: cn("grid gap-4", classNames == null ? void 0 : classNames.content),
			children: isPending ? /* @__PURE__ */ jsx(SettingsCellSkeleton, { classNames }, "skeleton") : sessions == null ? void 0 : sessions.map((session) => /* @__PURE__ */ jsx(SessionCell, {
				classNames,
				localization,
				session,
				refetch
			}, session.id))
		})
	});
}
function BackupCodesDialog({ classNames, backupCodes, onOpenChange, ...props }) {
	var _a, _b, _c;
	const { localization } = useContext(AuthUIContext);
	const [copied, setCopied] = useState(false);
	const handleCopy = () => {
		const codeText = backupCodes.join("\n");
		navigator.clipboard.writeText(codeText);
		setCopied(true);
		setTimeout(() => setCopied(false), 2e3);
	};
	return /* @__PURE__ */ jsx(Dialog, {
		onOpenChange,
		...props,
		children: /* @__PURE__ */ jsxs(DialogContent, {
			onOpenAutoFocus: (e) => e.preventDefault(),
			className: (_a = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _a.content,
			children: [
				/* @__PURE__ */ jsxs(DialogHeader, {
					className: (_b = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _b.header,
					children: [/* @__PURE__ */ jsx(DialogTitle, {
						className: cn("text-lg md:text-xl", classNames == null ? void 0 : classNames.title),
						children: localization.BACKUP_CODES
					}), /* @__PURE__ */ jsx(DialogDescription, {
						className: cn("text-xs md:text-sm", classNames == null ? void 0 : classNames.description),
						children: localization.BACKUP_CODES_DESCRIPTION
					})]
				}),
				/* @__PURE__ */ jsx("div", {
					className: "grid grid-cols-2 gap-2",
					children: backupCodes.map((code, index) => /* @__PURE__ */ jsx("div", {
						className: "rounded-md bg-muted p-2 text-center font-mono text-sm",
						children: code
					}, index))
				}),
				/* @__PURE__ */ jsxs(DialogFooter, {
					className: (_c = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _c.footer,
					children: [/* @__PURE__ */ jsx(Button, {
						type: "button",
						variant: "outline",
						onClick: handleCopy,
						disabled: copied,
						className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.outlineButton),
						children: copied ? /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(CheckIcon, { className: classNames == null ? void 0 : classNames.icon }), localization.COPIED_TO_CLIPBOARD] }) : /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(CopyIcon, { className: classNames == null ? void 0 : classNames.icon }), localization.COPY_ALL_CODES] })
					}), /* @__PURE__ */ jsx(Button, {
						type: "button",
						variant: "default",
						onClick: () => onOpenChange == null ? void 0 : onOpenChange(false),
						className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.primaryButton),
						children: localization.CONTINUE
					})]
				})
			]
		})
	});
}
function TwoFactorPasswordDialog({ classNames, onOpenChange, isTwoFactorEnabled, ...props }) {
	var _a, _b;
	const { localization, authClient: authClient2, basePath, viewPaths, navigate, toast: toast$1, twoFactor, localizeErrors } = useContext(AuthUIContext);
	const [showBackupCodesDialog, setShowBackupCodesDialog] = useState(false);
	const [backupCodes, setBackupCodes] = useState([]);
	const [totpURI, setTotpURI] = useState(null);
	const form = useForm({
		resolver: zodResolver(z$1.object({ password: z$1.string().min(1, { message: localization.PASSWORD_REQUIRED }) })),
		defaultValues: { password: "" }
	});
	const { isSubmitting } = form.formState;
	async function enableTwoFactor({ password }) {
		try {
			const response = await authClient2.twoFactor.enable({
				password,
				fetchOptions: { throw: true }
			});
			onOpenChange?.(false);
			setBackupCodes(response.backupCodes);
			if (twoFactor == null ? void 0 : twoFactor.includes("totp")) setTotpURI(response.totpURI);
			setTimeout(() => {
				setShowBackupCodesDialog(true);
			}, 250);
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
	}
	async function disableTwoFactor({ password }) {
		try {
			await authClient2.twoFactor.disable({
				password,
				fetchOptions: { throw: true }
			});
			toast$1({
				variant: "success",
				message: localization.TWO_FACTOR_DISABLED
			});
			onOpenChange?.(false);
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
	}
	return /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(Dialog, {
		onOpenChange,
		...props,
		children: /* @__PURE__ */ jsxs(DialogContent, {
			className: cn("sm:max-w-md", classNames == null ? void 0 : classNames.dialog),
			children: [/* @__PURE__ */ jsxs(DialogHeader, {
				className: (_a = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _a.header,
				children: [/* @__PURE__ */ jsx(DialogTitle, {
					className: classNames == null ? void 0 : classNames.title,
					children: localization.TWO_FACTOR
				}), /* @__PURE__ */ jsx(DialogDescription, {
					className: classNames == null ? void 0 : classNames.description,
					children: isTwoFactorEnabled ? localization.TWO_FACTOR_DISABLE_INSTRUCTIONS : localization.TWO_FACTOR_ENABLE_INSTRUCTIONS
				})]
			}), /* @__PURE__ */ jsx(Form, {
				...form,
				children: /* @__PURE__ */ jsxs("form", {
					onSubmit: form.handleSubmit(isTwoFactorEnabled ? disableTwoFactor : enableTwoFactor),
					className: "grid gap-4",
					children: [/* @__PURE__ */ jsx(FormField, {
						control: form.control,
						name: "password",
						render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
							/* @__PURE__ */ jsx(FormLabel, {
								className: classNames == null ? void 0 : classNames.label,
								children: localization.PASSWORD
							}),
							/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(PasswordInput, {
								className: classNames == null ? void 0 : classNames.input,
								placeholder: localization.PASSWORD_PLACEHOLDER,
								autoComplete: "current-password",
								...field
							}) }),
							/* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })
						] })
					}), /* @__PURE__ */ jsxs(DialogFooter, {
						className: (_b = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _b.footer,
						children: [/* @__PURE__ */ jsx(Button, {
							type: "button",
							variant: "secondary",
							onClick: () => onOpenChange == null ? void 0 : onOpenChange(false),
							className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.secondaryButton),
							children: localization.CANCEL
						}), /* @__PURE__ */ jsxs(Button, {
							type: "submit",
							disabled: isSubmitting,
							className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.primaryButton),
							children: [isSubmitting && /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }), isTwoFactorEnabled ? localization.DISABLE_TWO_FACTOR : localization.ENABLE_TWO_FACTOR]
						})]
					})]
				})
			})]
		})
	}), /* @__PURE__ */ jsx(BackupCodesDialog, {
		classNames,
		open: showBackupCodesDialog,
		onOpenChange: (open) => {
			setShowBackupCodesDialog(open);
			if (!open) {
				const url = `${basePath}/${viewPaths.TWO_FACTOR}`;
				navigate((twoFactor == null ? void 0 : twoFactor.includes("totp")) && totpURI ? `${url}?totpURI=${totpURI}` : url);
			}
		},
		backupCodes
	})] });
}
function TwoFactorCard({ className, classNames, localization }) {
	var _a;
	const { localization: contextLocalization, hooks: { useSession } } = useContext(AuthUIContext);
	const [showPasswordDialog, setShowPasswordDialog] = useState(false);
	localization = {
		...contextLocalization,
		...localization
	};
	const { data: sessionData, isPending } = useSession();
	const isTwoFactorEnabled = (_a = sessionData == null ? void 0 : sessionData.user) == null ? void 0 : _a.twoFactorEnabled;
	return /* @__PURE__ */ jsxs("div", { children: [/* @__PURE__ */ jsx(SettingsCard, {
		className,
		classNames,
		actionLabel: isTwoFactorEnabled ? localization.DISABLE_TWO_FACTOR : localization.ENABLE_TWO_FACTOR,
		description: localization.TWO_FACTOR_CARD_DESCRIPTION,
		instructions: isTwoFactorEnabled ? localization.TWO_FACTOR_DISABLE_INSTRUCTIONS : localization.TWO_FACTOR_ENABLE_INSTRUCTIONS,
		isPending,
		title: localization.TWO_FACTOR,
		action: () => setShowPasswordDialog(true)
	}), /* @__PURE__ */ jsx(TwoFactorPasswordDialog, {
		classNames,
		open: showPasswordDialog,
		onOpenChange: setShowPasswordDialog,
		isTwoFactorEnabled: !!isTwoFactorEnabled
	})] });
}
function SecuritySettingsCards({ className, classNames, localization }) {
	var _a, _b;
	const { credentials, deleteUser, hooks, localization: contextLocalization, passkey, social, genericOAuth, twoFactor } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const { useListAccounts } = hooks;
	const { data: accounts, isPending: accountsPending, refetch: refetchAccounts } = useListAccounts();
	const credentialsLinked = accounts == null ? void 0 : accounts.some((acc) => acc.providerId === "credential");
	return /* @__PURE__ */ jsxs("div", {
		className: cn("flex w-full flex-col gap-4 md:gap-6", className, classNames == null ? void 0 : classNames.cards),
		children: [
			credentials && /* @__PURE__ */ jsx(ChangePasswordCard, {
				accounts,
				classNames: classNames == null ? void 0 : classNames.card,
				isPending: accountsPending,
				localization,
				skipHook: true
			}),
			(((_a = social == null ? void 0 : social.providers) == null ? void 0 : _a.length) || ((_b = genericOAuth == null ? void 0 : genericOAuth.providers) == null ? void 0 : _b.length)) && /* @__PURE__ */ jsx(ProvidersCard, {
				accounts,
				classNames: classNames == null ? void 0 : classNames.card,
				isPending: accountsPending,
				localization,
				refetch: refetchAccounts,
				skipHook: true
			}),
			twoFactor && credentialsLinked && /* @__PURE__ */ jsx(TwoFactorCard, {
				classNames: classNames == null ? void 0 : classNames.card,
				localization
			}),
			passkey && /* @__PURE__ */ jsx(PasskeysCard, {
				classNames: classNames == null ? void 0 : classNames.card,
				localization
			}),
			/* @__PURE__ */ jsx(SessionsCard, {
				classNames: classNames == null ? void 0 : classNames.card,
				localization
			}),
			deleteUser && /* @__PURE__ */ jsx(DeleteAccountCard, {
				accounts,
				classNames: classNames == null ? void 0 : classNames.card,
				isPending: accountsPending,
				localization,
				skipHook: true
			})
		]
	});
}
var authClient = createAuthClient({ plugins: [
	apiKeyClient(),
	multiSessionClient(),
	passkeyClient(),
	oneTapClient({ clientId: "" }),
	genericOAuthClient(),
	anonymousClient(),
	usernameClient(),
	magicLinkClient(),
	emailOTPClient(),
	twoFactorClient(),
	organizationClient({ teams: { enabled: true } })
] });
function UserTeamCell({ className, classNames, team, localization, refetch }) {
	var _a;
	const { hooks: { useSession }, localization: contextLocalization, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const { data: sessionData, refetch: refetchSession } = useSession();
	const isCurrentTeam = team.id === ((_a = sessionData == null ? void 0 : sessionData.session) == null ? void 0 : _a.activeTeamId);
	const [isUpdating, setIsUpdating] = useState(false);
	const handleSetActiveTeam = async () => {
		try {
			setIsUpdating(true);
			await authClient.organization.setActiveTeam({
				teamId: team.id,
				fetchOptions: { throw: true }
			});
			toast$1({
				variant: "success",
				message: localization.UPDATE_TEAM_SUCCESS
			});
			await (refetchSession == null ? void 0 : refetchSession());
			await (refetch == null ? void 0 : refetch());
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		} finally {
			setIsUpdating(false);
		}
	};
	return /* @__PURE__ */ jsxs(Card, {
		className: cn("flex-row items-center gap-3 px-4 py-3", className, classNames == null ? void 0 : classNames.cell),
		children: [
			/* @__PURE__ */ jsx(UsersIcon, { className: cn("size-5 flex-shrink-0", classNames == null ? void 0 : classNames.icon) }),
			/* @__PURE__ */ jsxs("div", {
				className: "flex flex-col truncate",
				children: [/* @__PURE__ */ jsx("div", {
					className: "flex items-center gap-2",
					children: /* @__PURE__ */ jsx("span", {
						className: "truncate font-semibold text-sm",
						children: team.name
					})
				}), /* @__PURE__ */ jsx("div", {
					className: "truncate text-muted-foreground text-xs",
					children: localization == null ? void 0 : localization.TEAM
				})]
			}),
			/* @__PURE__ */ jsxs(Button, {
				className: cn("relative ms-auto", classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.outlineButton),
				disabled: isCurrentTeam || isUpdating,
				size: "sm",
				variant: "outline",
				onClick: handleSetActiveTeam,
				children: [isUpdating && /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }), isCurrentTeam ? localization.TEAM_ACTIVE : localization.TEAM_SET_ACTIVE]
			})
		]
	});
}
function UserTeamsCard({ className, classNames, localization }) {
	const { hooks: { useListUserTeams }, localization: contextLocalization } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const { data: teams, isPending, refetch } = useListUserTeams();
	return /* @__PURE__ */ jsx(SettingsCard, {
		className,
		classNames,
		description: localization.USER_TEAMS_DESCRIPTION,
		isPending,
		title: localization.TEAMS,
		children: /* @__PURE__ */ jsx(CardContent, {
			className: cn("grid gap-4", classNames == null ? void 0 : classNames.content),
			children: isPending ? /* @__PURE__ */ jsx(SettingsCellSkeleton, { classNames }, "skeleton") : teams && teams.length > 0 ? teams.sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()).map((team) => /* @__PURE__ */ jsx(UserTeamCell, {
				classNames,
				localization,
				refetch,
				team
			}, team.id)) : /* @__PURE__ */ jsx("p", {
				className: "text-muted-foreground text-sm",
				children: localization.NO_TEAMS_FOUND
			})
		})
	});
}
function Drawer$1({ ...props }) {
	return /* @__PURE__ */ jsx(Drawer.Root, {
		"data-slot": "drawer",
		...props
	});
}
function DrawerTrigger({ ...props }) {
	return /* @__PURE__ */ jsx(Drawer.Trigger, {
		"data-slot": "drawer-trigger",
		...props
	});
}
function DrawerPortal({ ...props }) {
	return /* @__PURE__ */ jsx(Drawer.Portal, {
		"data-slot": "drawer-portal",
		...props
	});
}
function DrawerOverlay({ className, ...props }) {
	return /* @__PURE__ */ jsx(Drawer.Overlay, {
		"data-slot": "drawer-overlay",
		className: cn("data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50", className),
		...props
	});
}
function DrawerContent({ className, children, ...props }) {
	return /* @__PURE__ */ jsxs(DrawerPortal, {
		"data-slot": "drawer-portal",
		children: [/* @__PURE__ */ jsx(DrawerOverlay, {}), /* @__PURE__ */ jsxs(Drawer.Content, {
			"data-slot": "drawer-content",
			className: cn("group/drawer-content bg-background fixed z-50 flex h-auto flex-col", "data-[vaul-drawer-direction=top]:inset-x-0 data-[vaul-drawer-direction=top]:top-0 data-[vaul-drawer-direction=top]:mb-24 data-[vaul-drawer-direction=top]:max-h-[80vh] data-[vaul-drawer-direction=top]:rounded-b-lg data-[vaul-drawer-direction=top]:border-b", "data-[vaul-drawer-direction=bottom]:inset-x-0 data-[vaul-drawer-direction=bottom]:bottom-0 data-[vaul-drawer-direction=bottom]:mt-24 data-[vaul-drawer-direction=bottom]:max-h-[80vh] data-[vaul-drawer-direction=bottom]:rounded-t-lg data-[vaul-drawer-direction=bottom]:border-t", "data-[vaul-drawer-direction=right]:inset-y-0 data-[vaul-drawer-direction=right]:right-0 data-[vaul-drawer-direction=right]:w-3/4 data-[vaul-drawer-direction=right]:border-l data-[vaul-drawer-direction=right]:sm:max-w-sm", "data-[vaul-drawer-direction=left]:inset-y-0 data-[vaul-drawer-direction=left]:left-0 data-[vaul-drawer-direction=left]:w-3/4 data-[vaul-drawer-direction=left]:border-r data-[vaul-drawer-direction=left]:sm:max-w-sm", className),
			...props,
			children: [/* @__PURE__ */ jsx("div", { className: "bg-muted mx-auto mt-4 hidden h-2 w-[100px] shrink-0 rounded-full group-data-[vaul-drawer-direction=bottom]/drawer-content:block" }), children]
		})]
	});
}
function DrawerHeader({ className, ...props }) {
	return /* @__PURE__ */ jsx("div", {
		"data-slot": "drawer-header",
		className: cn("flex flex-col gap-0.5 p-4 group-data-[vaul-drawer-direction=bottom]/drawer-content:text-center group-data-[vaul-drawer-direction=top]/drawer-content:text-center md:gap-1.5 md:text-left", className),
		...props
	});
}
function DrawerTitle({ className, ...props }) {
	return /* @__PURE__ */ jsx(Drawer.Title, {
		"data-slot": "drawer-title",
		className: cn("text-foreground font-semibold", className),
		...props
	});
}
function AccountView({ className, classNames, localization: localizationProp, path: pathProp, pathname, view: viewProp, hideNav, showTeams }) {
	var _a, _b;
	const { apiKey, teams: teamOptions, localization: contextLocalization, organization, account: accountOptions, Link } = useContext(AuthUIContext);
	if (!accountOptions) return null;
	const { enabled: teamsEnabled } = teamOptions || {};
	useAuthenticate();
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const path = pathProp ?? (pathname == null ? void 0 : pathname.split("/").pop());
	const view = viewProp || getViewByPath(accountOptions.viewPaths, path) || "SETTINGS";
	const navItems = [{
		view: "SETTINGS",
		label: localization.ACCOUNT
	}, {
		view: "SECURITY",
		label: localization.SECURITY
	}];
	if (teamsEnabled && showTeams) navItems.push({
		view: "TEAMS",
		label: localization.TEAMS
	});
	if (apiKey) navItems.push({
		view: "API_KEYS",
		label: localization.API_KEYS
	});
	if (organization) navItems.push({
		view: "ORGANIZATIONS",
		label: localization.ORGANIZATIONS
	});
	return /* @__PURE__ */ jsxs("div", {
		className: cn("flex w-full grow flex-col gap-4 md:flex-row md:gap-12", className, classNames == null ? void 0 : classNames.base),
		children: [
			!hideNav && /* @__PURE__ */ jsxs("div", {
				className: "flex justify-between gap-2 md:hidden",
				children: [/* @__PURE__ */ jsx(Label2, {
					className: "font-semibold text-base",
					children: (_a = navItems.find((i) => i.view === view)) == null ? void 0 : _a.label
				}), /* @__PURE__ */ jsxs(Drawer$1, { children: [/* @__PURE__ */ jsx(DrawerTrigger, {
					asChild: true,
					children: /* @__PURE__ */ jsx(Button, {
						variant: "outline",
						children: /* @__PURE__ */ jsx(MenuIcon, {})
					})
				}), /* @__PURE__ */ jsxs(DrawerContent, { children: [/* @__PURE__ */ jsx(DrawerHeader, { children: /* @__PURE__ */ jsx(DrawerTitle, {
					className: "hidden",
					children: localization.SETTINGS
				}) }), /* @__PURE__ */ jsx("div", {
					className: "flex flex-col px-4 pb-4",
					children: navItems.map((item) => {
						var _a2;
						return /* @__PURE__ */ jsx(Link, {
							href: `${accountOptions == null ? void 0 : accountOptions.basePath}/${accountOptions == null ? void 0 : accountOptions.viewPaths[item.view]}`,
							children: /* @__PURE__ */ jsx(Button, {
								size: "lg",
								className: cn("w-full justify-start px-4 transition-none", (_a2 = classNames == null ? void 0 : classNames.drawer) == null ? void 0 : _a2.menuItem, view === item.view ? "font-semibold" : "text-foreground/70"),
								variant: "ghost",
								children: item.label
							})
						}, item.view);
					})
				})] })] })]
			}),
			!hideNav && /* @__PURE__ */ jsx("div", {
				className: "hidden md:block",
				children: /* @__PURE__ */ jsx("div", {
					className: cn("flex w-48 flex-col gap-1 lg:w-60", (_b = classNames == null ? void 0 : classNames.sidebar) == null ? void 0 : _b.base),
					children: navItems.map((item) => {
						var _a2, _b2;
						return /* @__PURE__ */ jsx(Link, {
							href: `${accountOptions == null ? void 0 : accountOptions.basePath}/${accountOptions == null ? void 0 : accountOptions.viewPaths[item.view]}`,
							children: /* @__PURE__ */ jsx(Button, {
								size: "lg",
								className: cn("w-full justify-start px-4 transition-none", (_a2 = classNames == null ? void 0 : classNames.sidebar) == null ? void 0 : _a2.button, view === item.view ? "font-semibold" : "text-foreground/70", view === item.view && ((_b2 = classNames == null ? void 0 : classNames.sidebar) == null ? void 0 : _b2.buttonActive)),
								variant: "ghost",
								children: item.label
							})
						}, item.view);
					})
				})
			}),
			view === "SETTINGS" && /* @__PURE__ */ jsx(AccountSettingsCards, {
				classNames,
				localization
			}),
			view === "SECURITY" && /* @__PURE__ */ jsx(SecuritySettingsCards, {
				classNames,
				localization
			}),
			view === "TEAMS" && teamsEnabled && showTeams && /* @__PURE__ */ jsx(UserTeamsCard, {
				classNames,
				localization
			}),
			view === "API_KEYS" && /* @__PURE__ */ jsx(ApiKeysCard, {
				classNames: classNames == null ? void 0 : classNames.card,
				localization
			}),
			view === "ORGANIZATIONS" && organization && /* @__PURE__ */ jsxs("div", {
				className: "grid w-full gap-4 md:gap-6",
				children: [/* @__PURE__ */ jsx(OrganizationsCard, {
					classNames: classNames == null ? void 0 : classNames.card,
					localization
				}), /* @__PURE__ */ jsx(UserInvitationsCard, {
					classNames: classNames == null ? void 0 : classNames.card,
					localization
				})]
			})
		]
	});
}
function useOnSuccessTransition({ redirectTo: redirectToProp }) {
	const { redirectTo: contextRedirectTo } = useContext(AuthUIContext);
	const getRedirectTo = useCallback(() => redirectToProp || getSearchParam("redirectTo") || contextRedirectTo, [redirectToProp, contextRedirectTo]);
	const [isPending, setIsPending] = useState(false);
	const { navigate, hooks: { useSession }, onSessionChange } = useContext(AuthUIContext);
	const { refetch: refetchSession } = useSession();
	return {
		onSuccess: useCallback(async () => {
			setIsPending(true);
			await (refetchSession == null ? void 0 : refetchSession());
			if (onSessionChange) await onSessionChange();
			setIsPending(false);
			navigate(getRedirectTo());
		}, [
			refetchSession,
			onSessionChange,
			navigate,
			getRedirectTo
		]),
		isPending
	};
}
function AuthCallback({ redirectTo }) {
	const { hooks: { useIsRestoring }, persistClient } = useContext(AuthUIContext);
	const isRestoring = useIsRestoring == null ? void 0 : useIsRestoring();
	const isRedirecting = useRef(false);
	const { onSuccess } = useOnSuccessTransition({ redirectTo });
	useEffect(() => {
		if (isRedirecting.current) return;
		if (!persistClient) {
			isRedirecting.current = true;
			onSuccess();
			return;
		}
		if (isRestoring) return;
		isRedirecting.current = true;
		onSuccess();
	}, [
		isRestoring,
		persistClient,
		onSuccess
	]);
	return /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" });
}
var DEFAULT_CAPTCHA_ENDPOINTS = [
	"/sign-up/email",
	"/sign-in/email",
	"/forget-password"
];
var sanitizeActionName = (action) => {
	let result = action.startsWith("/") ? action.substring(1) : action;
	result = result.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase()).replace(/\/([a-z])/g, (_, letter) => letter.toUpperCase()).replace(/\//g, "").replace(/[^A-Za-z0-9_]/g, "");
	return result;
};
function useCaptcha({ localization }) {
	const { captcha, localization: contextLocalization } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const captchaRef = useRef(null);
	const { executeRecaptcha } = useGoogleReCaptcha();
	const executeCaptcha = async (action) => {
		if (!captcha) throw new Error(localization.MISSING_RESPONSE);
		let response;
		switch (captcha.provider) {
			case "google-recaptcha-v3": {
				const sanitizedAction = sanitizeActionName(action);
				response = await (executeRecaptcha == null ? void 0 : executeRecaptcha(sanitizedAction));
				break;
			}
			case "google-recaptcha-v2-checkbox":
				response = captchaRef.current.getValue();
				break;
			case "google-recaptcha-v2-invisible":
				response = await captchaRef.current.executeAsync();
				break;
			case "cloudflare-turnstile":
				response = captchaRef.current.getResponse();
				break;
			case "hcaptcha":
				response = captchaRef.current.getResponse();
				break;
			case "captchafox":
				response = captchaRef.current.getResponse();
				break;
		}
		if (!response) throw new Error(localization.MISSING_RESPONSE);
		return response;
	};
	const getCaptchaHeaders = async (action) => {
		if (!captcha) return void 0;
		if ((captcha.endpoints || DEFAULT_CAPTCHA_ENDPOINTS).includes(action)) return { "x-captcha-response": await executeCaptcha(action) };
	};
	const resetCaptcha = () => {
		var _a, _b, _c, _d, _e, _f, _g, _h;
		if (!captcha) return;
		switch (captcha.provider) {
			case "google-recaptcha-v3": break;
			case "google-recaptcha-v2-checkbox":
			case "google-recaptcha-v2-invisible":
				(_b = (_a = captchaRef.current) == null ? void 0 : _a.reset) == null || _b.call(_a);
				break;
			case "cloudflare-turnstile":
				(_d = (_c = captchaRef.current) == null ? void 0 : _c.reset) == null || _d.call(_c);
				break;
			case "hcaptcha":
				(_f = (_e = captchaRef.current) == null ? void 0 : _e.resetCaptcha) == null || _f.call(_e);
				break;
			case "captchafox":
				(_h = (_g = captchaRef.current) == null ? void 0 : _g.reset) == null || _h.call(_g);
				break;
		}
	};
	return {
		captchaRef,
		getCaptchaHeaders,
		resetCaptcha
	};
}
function RecaptchaBadge({ className, localization: propLocalization }) {
	const isHydrated = useIsHydrated();
	const { captcha, localization: contextLocalization } = useContext(AuthUIContext);
	const localization = {
		...contextLocalization,
		...propLocalization
	};
	if (!captcha) return null;
	if (!captcha.hideBadge) return isHydrated ? /* @__PURE__ */ jsx("style", { children: `
                .grecaptcha-badge { visibility: visible !important; }
            ` }) : null;
	return /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx("style", { children: `
                .grecaptcha-badge { visibility: hidden; }
            ` }), /* @__PURE__ */ jsxs("p", {
		className: cn("text-muted-foreground text-xs", className),
		children: [
			localization.PROTECTED_BY_RECAPTCHA,
			" ",
			localization.BY_CONTINUING_YOU_AGREE,
			" Google",
			" ",
			/* @__PURE__ */ jsx("a", {
				className: "text-foreground hover:underline",
				href: "https://policies.google.com/privacy",
				target: "_blank",
				rel: "noreferrer",
				children: localization.PRIVACY_POLICY
			}),
			" ",
			"&",
			" ",
			/* @__PURE__ */ jsx("a", {
				className: "text-foreground hover:underline",
				href: "https://policies.google.com/terms",
				target: "_blank",
				rel: "noreferrer",
				children: localization.TERMS_OF_SERVICE
			}),
			"."
		]
	})] });
}
function RecaptchaV2({ ref }) {
	const { captcha } = useContext(AuthUIContext);
	const { theme } = useTheme$1();
	const { lang } = useLang();
	useEffect(() => {
		window.recaptchaOptions = {
			useRecaptchaNet: captcha == null ? void 0 : captcha.recaptchaNet,
			enterprise: captcha == null ? void 0 : captcha.enterprise
		};
	}, [captcha]);
	if (!captcha) return null;
	return /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx("style", { children: `
                .grecaptcha-badge {
                    border-radius: var(--radius) !important;
                    --tw-shadow: 0 1px 2px 0 var(--tw-shadow-color, #0000000d);
                    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow) !important;
                    border-style: var(--tw-border-style) !important;
                    border-width: 1px;
                }

                .dark .grecaptcha-badge {
                    border-color: var(--input) !important;
                }
            ` }), /* @__PURE__ */ jsx(ReCAPTCHA, {
		ref,
		sitekey: captcha.siteKey,
		theme,
		hl: lang,
		size: captcha.provider === "google-recaptcha-v2-invisible" ? "invisible" : "normal",
		className: cn(captcha.provider === "google-recaptcha-v2-invisible" ? "absolute" : "mx-auto h-[76px] w-[302px] overflow-hidden rounded bg-muted")
	}, `${theme}-${lang}-${captcha.provider}`)] });
}
var DEFAULT_CAPTCHA_ENDPOINTS2 = [
	"/sign-up/email",
	"/sign-in/email",
	"/forget-password"
];
function Captcha({ ref, localization, action }) {
	const { captcha } = useContext(AuthUIContext);
	if (!captcha) return null;
	if (action) {
		if (!(captcha.endpoints || DEFAULT_CAPTCHA_ENDPOINTS2).includes(action)) return null;
	}
	const { theme } = useTheme$1();
	const showRecaptchaV2 = captcha.provider === "google-recaptcha-v2-checkbox" || captcha.provider === "google-recaptcha-v2-invisible";
	const showRecaptchaBadge = captcha.provider === "google-recaptcha-v3" || captcha.provider === "google-recaptcha-v2-invisible";
	const showTurnstile = captcha.provider === "cloudflare-turnstile";
	const showHCaptcha = captcha.provider === "hcaptcha";
	const showCaptchaFox = captcha.provider === "captchafox";
	return /* @__PURE__ */ jsxs(Fragment$1, { children: [
		showRecaptchaV2 && /* @__PURE__ */ jsx(RecaptchaV2, { ref }),
		showRecaptchaBadge && /* @__PURE__ */ jsx(RecaptchaBadge, { localization }),
		showTurnstile && /* @__PURE__ */ jsx(Turnstile, {
			className: "mx-auto",
			ref,
			siteKey: captcha.siteKey,
			options: {
				theme,
				size: "flexible"
			}
		}),
		showHCaptcha && /* @__PURE__ */ jsx("div", {
			className: "mx-auto",
			children: /* @__PURE__ */ jsx(HCaptcha, {
				ref,
				sitekey: captcha.siteKey,
				theme
			})
		}),
		showCaptchaFox && /* @__PURE__ */ jsx("div", {
			className: "mx-auto",
			children: /* @__PURE__ */ jsx(CaptchaFox, {
				ref,
				sitekey: captcha.siteKey,
				theme
			})
		})
	] });
}
function InputOTP({ className, containerClassName, ...props }) {
	return /* @__PURE__ */ jsx(OTPInput, {
		"data-slot": "input-otp",
		containerClassName: cn("flex items-center gap-2 has-disabled:opacity-50", containerClassName),
		className: cn("disabled:cursor-not-allowed", className),
		...props
	});
}
function InputOTPGroup({ className, ...props }) {
	return /* @__PURE__ */ jsx("div", {
		"data-slot": "input-otp-group",
		className: cn("flex items-center", className),
		...props
	});
}
function InputOTPSlot({ index, className, ...props }) {
	const inputOTPContext = React.useContext(OTPInputContext);
	const { char, hasFakeCaret, isActive } = (inputOTPContext == null ? void 0 : inputOTPContext.slots[index]) ?? {};
	return /* @__PURE__ */ jsxs("div", {
		"data-slot": "input-otp-slot",
		"data-active": isActive,
		className: cn("data-[active=true]:border-ring data-[active=true]:ring-ring/50 data-[active=true]:aria-invalid:ring-destructive/20 dark:data-[active=true]:aria-invalid:ring-destructive/40 aria-invalid:border-destructive data-[active=true]:aria-invalid:border-destructive dark:bg-input/30 border-input relative flex h-9 w-9 items-center justify-center border-y border-r text-sm shadow-xs transition-all outline-none first:rounded-l-md first:border-l last:rounded-r-md data-[active=true]:z-10 data-[active=true]:ring-[3px]", className),
		...props,
		children: [char, hasFakeCaret && /* @__PURE__ */ jsx("div", {
			className: "pointer-events-none absolute inset-0 flex items-center justify-center",
			children: /* @__PURE__ */ jsx("div", { className: "animate-caret-blink bg-foreground h-4 w-px duration-1000" })
		})]
	});
}
function InputOTPSeparator({ ...props }) {
	return /* @__PURE__ */ jsx("div", {
		"data-slot": "input-otp-separator",
		role: "separator",
		...props,
		children: /* @__PURE__ */ jsx(MinusIcon, {})
	});
}
function OTPInputGroup({ otpSeparators = 0 }) {
	if (otpSeparators === 0) return /* @__PURE__ */ jsxs(InputOTPGroup, { children: [
		/* @__PURE__ */ jsx(InputOTPSlot, { index: 0 }),
		/* @__PURE__ */ jsx(InputOTPSlot, { index: 1 }),
		/* @__PURE__ */ jsx(InputOTPSlot, { index: 2 }),
		/* @__PURE__ */ jsx(InputOTPSlot, { index: 3 }),
		/* @__PURE__ */ jsx(InputOTPSlot, { index: 4 }),
		/* @__PURE__ */ jsx(InputOTPSlot, { index: 5 })
	] });
	if (otpSeparators === 1) return /* @__PURE__ */ jsxs(Fragment$1, { children: [
		/* @__PURE__ */ jsxs(InputOTPGroup, { children: [
			/* @__PURE__ */ jsx(InputOTPSlot, { index: 0 }),
			/* @__PURE__ */ jsx(InputOTPSlot, { index: 1 }),
			/* @__PURE__ */ jsx(InputOTPSlot, { index: 2 })
		] }),
		/* @__PURE__ */ jsx(InputOTPSeparator, {}),
		/* @__PURE__ */ jsxs(InputOTPGroup, { children: [
			/* @__PURE__ */ jsx(InputOTPSlot, { index: 3 }),
			/* @__PURE__ */ jsx(InputOTPSlot, { index: 4 }),
			/* @__PURE__ */ jsx(InputOTPSlot, { index: 5 })
		] })
	] });
	return /* @__PURE__ */ jsxs(Fragment$1, { children: [
		/* @__PURE__ */ jsxs(InputOTPGroup, { children: [/* @__PURE__ */ jsx(InputOTPSlot, { index: 0 }), /* @__PURE__ */ jsx(InputOTPSlot, { index: 1 })] }),
		/* @__PURE__ */ jsx(InputOTPSeparator, {}),
		/* @__PURE__ */ jsxs(InputOTPGroup, { children: [/* @__PURE__ */ jsx(InputOTPSlot, { index: 2 }), /* @__PURE__ */ jsx(InputOTPSlot, { index: 3 })] }),
		/* @__PURE__ */ jsx(InputOTPSeparator, {}),
		/* @__PURE__ */ jsxs(InputOTPGroup, { children: [/* @__PURE__ */ jsx(InputOTPSlot, { index: 4 }), /* @__PURE__ */ jsx(InputOTPSlot, { index: 5 })] })
	] });
}
function EmailOTPForm(props) {
	const [email, setEmail] = useState();
	if (!email) return /* @__PURE__ */ jsx(EmailForm, {
		...props,
		setEmail
	});
	return /* @__PURE__ */ jsx(OTPForm, {
		...props,
		email
	});
}
function EmailForm({ className, classNames, isSubmitting, localization, setIsSubmitting, setEmail }) {
	const isHydrated = useIsHydrated();
	const { captchaRef, getCaptchaHeaders } = useCaptcha({ localization });
	const { authClient: authClient2, localization: contextLocalization, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const form = useForm({
		resolver: zodResolver(z$1.object({ email: z$1.string().email({ message: `${localization.EMAIL} ${localization.IS_INVALID}` }) })),
		defaultValues: { email: "" }
	});
	isSubmitting = isSubmitting || form.formState.isSubmitting;
	useEffect(() => {
		setIsSubmitting?.(form.formState.isSubmitting);
	}, [form.formState.isSubmitting, setIsSubmitting]);
	async function sendEmailOTP({ email }) {
		const fetchOptions = {
			throw: true,
			headers: await getCaptchaHeaders("/email-otp/send-verification-otp")
		};
		try {
			await authClient2.emailOtp.sendVerificationOtp({
				email,
				type: "sign-in",
				fetchOptions
			});
			toast$1({
				variant: "success",
				message: localization.EMAIL_OTP_VERIFICATION_SENT
			});
			setEmail(email);
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
	}
	return /* @__PURE__ */ jsx(Form, {
		...form,
		children: /* @__PURE__ */ jsxs("form", {
			onSubmit: form.handleSubmit(sendEmailOTP),
			noValidate: isHydrated,
			className: cn("grid w-full gap-6", className, classNames == null ? void 0 : classNames.base),
			children: [
				/* @__PURE__ */ jsx(FormField, {
					control: form.control,
					name: "email",
					render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
						/* @__PURE__ */ jsx(FormLabel, {
							className: classNames == null ? void 0 : classNames.label,
							children: localization.EMAIL
						}),
						/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(Input, {
							className: classNames == null ? void 0 : classNames.input,
							type: "email",
							placeholder: localization.EMAIL_PLACEHOLDER,
							disabled: isSubmitting,
							...field
						}) }),
						/* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })
					] })
				}),
				/* @__PURE__ */ jsx(Captcha, {
					ref: captchaRef,
					localization,
					action: "/email-otp/send-verification-otp"
				}),
				/* @__PURE__ */ jsx(Button, {
					type: "submit",
					disabled: isSubmitting,
					className: cn("w-full", classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.primaryButton),
					children: isSubmitting ? /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }) : localization.EMAIL_OTP_SEND_ACTION
				})
			]
		})
	});
}
function OTPForm({ className, classNames, isSubmitting, localization, otpSeparators = 0, redirectTo, setIsSubmitting, email }) {
	const { authClient: authClient2, localization: contextLocalization, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const { onSuccess, isPending: transitionPending } = useOnSuccessTransition({ redirectTo });
	const form = useForm({
		resolver: zodResolver(z$1.object({ code: z$1.string().min(1, { message: `${localization.EMAIL_OTP} ${localization.IS_REQUIRED}` }).min(6, { message: `${localization.EMAIL_OTP} ${localization.IS_INVALID}` }) })),
		defaultValues: { code: "" }
	});
	isSubmitting = isSubmitting || form.formState.isSubmitting || transitionPending;
	useEffect(() => {
		setIsSubmitting?.(form.formState.isSubmitting || transitionPending);
	}, [
		form.formState.isSubmitting,
		transitionPending,
		setIsSubmitting
	]);
	async function verifyCode({ code }) {
		try {
			await authClient2.signIn.emailOtp({
				email,
				otp: code,
				fetchOptions: { throw: true }
			});
			await onSuccess();
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
			form.reset();
		}
	}
	return /* @__PURE__ */ jsx(Form, {
		...form,
		children: /* @__PURE__ */ jsxs("form", {
			onSubmit: form.handleSubmit(verifyCode),
			className: cn("grid w-full gap-6", className, classNames == null ? void 0 : classNames.base),
			children: [/* @__PURE__ */ jsx(FormField, {
				control: form.control,
				name: "code",
				render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
					/* @__PURE__ */ jsx(FormLabel, {
						className: classNames == null ? void 0 : classNames.label,
						children: localization.EMAIL_OTP
					}),
					/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(InputOTP, {
						...field,
						maxLength: 6,
						onChange: (value) => {
							field.onChange(value);
							if (value.length === 6) form.handleSubmit(verifyCode)();
						},
						containerClassName: classNames == null ? void 0 : classNames.otpInputContainer,
						className: classNames == null ? void 0 : classNames.otpInput,
						disabled: isSubmitting,
						children: /* @__PURE__ */ jsx(OTPInputGroup, { otpSeparators })
					}) }),
					/* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })
				] })
			}), /* @__PURE__ */ jsx("div", {
				className: "grid gap-4",
				children: /* @__PURE__ */ jsxs(Button, {
					type: "submit",
					disabled: isSubmitting,
					className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.primaryButton),
					children: [isSubmitting && /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }), localization.EMAIL_OTP_VERIFY_ACTION]
				})
			})]
		})
	});
}
function ForgotPasswordForm({ className, classNames, isSubmitting, localization, setIsSubmitting }) {
	const isHydrated = useIsHydrated();
	const { captchaRef, getCaptchaHeaders, resetCaptcha } = useCaptcha({ localization });
	const { authClient: authClient2, basePath, baseURL, localization: contextLocalization, navigate, toast: toast$1, viewPaths, localizeErrors } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const form = useForm({
		resolver: zodResolver(z$1.object({ email: z$1.string().email({ message: `${localization.EMAIL} ${localization.IS_INVALID}` }).min(1, { message: `${localization.EMAIL} ${localization.IS_REQUIRED}` }) })),
		defaultValues: { email: "" }
	});
	isSubmitting = isSubmitting || form.formState.isSubmitting;
	useEffect(() => {
		setIsSubmitting?.(form.formState.isSubmitting);
	}, [form.formState.isSubmitting, setIsSubmitting]);
	async function forgotPassword({ email }) {
		try {
			const fetchOptions = {
				throw: true,
				headers: await getCaptchaHeaders("/forget-password")
			};
			await authClient2.requestPasswordReset({
				email,
				redirectTo: `${baseURL}${basePath}/${viewPaths.RESET_PASSWORD}`,
				fetchOptions
			});
			toast$1({
				variant: "success",
				message: localization.FORGOT_PASSWORD_EMAIL
			});
			navigate(`${basePath}/${viewPaths.SIGN_IN}${window.location.search}`);
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
			resetCaptcha();
		}
	}
	return /* @__PURE__ */ jsx(Form, {
		...form,
		children: /* @__PURE__ */ jsxs("form", {
			onSubmit: form.handleSubmit(forgotPassword),
			noValidate: isHydrated,
			className: cn("grid w-full gap-6", className, classNames == null ? void 0 : classNames.base),
			children: [
				/* @__PURE__ */ jsx(FormField, {
					control: form.control,
					name: "email",
					render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
						/* @__PURE__ */ jsx(FormLabel, {
							className: classNames == null ? void 0 : classNames.label,
							children: localization.EMAIL
						}),
						/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(Input, {
							className: classNames == null ? void 0 : classNames.input,
							type: "email",
							placeholder: localization.EMAIL_PLACEHOLDER,
							disabled: isSubmitting,
							...field
						}) }),
						/* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })
					] })
				}),
				/* @__PURE__ */ jsx(Captcha, {
					ref: captchaRef,
					localization,
					action: "/forget-password"
				}),
				/* @__PURE__ */ jsx(Button, {
					type: "submit",
					disabled: isSubmitting,
					className: cn("w-full", classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.primaryButton),
					children: isSubmitting ? /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }) : localization.FORGOT_PASSWORD_ACTION
				})
			]
		})
	});
}
function MagicLinkForm({ className, classNames, callbackURL: callbackURLProp, isSubmitting, localization, redirectTo: redirectToProp, setIsSubmitting }) {
	const isHydrated = useIsHydrated();
	const { captchaRef, getCaptchaHeaders, resetCaptcha } = useCaptcha({ localization });
	const { authClient: authClient2, basePath, baseURL, persistClient, localization: contextLocalization, redirectTo: contextRedirectTo, viewPaths, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const getRedirectTo = useCallback(() => redirectToProp || getSearchParam("redirectTo") || contextRedirectTo, [redirectToProp, contextRedirectTo]);
	const getCallbackURL = useCallback(() => `${baseURL}${callbackURLProp || (persistClient ? `${basePath}/${viewPaths.CALLBACK}?redirectTo=${encodeURIComponent(getRedirectTo())}` : getRedirectTo())}`, [
		callbackURLProp,
		persistClient,
		basePath,
		viewPaths,
		baseURL,
		getRedirectTo
	]);
	const form = useForm({
		resolver: zodResolver(z$1.object({ email: z$1.string().email({ message: `${localization.EMAIL} ${localization.IS_INVALID}` }) })),
		defaultValues: { email: "" }
	});
	isSubmitting = isSubmitting || form.formState.isSubmitting;
	useEffect(() => {
		setIsSubmitting?.(form.formState.isSubmitting);
	}, [form.formState.isSubmitting, setIsSubmitting]);
	async function sendMagicLink({ email }) {
		try {
			const fetchOptions = {
				throw: true,
				headers: await getCaptchaHeaders("/sign-in/magic-link")
			};
			await authClient2.signIn.magicLink({
				email,
				callbackURL: getCallbackURL(),
				fetchOptions
			});
			toast$1({
				variant: "success",
				message: localization.MAGIC_LINK_EMAIL
			});
			form.reset();
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
			resetCaptcha();
		}
	}
	return /* @__PURE__ */ jsx(Form, {
		...form,
		children: /* @__PURE__ */ jsxs("form", {
			onSubmit: form.handleSubmit(sendMagicLink),
			noValidate: isHydrated,
			className: cn("grid w-full gap-6", className, classNames == null ? void 0 : classNames.base),
			children: [
				/* @__PURE__ */ jsx(FormField, {
					control: form.control,
					name: "email",
					render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
						/* @__PURE__ */ jsx(FormLabel, {
							className: classNames == null ? void 0 : classNames.label,
							children: localization.EMAIL
						}),
						/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(Input, {
							className: classNames == null ? void 0 : classNames.input,
							type: "email",
							placeholder: localization.EMAIL_PLACEHOLDER,
							disabled: isSubmitting,
							...field
						}) }),
						/* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })
					] })
				}),
				/* @__PURE__ */ jsx(Captcha, {
					ref: captchaRef,
					localization,
					action: "/sign-in/magic-link"
				}),
				/* @__PURE__ */ jsx(Button, {
					type: "submit",
					disabled: isSubmitting,
					className: cn("w-full", classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.primaryButton),
					children: isSubmitting ? /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }) : localization.MAGIC_LINK_ACTION
				})
			]
		})
	});
}
function RecoverAccountForm({ className, classNames, isSubmitting, localization, redirectTo, setIsSubmitting }) {
	const { authClient: authClient2, localization: contextLocalization, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const { onSuccess, isPending: transitionPending } = useOnSuccessTransition({ redirectTo });
	const form = useForm({
		resolver: zodResolver(z$1.object({ code: z$1.string().min(1, { message: localization.BACKUP_CODE_REQUIRED }) })),
		defaultValues: { code: "" }
	});
	isSubmitting = isSubmitting || form.formState.isSubmitting || transitionPending;
	useEffect(() => {
		setIsSubmitting?.(form.formState.isSubmitting || transitionPending);
	}, [
		form.formState.isSubmitting,
		transitionPending,
		setIsSubmitting
	]);
	async function verifyBackupCode({ code }) {
		try {
			await authClient2.twoFactor.verifyBackupCode({
				code,
				fetchOptions: { throw: true }
			});
			await onSuccess();
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
			form.reset();
		}
	}
	return /* @__PURE__ */ jsx(Form, {
		...form,
		children: /* @__PURE__ */ jsxs("form", {
			onSubmit: form.handleSubmit(verifyBackupCode),
			className: cn("grid gap-6", className, classNames == null ? void 0 : classNames.base),
			children: [/* @__PURE__ */ jsx(FormField, {
				control: form.control,
				name: "code",
				render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
					/* @__PURE__ */ jsx(FormLabel, {
						className: classNames == null ? void 0 : classNames.label,
						children: localization.BACKUP_CODE
					}),
					/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(Input, {
						placeholder: localization.BACKUP_CODE_PLACEHOLDER,
						autoComplete: "off",
						className: classNames == null ? void 0 : classNames.input,
						disabled: isSubmitting,
						...field
					}) }),
					/* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })
				] })
			}), /* @__PURE__ */ jsx(Button, {
				type: "submit",
				disabled: isSubmitting,
				className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.primaryButton),
				children: isSubmitting ? /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }) : localization.RECOVER_ACCOUNT_ACTION
			})]
		})
	});
}
function ResetPasswordForm({ className, classNames, localization, passwordValidation }) {
	const tokenChecked = useRef(false);
	const { authClient: authClient2, basePath, credentials, localization: contextLocalization, viewPaths, navigate, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	const confirmPasswordEnabled = credentials == null ? void 0 : credentials.confirmPassword;
	const contextPasswordValidation = credentials == null ? void 0 : credentials.passwordValidation;
	localization = {
		...contextLocalization,
		...localization
	};
	passwordValidation = {
		...contextPasswordValidation,
		...passwordValidation
	};
	const form = useForm({
		resolver: zodResolver(z$1.object({
			newPassword: getPasswordSchema(passwordValidation, {
				PASSWORD_REQUIRED: localization.NEW_PASSWORD_REQUIRED,
				PASSWORD_TOO_SHORT: localization.PASSWORD_TOO_SHORT,
				PASSWORD_TOO_LONG: localization.PASSWORD_TOO_LONG,
				INVALID_PASSWORD: localization.INVALID_PASSWORD
			}),
			confirmPassword: confirmPasswordEnabled ? getPasswordSchema(passwordValidation, {
				PASSWORD_REQUIRED: localization.CONFIRM_PASSWORD_REQUIRED,
				PASSWORD_TOO_SHORT: localization.PASSWORD_TOO_SHORT,
				PASSWORD_TOO_LONG: localization.PASSWORD_TOO_LONG,
				INVALID_PASSWORD: localization.INVALID_PASSWORD
			}) : z$1.string().optional()
		}).refine((data) => !confirmPasswordEnabled || data.newPassword === data.confirmPassword, {
			message: localization.PASSWORDS_DO_NOT_MATCH,
			path: ["confirmPassword"]
		})),
		defaultValues: {
			newPassword: "",
			confirmPassword: ""
		}
	});
	const isSubmitting = form.formState.isSubmitting;
	useEffect(() => {
		if (tokenChecked.current) return;
		tokenChecked.current = true;
		const token = new URLSearchParams(window.location.search).get("token");
		if (!token || token === "INVALID_TOKEN") {
			navigate(`${basePath}/${viewPaths.SIGN_IN}${window.location.search}`);
			toast$1({
				variant: "error",
				message: localization.INVALID_TOKEN
			});
		}
	}, [
		basePath,
		navigate,
		toast$1,
		viewPaths,
		localization
	]);
	async function resetPassword({ newPassword }) {
		try {
			const token = new URLSearchParams(window.location.search).get("token");
			await authClient2.resetPassword({
				newPassword,
				token,
				fetchOptions: { throw: true }
			});
			toast$1({
				variant: "success",
				message: localization.RESET_PASSWORD_SUCCESS
			});
			navigate(`${basePath}/${viewPaths.SIGN_IN}${window.location.search}`);
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
			form.reset();
		}
	}
	return /* @__PURE__ */ jsx(Form, {
		...form,
		children: /* @__PURE__ */ jsxs("form", {
			onSubmit: form.handleSubmit(resetPassword),
			className: cn("grid w-full gap-6", className, classNames == null ? void 0 : classNames.base),
			children: [
				/* @__PURE__ */ jsx(FormField, {
					control: form.control,
					name: "newPassword",
					render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
						/* @__PURE__ */ jsx(FormLabel, {
							className: classNames == null ? void 0 : classNames.label,
							children: localization.NEW_PASSWORD
						}),
						/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(PasswordInput, {
							autoComplete: "new-password",
							className: classNames == null ? void 0 : classNames.input,
							placeholder: localization.NEW_PASSWORD_PLACEHOLDER,
							disabled: isSubmitting,
							...field
						}) }),
						/* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })
					] })
				}),
				confirmPasswordEnabled && /* @__PURE__ */ jsx(FormField, {
					control: form.control,
					name: "confirmPassword",
					render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
						/* @__PURE__ */ jsx(FormLabel, {
							className: classNames == null ? void 0 : classNames.label,
							children: localization.CONFIRM_PASSWORD
						}),
						/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(PasswordInput, {
							autoComplete: "new-password",
							className: classNames == null ? void 0 : classNames.input,
							placeholder: localization.CONFIRM_PASSWORD_PLACEHOLDER,
							disabled: isSubmitting,
							...field
						}) }),
						/* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })
					] })
				}),
				/* @__PURE__ */ jsx(Button, {
					type: "submit",
					disabled: isSubmitting,
					className: cn("w-full", classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.primaryButton),
					children: isSubmitting ? /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }) : localization.RESET_PASSWORD_ACTION
				})
			]
		})
	});
}
function SignInForm({ className, classNames, isSubmitting, localization, redirectTo, setIsSubmitting, passwordValidation }) {
	const isHydrated = useIsHydrated();
	const { captchaRef, getCaptchaHeaders, resetCaptcha } = useCaptcha({ localization });
	const { authClient: authClient2, basePath, credentials, localization: contextLocalization, viewPaths, navigate, toast: toast$1, Link, localizeErrors } = useContext(AuthUIContext);
	const rememberMeEnabled = credentials == null ? void 0 : credentials.rememberMe;
	const usernameEnabled = credentials == null ? void 0 : credentials.username;
	const contextPasswordValidation = credentials == null ? void 0 : credentials.passwordValidation;
	localization = {
		...contextLocalization,
		...localization
	};
	passwordValidation = {
		...contextPasswordValidation,
		...passwordValidation
	};
	const { onSuccess, isPending: transitionPending } = useOnSuccessTransition({ redirectTo });
	const form = useForm({
		resolver: zodResolver(z$1.object({
			email: usernameEnabled ? z$1.string().min(1, { message: `${localization.USERNAME} ${localization.IS_REQUIRED}` }) : z$1.string().email({ message: `${localization.EMAIL} ${localization.IS_INVALID}` }),
			password: getPasswordSchema(passwordValidation, localization),
			rememberMe: z$1.boolean().optional()
		})),
		defaultValues: {
			email: "",
			password: "",
			rememberMe: !rememberMeEnabled
		}
	});
	isSubmitting = isSubmitting || form.formState.isSubmitting || transitionPending;
	useEffect(() => {
		setIsSubmitting?.(form.formState.isSubmitting || transitionPending);
	}, [
		form.formState.isSubmitting,
		transitionPending,
		setIsSubmitting
	]);
	async function signIn({ email, password, rememberMe }) {
		try {
			let response = {};
			if (usernameEnabled && !isValidEmail(email)) {
				const fetchOptions = {
					throw: true,
					headers: await getCaptchaHeaders("/sign-in/username")
				};
				response = await authClient2.signIn.username({
					username: email,
					password,
					rememberMe,
					fetchOptions
				});
			} else {
				const fetchOptions = {
					throw: true,
					headers: await getCaptchaHeaders("/sign-in/email")
				};
				response = await authClient2.signIn.email({
					email,
					password,
					rememberMe,
					fetchOptions
				});
			}
			if (response.twoFactorRedirect) navigate(`${basePath}/${viewPaths.TWO_FACTOR}${window.location.search}`);
			else await onSuccess();
		} catch (error) {
			form.resetField("password");
			resetCaptcha();
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
	}
	return /* @__PURE__ */ jsx(Form, {
		...form,
		children: /* @__PURE__ */ jsxs("form", {
			onSubmit: form.handleSubmit(signIn),
			noValidate: isHydrated,
			className: cn("grid w-full gap-6", className, classNames == null ? void 0 : classNames.base),
			children: [
				/* @__PURE__ */ jsx(FormField, {
					control: form.control,
					name: "email",
					render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
						/* @__PURE__ */ jsx(FormLabel, {
							className: classNames == null ? void 0 : classNames.label,
							children: usernameEnabled ? localization.USERNAME : localization.EMAIL
						}),
						/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(Input, {
							autoComplete: usernameEnabled ? "username" : "email",
							className: classNames == null ? void 0 : classNames.input,
							type: usernameEnabled ? "text" : "email",
							placeholder: usernameEnabled ? localization.SIGN_IN_USERNAME_PLACEHOLDER : localization.EMAIL_PLACEHOLDER,
							disabled: isSubmitting,
							...field
						}) }),
						/* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })
					] })
				}),
				/* @__PURE__ */ jsx(FormField, {
					control: form.control,
					name: "password",
					render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
						/* @__PURE__ */ jsxs("div", {
							className: "flex items-center justify-between",
							children: [/* @__PURE__ */ jsx(FormLabel, {
								className: classNames == null ? void 0 : classNames.label,
								children: localization.PASSWORD
							}), (credentials == null ? void 0 : credentials.forgotPassword) && /* @__PURE__ */ jsx(Link, {
								className: cn("text-sm hover:underline", classNames == null ? void 0 : classNames.forgotPasswordLink),
								href: `${basePath}/${viewPaths.FORGOT_PASSWORD}${isHydrated ? window.location.search : ""}`,
								children: localization.FORGOT_PASSWORD_LINK
							})]
						}),
						/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(PasswordInput, {
							autoComplete: "current-password",
							className: classNames == null ? void 0 : classNames.input,
							placeholder: localization.PASSWORD_PLACEHOLDER,
							disabled: isSubmitting,
							...field
						}) }),
						/* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })
					] })
				}),
				rememberMeEnabled && /* @__PURE__ */ jsx(FormField, {
					control: form.control,
					name: "rememberMe",
					render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, {
						className: "flex",
						children: [/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(Checkbox, {
							checked: field.value,
							onCheckedChange: field.onChange,
							disabled: isSubmitting
						}) }), /* @__PURE__ */ jsx(FormLabel, { children: localization.REMEMBER_ME })]
					})
				}),
				/* @__PURE__ */ jsx(Captcha, {
					ref: captchaRef,
					localization,
					action: "/sign-in/email"
				}),
				/* @__PURE__ */ jsx(Button, {
					type: "submit",
					disabled: isSubmitting,
					className: cn("w-full", classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.primaryButton),
					children: isSubmitting ? /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }) : localization.SIGN_IN_ACTION
				})
			]
		})
	});
}
function SignUpForm({ className, classNames, callbackURL, isSubmitting, localization, redirectTo, setIsSubmitting, passwordValidation }) {
	const isHydrated = useIsHydrated();
	const { captchaRef, getCaptchaHeaders, resetCaptcha } = useCaptcha({ localization });
	const { additionalFields, authClient: authClient2, basePath, baseURL, credentials, localization: contextLocalization, nameRequired, persistClient, redirectTo: contextRedirectTo, signUp: signUpOptions, viewPaths, navigate, toast: toast$1, avatar, localizeErrors } = useContext(AuthUIContext);
	const confirmPasswordEnabled = credentials == null ? void 0 : credentials.confirmPassword;
	const usernameEnabled = credentials == null ? void 0 : credentials.username;
	const usernameRequired = (credentials == null ? void 0 : credentials.usernameRequired) ?? true;
	const contextPasswordValidation = credentials == null ? void 0 : credentials.passwordValidation;
	const signUpFields = signUpOptions == null ? void 0 : signUpOptions.fields;
	localization = {
		...contextLocalization,
		...localization
	};
	passwordValidation = {
		...contextPasswordValidation,
		...passwordValidation
	};
	const fileInputRef = useRef(null);
	const [avatarImage, setAvatarImage] = useState(null);
	const [uploadingAvatar, setUploadingAvatar] = useState(false);
	const getRedirectTo = useCallback(() => redirectTo || getSearchParam("redirectTo") || contextRedirectTo, [redirectTo, contextRedirectTo]);
	const getCallbackURL = useCallback(() => `${baseURL}${callbackURL || (persistClient ? `${basePath}/${viewPaths.CALLBACK}?redirectTo=${encodeURIComponent(getRedirectTo())}` : getRedirectTo())}`, [
		callbackURL,
		persistClient,
		basePath,
		viewPaths,
		baseURL,
		getRedirectTo
	]);
	const { onSuccess, isPending: transitionPending } = useOnSuccessTransition({ redirectTo });
	const defaultFields = {
		email: z$1.string().email({ message: `${localization.EMAIL} ${localization.IS_INVALID}` }),
		password: getPasswordSchema(passwordValidation, localization),
		name: (signUpFields == null ? void 0 : signUpFields.includes("name")) && nameRequired ? z$1.string().min(1, { message: `${localization.NAME} ${localization.IS_REQUIRED}` }) : z$1.string().optional(),
		image: z$1.string().optional(),
		username: usernameEnabled ? usernameRequired ? z$1.string().min(1, { message: `${localization.USERNAME} ${localization.IS_REQUIRED}` }) : z$1.string().optional() : z$1.string().optional(),
		confirmPassword: confirmPasswordEnabled ? getPasswordSchema(passwordValidation, {
			PASSWORD_REQUIRED: localization.CONFIRM_PASSWORD_REQUIRED,
			PASSWORD_TOO_SHORT: localization.PASSWORD_TOO_SHORT,
			PASSWORD_TOO_LONG: localization.PASSWORD_TOO_LONG,
			INVALID_PASSWORD: localization.INVALID_PASSWORD
		}) : z$1.string().optional()
	};
	const schemaFields = {};
	if (signUpFields) for (const field of signUpFields) {
		if (field === "name") continue;
		if (field === "image") continue;
		const additionalField = additionalFields == null ? void 0 : additionalFields[field];
		if (!additionalField) continue;
		let fieldSchema;
		if (additionalField.type === "number") fieldSchema = additionalField.required ? z$1.preprocess((val) => !val ? void 0 : Number(val), z$1.number({ message: `${additionalField.label} ${localization.IS_INVALID}` })) : z$1.coerce.number({ message: `${additionalField.label} ${localization.IS_INVALID}` }).optional();
		else if (additionalField.type === "boolean") fieldSchema = additionalField.required ? z$1.coerce.boolean({ message: `${additionalField.label} ${localization.IS_INVALID}` }).refine((val) => val === true, { message: `${additionalField.label} ${localization.IS_REQUIRED}` }) : z$1.coerce.boolean({ message: `${additionalField.label} ${localization.IS_INVALID}` }).optional();
		else fieldSchema = additionalField.required ? z$1.string().min(1, `${additionalField.label} ${localization.IS_REQUIRED}`) : z$1.string().optional();
		schemaFields[field] = fieldSchema;
	}
	const formSchema = z$1.object(defaultFields).extend(schemaFields).refine((data) => {
		if (!confirmPasswordEnabled) return true;
		return data.password === data.confirmPassword;
	}, {
		message: localization.PASSWORDS_DO_NOT_MATCH,
		path: ["confirmPassword"]
	});
	const defaultValues = {
		email: "",
		password: "",
		...confirmPasswordEnabled && { confirmPassword: "" },
		...(signUpFields == null ? void 0 : signUpFields.includes("name")) ? { name: "" } : {},
		...usernameEnabled ? { username: "" } : {},
		...(signUpFields == null ? void 0 : signUpFields.includes("image")) && avatar ? { image: "" } : {}
	};
	if (signUpFields) for (const field of signUpFields) {
		if (field === "name") continue;
		if (field === "image") continue;
		const additionalField = additionalFields == null ? void 0 : additionalFields[field];
		if (!additionalField) continue;
		defaultValues[field] = additionalField.type === "boolean" ? false : "";
	}
	const form = useForm({
		resolver: zodResolver(formSchema),
		defaultValues
	});
	isSubmitting = isSubmitting || form.formState.isSubmitting || transitionPending;
	useEffect(() => {
		setIsSubmitting?.(form.formState.isSubmitting || transitionPending);
	}, [
		form.formState.isSubmitting,
		transitionPending,
		setIsSubmitting
	]);
	const handleAvatarChange = async (file) => {
		if (!avatar) return;
		setUploadingAvatar(true);
		try {
			const resizedFile = await resizeAndCropImage(file, crypto.randomUUID(), avatar.size, avatar.extension);
			let image;
			if (avatar.upload) image = await avatar.upload(resizedFile);
			else image = await fileToBase64(resizedFile);
			if (image) {
				setAvatarImage(image);
				form.setValue("image", image);
			} else {
				setAvatarImage(null);
				form.setValue("image", "");
			}
		} catch (error) {
			console.error(error);
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
		setUploadingAvatar(false);
	};
	const handleDeleteAvatar = () => {
		setAvatarImage(null);
		form.setValue("image", "");
	};
	const openFileDialog = () => {
		var _a;
		return (_a = fileInputRef.current) == null ? void 0 : _a.click();
	};
	async function signUp({ email, password, name, username, confirmPassword, image, ...additionalFieldValues }) {
		try {
			for (const [field, value] of Object.entries(additionalFieldValues)) {
				const additionalField = additionalFields == null ? void 0 : additionalFields[field];
				if (!(additionalField == null ? void 0 : additionalField.validate)) continue;
				if (typeof value === "string" && !await additionalField.validate(value)) {
					form.setError(field, { message: `${additionalField.label} ${localization.IS_INVALID}` });
					return;
				}
			}
			const fetchOptions = {
				throw: true,
				headers: await getCaptchaHeaders("/sign-up/email")
			};
			const additionalParams = {};
			if (username !== void 0) if (!usernameRequired && (username === null || username === "" || typeof username === "string" && username.trim() === "")) {} else additionalParams.username = username;
			if (image !== void 0) additionalParams.image = image;
			const data = await authClient2.signUp.email({
				email,
				password,
				name: name || "",
				...additionalParams,
				...additionalFieldValues,
				callbackURL: getCallbackURL(),
				fetchOptions
			});
			if ("token" in data && data.token) await onSuccess();
			else {
				navigate(`${basePath}/${viewPaths.SIGN_IN}${window.location.search}`);
				toast$1({
					variant: "success",
					message: localization.SIGN_UP_EMAIL
				});
			}
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
			form.resetField("password");
			form.resetField("confirmPassword");
			resetCaptcha();
		}
	}
	return /* @__PURE__ */ jsx(Form, {
		...form,
		children: /* @__PURE__ */ jsxs("form", {
			onSubmit: form.handleSubmit(signUp),
			noValidate: isHydrated,
			className: cn("grid w-full gap-6", className, classNames == null ? void 0 : classNames.base),
			children: [
				(signUpFields == null ? void 0 : signUpFields.includes("image")) && avatar && /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx("input", {
					ref: fileInputRef,
					accept: "image/*",
					disabled: uploadingAvatar,
					hidden: true,
					type: "file",
					onChange: (e) => {
						var _a;
						const file = (_a = e.target.files) == null ? void 0 : _a.item(0);
						if (file) handleAvatarChange(file);
						e.target.value = "";
					}
				}), /* @__PURE__ */ jsx(FormField, {
					control: form.control,
					name: "image",
					render: () => /* @__PURE__ */ jsxs(FormItem, { children: [
						/* @__PURE__ */ jsx(FormLabel, { children: localization.AVATAR }),
						/* @__PURE__ */ jsxs("div", {
							className: "flex items-center gap-4",
							children: [/* @__PURE__ */ jsxs(DropdownMenu, { children: [/* @__PURE__ */ jsx(DropdownMenuTrigger, {
								asChild: true,
								children: /* @__PURE__ */ jsx(Button, {
									className: "size-fit rounded-full",
									size: "icon",
									variant: "ghost",
									type: "button",
									children: /* @__PURE__ */ jsx(UserAvatar, {
										isPending: uploadingAvatar,
										className: "size-16",
										user: avatarImage ? {
											name: form.watch("name"),
											email: form.watch("email"),
											image: avatarImage
										} : null,
										localization
									})
								})
							}), /* @__PURE__ */ jsxs(DropdownMenuContent, {
								align: "start",
								onCloseAutoFocus: (e) => e.preventDefault(),
								children: [/* @__PURE__ */ jsxs(DropdownMenuItem, {
									onClick: openFileDialog,
									disabled: uploadingAvatar,
									children: [/* @__PURE__ */ jsx(UploadCloudIcon, {}), localization.UPLOAD_AVATAR]
								}), avatarImage && /* @__PURE__ */ jsxs(DropdownMenuItem, {
									onClick: handleDeleteAvatar,
									disabled: uploadingAvatar,
									variant: "destructive",
									children: [/* @__PURE__ */ jsx(Trash2Icon, {}), localization.DELETE_AVATAR]
								})]
							})] }), /* @__PURE__ */ jsxs(Button, {
								type: "button",
								variant: "outline",
								onClick: openFileDialog,
								disabled: uploadingAvatar,
								children: [uploadingAvatar && /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }), localization.UPLOAD]
							})]
						}),
						/* @__PURE__ */ jsx(FormMessage, {})
					] })
				})] }),
				(signUpFields == null ? void 0 : signUpFields.includes("name")) && /* @__PURE__ */ jsx(FormField, {
					control: form.control,
					name: "name",
					render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
						/* @__PURE__ */ jsxs(FormLabel, {
							className: classNames == null ? void 0 : classNames.label,
							children: [localization.NAME, !nameRequired && /* @__PURE__ */ jsx("span", {
								className: "ml-1 text-muted-foreground",
								children: localization.OPTIONAL_BRACKETS
							})]
						}),
						/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(Input, {
							autoComplete: "name",
							className: classNames == null ? void 0 : classNames.input,
							placeholder: localization.NAME_PLACEHOLDER,
							disabled: isSubmitting,
							...field,
							value: field.value
						}) }),
						/* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })
					] })
				}),
				usernameEnabled && /* @__PURE__ */ jsx(FormField, {
					control: form.control,
					name: "username",
					render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
						/* @__PURE__ */ jsxs(FormLabel, {
							className: classNames == null ? void 0 : classNames.label,
							children: [localization.USERNAME, !usernameRequired && /* @__PURE__ */ jsx("span", {
								className: "ml-1 text-muted-foreground",
								children: localization.OPTIONAL_BRACKETS
							})]
						}),
						/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(Input, {
							autoComplete: "username",
							className: classNames == null ? void 0 : classNames.input,
							placeholder: localization.USERNAME_PLACEHOLDER,
							disabled: isSubmitting,
							...field,
							value: field.value
						}) }),
						/* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })
					] })
				}),
				/* @__PURE__ */ jsx(FormField, {
					control: form.control,
					name: "email",
					render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
						/* @__PURE__ */ jsx(FormLabel, {
							className: classNames == null ? void 0 : classNames.label,
							children: localization.EMAIL
						}),
						/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(Input, {
							autoComplete: "email",
							className: classNames == null ? void 0 : classNames.input,
							type: "email",
							placeholder: localization.EMAIL_PLACEHOLDER,
							disabled: isSubmitting,
							...field,
							value: field.value
						}) }),
						/* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })
					] })
				}),
				/* @__PURE__ */ jsx(FormField, {
					control: form.control,
					name: "password",
					render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
						/* @__PURE__ */ jsx(FormLabel, {
							className: classNames == null ? void 0 : classNames.label,
							children: localization.PASSWORD
						}),
						/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(PasswordInput, {
							autoComplete: "new-password",
							className: classNames == null ? void 0 : classNames.input,
							placeholder: localization.PASSWORD_PLACEHOLDER,
							disabled: isSubmitting,
							enableToggle: true,
							...field,
							value: field.value
						}) }),
						/* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })
					] })
				}),
				confirmPasswordEnabled && /* @__PURE__ */ jsx(FormField, {
					control: form.control,
					name: "confirmPassword",
					render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
						/* @__PURE__ */ jsx(FormLabel, {
							className: classNames == null ? void 0 : classNames.label,
							children: localization.CONFIRM_PASSWORD
						}),
						/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(PasswordInput, {
							autoComplete: "new-password",
							className: classNames == null ? void 0 : classNames.input,
							placeholder: localization.CONFIRM_PASSWORD_PLACEHOLDER,
							disabled: isSubmitting,
							enableToggle: true,
							...field,
							value: field.value
						}) }),
						/* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })
					] })
				}),
				signUpFields == null ? void 0 : signUpFields.filter((field) => field !== "name" && field !== "image").map((field) => {
					const additionalField = additionalFields == null ? void 0 : additionalFields[field];
					if (!additionalField) {
						console.error(`Additional field ${field} not found`);
						return null;
					}
					return additionalField.type === "boolean" ? /* @__PURE__ */ jsx(FormField, {
						control: form.control,
						name: field,
						render: ({ field: formField }) => /* @__PURE__ */ jsxs(FormItem, {
							className: "flex",
							children: [
								/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(Checkbox, {
									checked: formField.value,
									onCheckedChange: formField.onChange,
									disabled: isSubmitting
								}) }),
								/* @__PURE__ */ jsx(FormLabel, {
									className: classNames == null ? void 0 : classNames.label,
									children: additionalField.label
								}),
								/* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })
							]
						})
					}, field) : /* @__PURE__ */ jsx(FormField, {
						control: form.control,
						name: field,
						render: ({ field: formField }) => /* @__PURE__ */ jsxs(FormItem, { children: [
							/* @__PURE__ */ jsx(FormLabel, {
								className: classNames == null ? void 0 : classNames.label,
								children: additionalField.label
							}),
							/* @__PURE__ */ jsx(FormControl, { children: additionalField.type === "number" ? /* @__PURE__ */ jsx(Input, {
								className: classNames == null ? void 0 : classNames.input,
								type: "number",
								placeholder: additionalField.placeholder || (typeof additionalField.label === "string" ? additionalField.label : ""),
								disabled: isSubmitting,
								...formField,
								value: formField.value
							}) : additionalField.multiline ? /* @__PURE__ */ jsx(Textarea, {
								className: classNames == null ? void 0 : classNames.input,
								placeholder: additionalField.placeholder || (typeof additionalField.label === "string" ? additionalField.label : ""),
								disabled: isSubmitting,
								...formField,
								value: formField.value
							}) : /* @__PURE__ */ jsx(Input, {
								className: classNames == null ? void 0 : classNames.input,
								type: "text",
								placeholder: additionalField.placeholder || (typeof additionalField.label === "string" ? additionalField.label : ""),
								disabled: isSubmitting,
								...formField,
								value: formField.value
							}) }),
							/* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })
						] })
					}, field);
				}),
				/* @__PURE__ */ jsx(Captcha, {
					ref: captchaRef,
					localization,
					action: "/sign-up/email"
				}),
				/* @__PURE__ */ jsx(Button, {
					type: "submit",
					disabled: isSubmitting,
					className: cn("w-full", classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.primaryButton),
					children: isSubmitting ? /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }) : localization.SIGN_UP_ACTION
				})
			]
		})
	});
}
function TwoFactorForm({ className, classNames, isSubmitting, localization, otpSeparators = 0, redirectTo, setIsSubmitting }) {
	var _a;
	const isHydrated = useIsHydrated();
	const totpURI = isHydrated ? getSearchParam("totpURI") : null;
	const initialSendRef = useRef(false);
	const { authClient: authClient2, basePath, hooks: { useSession }, localization: contextLocalization, twoFactor, viewPaths, toast: toast$1, Link, localizeErrors } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const { onSuccess, isPending: transitionPending } = useOnSuccessTransition({ redirectTo });
	const { data: sessionData } = useSession();
	const isTwoFactorEnabled = (_a = sessionData == null ? void 0 : sessionData.user) == null ? void 0 : _a.twoFactorEnabled;
	const [method, setMethod] = useState((twoFactor == null ? void 0 : twoFactor.length) === 1 ? twoFactor[0] : null);
	const [isSendingOtp, setIsSendingOtp] = useState(false);
	const [cooldownSeconds, setCooldownSeconds] = useState(0);
	const form = useForm({
		resolver: zodResolver(z$1.object({
			code: z$1.string().min(1, { message: `${localization.ONE_TIME_PASSWORD} ${localization.IS_REQUIRED}` }).min(6, { message: `${localization.ONE_TIME_PASSWORD} ${localization.IS_INVALID}` }),
			trustDevice: z$1.boolean().optional()
		})),
		defaultValues: { code: "" }
	});
	isSubmitting = isSubmitting || form.formState.isSubmitting || transitionPending;
	useEffect(() => {
		setIsSubmitting?.(form.formState.isSubmitting || transitionPending);
	}, [
		form.formState.isSubmitting,
		transitionPending,
		setIsSubmitting
	]);
	useEffect(() => {
		if (method === "otp" && cooldownSeconds <= 0 && !initialSendRef.current) {
			initialSendRef.current = true;
			sendOtp();
		}
	}, [method]);
	useEffect(() => {
		if (cooldownSeconds <= 0) return;
		const timer = setTimeout(() => {
			setCooldownSeconds((prev) => prev - 1);
		}, 1e3);
		return () => clearTimeout(timer);
	}, [cooldownSeconds]);
	const sendOtp = async () => {
		if (isSendingOtp || cooldownSeconds > 0) return;
		try {
			setIsSendingOtp(true);
			await authClient2.twoFactor.sendOtp({ fetchOptions: { throw: true } });
			setCooldownSeconds(60);
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
			if (error.error.code === "INVALID_TWO_FACTOR_COOKIE") history.back();
		}
		initialSendRef.current = false;
		setIsSendingOtp(false);
	};
	async function verifyCode({ code, trustDevice }) {
		try {
			await (method === "totp" ? authClient2.twoFactor.verifyTotp : authClient2.twoFactor.verifyOtp)({
				code,
				trustDevice,
				fetchOptions: { throw: true }
			});
			await onSuccess();
			if (sessionData && !isTwoFactorEnabled) toast$1({
				variant: "success",
				message: localization == null ? void 0 : localization.TWO_FACTOR_ENABLED
			});
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
			form.reset();
		}
	}
	return /* @__PURE__ */ jsx(Form, {
		...form,
		children: /* @__PURE__ */ jsxs("form", {
			onSubmit: form.handleSubmit(verifyCode),
			className: cn("grid w-full gap-6", className, classNames == null ? void 0 : classNames.base),
			children: [
				(twoFactor == null ? void 0 : twoFactor.includes("totp")) && totpURI && method === "totp" && /* @__PURE__ */ jsxs("div", {
					className: "space-y-3",
					children: [/* @__PURE__ */ jsx(Label2, {
						className: classNames == null ? void 0 : classNames.label,
						children: localization.TWO_FACTOR_TOTP_LABEL
					}), /* @__PURE__ */ jsx(QRCode, {
						className: cn("border shadow-xs", classNames == null ? void 0 : classNames.qrCode),
						value: totpURI
					})]
				}),
				method !== null && /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(FormField, {
					control: form.control,
					name: "code",
					render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
						/* @__PURE__ */ jsxs("div", {
							className: "flex items-center justify-between",
							children: [/* @__PURE__ */ jsx(FormLabel, {
								className: classNames == null ? void 0 : classNames.label,
								children: localization.ONE_TIME_PASSWORD
							}), /* @__PURE__ */ jsx(Link, {
								className: cn("text-sm hover:underline", classNames == null ? void 0 : classNames.forgotPasswordLink),
								href: `${basePath}/${viewPaths.RECOVER_ACCOUNT}${isHydrated ? window.location.search : ""}`,
								children: localization.FORGOT_AUTHENTICATOR
							})]
						}),
						/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(InputOTP, {
							...field,
							maxLength: 6,
							onChange: (value) => {
								field.onChange(value);
								if (value.length === 6) form.handleSubmit(verifyCode)();
							},
							containerClassName: classNames == null ? void 0 : classNames.otpInputContainer,
							className: classNames == null ? void 0 : classNames.otpInput,
							disabled: isSubmitting,
							children: /* @__PURE__ */ jsx(OTPInputGroup, { otpSeparators })
						}) }),
						/* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })
					] })
				}), /* @__PURE__ */ jsx(FormField, {
					control: form.control,
					name: "trustDevice",
					render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, {
						className: "flex",
						children: [/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(Checkbox, {
							checked: field.value,
							onCheckedChange: field.onChange,
							disabled: isSubmitting,
							className: classNames == null ? void 0 : classNames.checkbox
						}) }), /* @__PURE__ */ jsx(FormLabel, {
							className: classNames == null ? void 0 : classNames.label,
							children: localization.TRUST_DEVICE
						})]
					})
				})] }),
				/* @__PURE__ */ jsxs("div", {
					className: "grid gap-4",
					children: [
						method !== null && /* @__PURE__ */ jsxs(Button, {
							type: "submit",
							disabled: isSubmitting,
							className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.primaryButton),
							children: [isSubmitting && /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }), localization.TWO_FACTOR_ACTION]
						}),
						method === "otp" && (twoFactor == null ? void 0 : twoFactor.includes("otp")) && /* @__PURE__ */ jsxs(Button, {
							type: "button",
							variant: "outline",
							onClick: sendOtp,
							disabled: cooldownSeconds > 0 || isSendingOtp || isSubmitting,
							className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.outlineButton),
							children: [
								isSendingOtp ? /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }) : /* @__PURE__ */ jsx(SendIcon, { className: classNames == null ? void 0 : classNames.icon }),
								localization.RESEND_CODE,
								cooldownSeconds > 0 && ` (${cooldownSeconds})`
							]
						}),
						method !== "otp" && (twoFactor == null ? void 0 : twoFactor.includes("otp")) && /* @__PURE__ */ jsxs(Button, {
							type: "button",
							variant: "secondary",
							className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.secondaryButton),
							onClick: () => setMethod("otp"),
							disabled: isSubmitting,
							children: [/* @__PURE__ */ jsx(SendIcon, { className: classNames == null ? void 0 : classNames.icon }), localization.SEND_VERIFICATION_CODE]
						}),
						method !== "totp" && (twoFactor == null ? void 0 : twoFactor.includes("totp")) && /* @__PURE__ */ jsxs(Button, {
							type: "button",
							variant: "secondary",
							className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.secondaryButton),
							onClick: () => setMethod("totp"),
							disabled: isSubmitting,
							children: [/* @__PURE__ */ jsx(QrCodeIcon, { className: classNames == null ? void 0 : classNames.icon }), localization.CONTINUE_WITH_AUTHENTICATOR]
						})
					]
				})
			]
		})
	});
}
function SignOut({ redirectTo }) {
	const signingOut = useRef(false);
	const { authClient: authClient2, basePath, viewPaths } = useContext(AuthUIContext);
	const { onSuccess } = useOnSuccessTransition({ redirectTo: redirectTo || `${basePath}/${viewPaths.SIGN_IN}` });
	useEffect(() => {
		if (signingOut.current) return;
		signingOut.current = true;
		authClient2.signOut().finally(onSuccess);
	}, [authClient2, onSuccess]);
	return /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" });
}
function AuthForm({ className, classNames, callbackURL, isSubmitting, localization, pathname, redirectTo, view, otpSeparators = 0, setIsSubmitting }) {
	const { basePath, credentials, localization: contextLocalization, magicLink, emailOTP, signUp, twoFactor: twoFactorEnabled, viewPaths, replace } = useContext(AuthUIContext);
	const signUpEnabled = !!signUp;
	localization = {
		...contextLocalization,
		...localization
	};
	useEffect(() => {
		if (pathname && !getViewByPath(viewPaths, pathname)) {
			console.error(`Invalid auth view: ${pathname}`);
			replace(`${basePath}/${viewPaths.SIGN_IN}${window.location.search}`);
		}
	}, [
		pathname,
		viewPaths,
		basePath,
		replace
	]);
	view = view || getViewByPath(viewPaths, pathname) || "SIGN_IN";
	useEffect(() => {
		let isInvalidView = false;
		if (view === "MAGIC_LINK" && (!magicLink || !credentials && !emailOTP)) isInvalidView = true;
		if (view === "EMAIL_OTP" && (!emailOTP || !credentials && !magicLink)) isInvalidView = true;
		if (view === "SIGN_UP" && !signUpEnabled) isInvalidView = true;
		if (!credentials && [
			"SIGN_UP",
			"FORGOT_PASSWORD",
			"RESET_PASSWORD",
			"TWO_FACTOR",
			"RECOVER_ACCOUNT"
		].includes(view)) isInvalidView = true;
		if (["TWO_FACTOR", "RECOVER_ACCOUNT"].includes(view) && !twoFactorEnabled) isInvalidView = true;
		if (isInvalidView) replace(`${basePath}/${viewPaths.SIGN_IN}${window.location.search}`);
	}, [
		basePath,
		view,
		viewPaths,
		credentials,
		replace,
		emailOTP,
		signUpEnabled,
		magicLink,
		twoFactorEnabled
	]);
	if (view === "SIGN_OUT") return /* @__PURE__ */ jsx(SignOut, { redirectTo });
	if (view === "CALLBACK") return /* @__PURE__ */ jsx(AuthCallback, { redirectTo });
	if (view === "SIGN_IN") return credentials ? /* @__PURE__ */ jsx(SignInForm, {
		className,
		classNames,
		localization,
		redirectTo,
		isSubmitting,
		setIsSubmitting
	}) : magicLink ? /* @__PURE__ */ jsx(MagicLinkForm, {
		className,
		classNames,
		callbackURL,
		localization,
		redirectTo,
		isSubmitting,
		setIsSubmitting
	}) : emailOTP ? /* @__PURE__ */ jsx(EmailOTPForm, {
		className,
		classNames,
		callbackURL,
		localization,
		redirectTo,
		isSubmitting,
		setIsSubmitting
	}) : null;
	if (view === "TWO_FACTOR") return /* @__PURE__ */ jsx(TwoFactorForm, {
		className,
		classNames,
		localization,
		otpSeparators,
		redirectTo,
		isSubmitting,
		setIsSubmitting
	});
	if (view === "RECOVER_ACCOUNT") return /* @__PURE__ */ jsx(RecoverAccountForm, {
		className,
		classNames,
		localization,
		redirectTo,
		isSubmitting,
		setIsSubmitting
	});
	if (view === "MAGIC_LINK") return /* @__PURE__ */ jsx(MagicLinkForm, {
		className,
		classNames,
		callbackURL,
		localization,
		redirectTo,
		isSubmitting,
		setIsSubmitting
	});
	if (view === "EMAIL_OTP") return /* @__PURE__ */ jsx(EmailOTPForm, {
		className,
		classNames,
		callbackURL,
		localization,
		redirectTo,
		isSubmitting,
		setIsSubmitting
	});
	if (view === "FORGOT_PASSWORD") return /* @__PURE__ */ jsx(ForgotPasswordForm, {
		className,
		classNames,
		localization,
		isSubmitting,
		setIsSubmitting
	});
	if (view === "RESET_PASSWORD") return /* @__PURE__ */ jsx(ResetPasswordForm, {
		className,
		classNames,
		localization
	});
	if (view === "SIGN_UP") return signUpEnabled && /* @__PURE__ */ jsx(SignUpForm, {
		className,
		classNames,
		callbackURL,
		localization,
		redirectTo,
		isSubmitting,
		setIsSubmitting
	});
}
function AcceptInvitationCard({ className, classNames, localization: localizationProp }) {
	const { localization: contextLocalization, redirectTo, replace, toast: toast$1 } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const { data: sessionData } = useAuthenticate();
	const [invitationId, setInvitationId] = useState(null);
	useEffect(() => {
		const invitationIdParam = getSearchParam("invitationId");
		if (!invitationIdParam) {
			toast$1({
				variant: "error",
				message: localization.INVITATION_NOT_FOUND
			});
			replace(redirectTo);
			return;
		}
		setInvitationId(invitationIdParam);
	}, [
		localization.INVITATION_NOT_FOUND,
		toast$1,
		replace,
		redirectTo
	]);
	if (!sessionData || !invitationId) return /* @__PURE__ */ jsx(AcceptInvitationSkeleton, {
		className,
		classNames
	});
	return /* @__PURE__ */ jsx(AcceptInvitationContent, {
		className,
		classNames,
		localization,
		invitationId
	});
}
function AcceptInvitationContent({ className, classNames, localization: localizationProp, invitationId }) {
	var _a;
	const { authClient: authClient2, hooks: { useInvitation }, localization: contextLocalization, organization, redirectTo, replace, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const [isRejecting, setIsRejecting] = useState(false);
	const [isAccepting, setIsAccepting] = useState(false);
	const isProcessing = isRejecting || isAccepting;
	const { data: invitation, isPending } = useInvitation({ query: { id: invitationId } });
	const getRedirectTo = useCallback(() => getSearchParam("redirectTo") || redirectTo, [redirectTo]);
	useEffect(() => {
		if (isPending || !invitationId) return;
		if (!invitation) {
			toast$1({
				variant: "error",
				message: localization.INVITATION_NOT_FOUND
			});
			replace(redirectTo);
			return;
		}
		if (invitation.status !== "pending" || new Date(invitation.expiresAt) < /* @__PURE__ */ new Date()) {
			toast$1({
				variant: "error",
				message: new Date(invitation.expiresAt) < /* @__PURE__ */ new Date() ? localization.INVITATION_EXPIRED : localization.INVITATION_NOT_FOUND
			});
			replace(redirectTo);
		}
	}, [
		invitation,
		isPending,
		invitationId,
		localization,
		toast$1,
		replace,
		redirectTo
	]);
	const acceptInvitation = async () => {
		setIsAccepting(true);
		try {
			await authClient2.organization.acceptInvitation({
				invitationId,
				fetchOptions: { throw: true }
			});
			toast$1({
				variant: "success",
				message: localization.INVITATION_ACCEPTED || "Invitation accepted"
			});
			replace(getRedirectTo());
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
			setIsAccepting(false);
		}
	};
	const rejectInvitation = async () => {
		setIsRejecting(true);
		try {
			await authClient2.organization.rejectInvitation({
				invitationId,
				fetchOptions: { throw: true }
			});
			toast$1({
				variant: "success",
				message: localization.INVITATION_REJECTED
			});
			replace(redirectTo);
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
			setIsRejecting(false);
		}
	};
	const roleLabel = ((_a = [...[
		{
			role: "owner",
			label: localization.OWNER
		},
		{
			role: "admin",
			label: localization.ADMIN
		},
		{
			role: "member",
			label: localization.MEMBER
		}
	], ...(organization == null ? void 0 : organization.customRoles) || []].find((r) => r.role === (invitation == null ? void 0 : invitation.role))) == null ? void 0 : _a.label) || (invitation == null ? void 0 : invitation.role);
	if (!invitation) return /* @__PURE__ */ jsx(AcceptInvitationSkeleton, {
		className,
		classNames
	});
	return /* @__PURE__ */ jsxs(Card, {
		className: cn("w-full max-w-sm", className, classNames == null ? void 0 : classNames.base),
		children: [/* @__PURE__ */ jsxs(CardHeader, {
			className: cn("justify-items-center text-center", classNames == null ? void 0 : classNames.header),
			children: [/* @__PURE__ */ jsx(CardTitle, {
				className: cn("text-lg md:text-xl", classNames == null ? void 0 : classNames.title),
				children: localization.ACCEPT_INVITATION
			}), /* @__PURE__ */ jsx(CardDescription, {
				className: cn("text-xs md:text-sm", classNames == null ? void 0 : classNames.description),
				children: localization.ACCEPT_INVITATION_DESCRIPTION
			})]
		}), /* @__PURE__ */ jsxs(CardContent, {
			className: cn("flex flex-col gap-6 truncate", classNames == null ? void 0 : classNames.content),
			children: [/* @__PURE__ */ jsxs(Card, {
				className: cn("flex-row items-center p-4"),
				children: [/* @__PURE__ */ jsx(OrganizationCellView, {
					organization: {
						id: invitation.organizationId,
						name: invitation.organizationName,
						slug: invitation.organizationSlug,
						logo: invitation.organizationLogo,
						createdAt: /* @__PURE__ */ new Date()
					},
					localization
				}), /* @__PURE__ */ jsx("p", {
					className: "ml-auto text-muted-foreground text-sm",
					children: roleLabel
				})]
			}), /* @__PURE__ */ jsxs("div", {
				className: "grid grid-cols-2 gap-3",
				children: [/* @__PURE__ */ jsxs(Button, {
					variant: "outline",
					className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.outlineButton),
					onClick: rejectInvitation,
					disabled: isProcessing,
					children: [isRejecting ? /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }) : /* @__PURE__ */ jsx(XIcon, {}), localization.REJECT]
				}), /* @__PURE__ */ jsxs(Button, {
					className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.primaryButton),
					onClick: acceptInvitation,
					disabled: isProcessing,
					children: [isAccepting ? /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }) : /* @__PURE__ */ jsx(CheckIcon, {}), localization.ACCEPT]
				})]
			})]
		})]
	});
}
var AcceptInvitationSkeleton = ({ className, classNames, localization }) => {
	return /* @__PURE__ */ jsxs(Card, {
		className: cn("w-full max-w-sm", className, classNames == null ? void 0 : classNames.base),
		children: [/* @__PURE__ */ jsxs(CardHeader, {
			className: cn("justify-items-center", classNames == null ? void 0 : classNames.header),
			children: [/* @__PURE__ */ jsx(Skeleton, { className: cn("my-1 h-5 w-full max-w-32 md:h-5.5 md:w-40", classNames == null ? void 0 : classNames.skeleton) }), /* @__PURE__ */ jsx(Skeleton, { className: cn("my-0.5 h-3 w-full max-w-56 md:h-3.5 md:w-64", classNames == null ? void 0 : classNames.skeleton) })]
		}), /* @__PURE__ */ jsxs(CardContent, {
			className: cn("flex flex-col gap-6 truncate", classNames == null ? void 0 : classNames.content),
			children: [/* @__PURE__ */ jsxs(Card, {
				className: cn("flex-row items-center p-4"),
				children: [/* @__PURE__ */ jsx(OrganizationCellView, {
					isPending: true,
					localization
				}), /* @__PURE__ */ jsx(Skeleton, { className: "mt-0.5 ml-auto h-4 w-full max-w-14 shrink-2" })]
			}), /* @__PURE__ */ jsxs("div", {
				className: "grid grid-cols-2 gap-3",
				children: [/* @__PURE__ */ jsx(Skeleton, { className: "h-9 w-full" }), /* @__PURE__ */ jsx(Skeleton, { className: "h-9 w-full" })]
			})]
		})]
	});
};
function Separator3({ className, orientation = "horizontal", decorative = true, ...props }) {
	return /* @__PURE__ */ jsx(SeparatorPrimitive.Root, {
		"data-slot": "separator",
		decorative,
		orientation,
		className: cn("bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px", className),
		...props
	});
}
function EmailOTPButton({ classNames, isSubmitting, localization, view }) {
	var _a, _b, _c, _d;
	const { viewPaths, navigate, basePath } = useContext(AuthUIContext);
	return /* @__PURE__ */ jsxs(Button, {
		className: cn("w-full", (_a = classNames == null ? void 0 : classNames.form) == null ? void 0 : _a.button, (_b = classNames == null ? void 0 : classNames.form) == null ? void 0 : _b.secondaryButton),
		disabled: isSubmitting,
		type: "button",
		variant: "secondary",
		onClick: () => navigate(`${basePath}/${view === "EMAIL_OTP" ? viewPaths.SIGN_IN : viewPaths.EMAIL_OTP}${window.location.search}`),
		children: [
			view === "EMAIL_OTP" ? /* @__PURE__ */ jsx(LockIcon, { className: (_c = classNames == null ? void 0 : classNames.form) == null ? void 0 : _c.icon }) : /* @__PURE__ */ jsx(MailIcon, { className: (_d = classNames == null ? void 0 : classNames.form) == null ? void 0 : _d.icon }),
			localization.SIGN_IN_WITH,
			" ",
			view === "EMAIL_OTP" ? localization.PASSWORD : localization.EMAIL_OTP
		]
	});
}
function MagicLinkButton({ classNames, isSubmitting, localization, view }) {
	var _a, _b, _c, _d;
	const { viewPaths, navigate, basePath, credentials } = useContext(AuthUIContext);
	return /* @__PURE__ */ jsxs(Button, {
		className: cn("w-full", (_a = classNames == null ? void 0 : classNames.form) == null ? void 0 : _a.button, (_b = classNames == null ? void 0 : classNames.form) == null ? void 0 : _b.secondaryButton),
		disabled: isSubmitting,
		type: "button",
		variant: "secondary",
		onClick: () => navigate(`${basePath}/${view === "MAGIC_LINK" || !credentials ? viewPaths.SIGN_IN : viewPaths.MAGIC_LINK}${window.location.search}`),
		children: [
			view === "MAGIC_LINK" ? /* @__PURE__ */ jsx(LockIcon, { className: (_c = classNames == null ? void 0 : classNames.form) == null ? void 0 : _c.icon }) : /* @__PURE__ */ jsx(MailIcon, { className: (_d = classNames == null ? void 0 : classNames.form) == null ? void 0 : _d.icon }),
			localization.SIGN_IN_WITH,
			" ",
			view === "MAGIC_LINK" ? localization.PASSWORD : localization.MAGIC_LINK
		]
	});
}
function OneTap({ localization, redirectTo }) {
	const { authClient: authClient2, localization: contextLocalization, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	const oneTapFetched = useRef(false);
	localization = useMemo(() => ({
		...contextLocalization,
		...localization
	}), [contextLocalization, localization]);
	const { onSuccess } = useOnSuccessTransition({ redirectTo });
	useEffect(() => {
		if (oneTapFetched.current) return;
		oneTapFetched.current = true;
		try {
			authClient2.oneTap({ fetchOptions: {
				throw: true,
				onSuccess
			} });
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
	}, [
		authClient2,
		localization,
		localizeErrors,
		onSuccess,
		toast$1
	]);
	return null;
}
function PasskeyButton({ classNames, isSubmitting, localization, redirectTo, setIsSubmitting }) {
	var _a, _b;
	const { authClient: authClient2, localization: contextLocalization, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	const { onSuccess } = useOnSuccessTransition({ redirectTo });
	const signInPassKey = async () => {
		setIsSubmitting?.(true);
		try {
			const response = await authClient2.signIn.passkey({ fetchOptions: { throw: true } });
			if (response == null ? void 0 : response.error) {
				toast$1({
					variant: "error",
					message: getLocalizedError({
						error: response.error,
						localization,
						localizeErrors
					})
				});
				setIsSubmitting?.(false);
			} else onSuccess();
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
			setIsSubmitting?.(false);
		}
	};
	return /* @__PURE__ */ jsxs(Button, {
		className: cn("w-full", (_a = classNames == null ? void 0 : classNames.form) == null ? void 0 : _a.button, (_b = classNames == null ? void 0 : classNames.form) == null ? void 0 : _b.secondaryButton),
		disabled: isSubmitting,
		formNoValidate: true,
		name: "passkey",
		value: "true",
		variant: "secondary",
		onClick: signInPassKey,
		children: [
			/* @__PURE__ */ jsx(FingerprintIcon, {}),
			localization.SIGN_IN_WITH,
			" ",
			localization.PASSKEY
		]
	});
}
function ProviderButton({ className, classNames, callbackURL: callbackURLProp, isSubmitting, localization, other, provider, redirectTo: redirectToProp, socialLayout, setIsSubmitting }) {
	var _a, _b, _c, _d;
	const { authClient: authClient2, basePath, baseURL, persistClient, redirectTo: contextRedirectTo, viewPaths, social, genericOAuth, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	const getRedirectTo = useCallback(() => redirectToProp || getSearchParam("redirectTo") || contextRedirectTo, [redirectToProp, contextRedirectTo]);
	const getCallbackURL = useCallback(() => `${baseURL}${callbackURLProp || (persistClient ? `${basePath}/${viewPaths.CALLBACK}?redirectTo=${encodeURIComponent(getRedirectTo())}` : getRedirectTo())}`, [
		callbackURLProp,
		persistClient,
		basePath,
		viewPaths,
		baseURL,
		getRedirectTo
	]);
	const doSignInSocial = async () => {
		setIsSubmitting(true);
		try {
			if (other) {
				const oauth2Params = {
					providerId: provider.provider,
					callbackURL: getCallbackURL(),
					fetchOptions: { throw: true }
				};
				if (genericOAuth == null ? void 0 : genericOAuth.signIn) {
					await genericOAuth.signIn(oauth2Params);
					setTimeout(() => {
						setIsSubmitting(false);
					}, 1e4);
				} else await authClient2.signIn.oauth2(oauth2Params);
			} else {
				const socialParams = {
					provider: provider.provider,
					callbackURL: getCallbackURL(),
					fetchOptions: { throw: true }
				};
				if (social == null ? void 0 : social.signIn) {
					await social.signIn(socialParams);
					setTimeout(() => {
						setIsSubmitting(false);
					}, 1e4);
				} else await authClient2.signIn.social(socialParams);
			}
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
			setIsSubmitting(false);
		}
	};
	return /* @__PURE__ */ jsxs(Button, {
		className: cn(socialLayout === "vertical" ? "w-full" : "grow", className, (_a = classNames == null ? void 0 : classNames.form) == null ? void 0 : _a.button, (_b = classNames == null ? void 0 : classNames.form) == null ? void 0 : _b.outlineButton, (_c = classNames == null ? void 0 : classNames.form) == null ? void 0 : _c.providerButton),
		disabled: isSubmitting,
		variant: "outline",
		onClick: doSignInSocial,
		children: [
			provider.icon && /* @__PURE__ */ jsx(provider.icon, { className: (_d = classNames == null ? void 0 : classNames.form) == null ? void 0 : _d.icon }),
			socialLayout === "grid" && provider.name,
			socialLayout === "vertical" && `${localization.SIGN_IN_WITH} ${provider.name}`
		]
	});
}
function AuthView({ className, classNames, callbackURL, cardHeader, cardFooter, localization, path: pathProp, pathname, redirectTo, socialLayout: socialLayoutProp = "auto", view: viewProp, otpSeparators = 0 }) {
	var _a, _b, _c, _d, _e, _f;
	const isHydrated = useIsHydrated();
	const { basePath, credentials, localization: contextLocalization, magicLink, emailOTP, oneTap, passkey, signUp, social, genericOAuth, viewPaths, Link } = useContext(AuthUIContext);
	localization = {
		...contextLocalization,
		...localization
	};
	let socialLayout = socialLayoutProp;
	if (socialLayout === "auto") socialLayout = !credentials ? "vertical" : (social == null ? void 0 : social.providers) && social.providers.length > 2 ? "horizontal" : "vertical";
	const path = pathProp ?? (pathname == null ? void 0 : pathname.split("/").pop());
	const view = viewProp || getViewByPath(viewPaths, path) || "SIGN_IN";
	const [isSubmitting, setIsSubmitting] = useState(false);
	useEffect(() => {
		const handlePageHide = () => setIsSubmitting(false);
		window.addEventListener("pagehide", handlePageHide);
		return () => {
			setIsSubmitting(false);
			window.removeEventListener("pagehide", handlePageHide);
		};
	}, []);
	if (view === "CALLBACK") return /* @__PURE__ */ jsx(AuthCallback, { redirectTo });
	if (view === "SIGN_OUT") return /* @__PURE__ */ jsx(SignOut, { redirectTo });
	if (view === "ACCEPT_INVITATION") return /* @__PURE__ */ jsx(AcceptInvitationCard, {
		className,
		classNames
	});
	const description = !credentials && !magicLink && !emailOTP ? localization.DISABLED_CREDENTIALS_DESCRIPTION : localization[`${view}_DESCRIPTION`];
	return /* @__PURE__ */ jsxs(Card, {
		className: cn("w-full max-w-sm", className, classNames == null ? void 0 : classNames.base),
		children: [
			/* @__PURE__ */ jsx(CardHeader, {
				className: classNames == null ? void 0 : classNames.header,
				children: cardHeader ? cardHeader : /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(CardTitle, {
					className: cn("text-lg md:text-xl", classNames == null ? void 0 : classNames.title),
					children: localization[view]
				}), description && /* @__PURE__ */ jsx(CardDescription, {
					className: cn("text-xs md:text-sm", classNames == null ? void 0 : classNames.description),
					children: description
				})] })
			}),
			/* @__PURE__ */ jsxs(CardContent, {
				className: cn("grid gap-6", classNames == null ? void 0 : classNames.content),
				children: [
					oneTap && [
						"SIGN_IN",
						"SIGN_UP",
						"MAGIC_LINK",
						"EMAIL_OTP"
					].includes(view) && /* @__PURE__ */ jsx(OneTap, {
						localization,
						redirectTo
					}),
					(credentials || magicLink || emailOTP) && /* @__PURE__ */ jsxs("div", {
						className: "grid gap-4",
						children: [
							/* @__PURE__ */ jsx(AuthForm, {
								classNames: classNames == null ? void 0 : classNames.form,
								callbackURL,
								isSubmitting,
								localization,
								otpSeparators,
								view,
								redirectTo,
								setIsSubmitting
							}),
							magicLink && (credentials && [
								"FORGOT_PASSWORD",
								"SIGN_UP",
								"SIGN_IN",
								"MAGIC_LINK",
								"EMAIL_OTP"
							].includes(view) || emailOTP && view === "EMAIL_OTP") && /* @__PURE__ */ jsx(MagicLinkButton, {
								classNames,
								localization,
								view,
								isSubmitting
							}),
							emailOTP && (credentials && [
								"FORGOT_PASSWORD",
								"SIGN_UP",
								"SIGN_IN",
								"MAGIC_LINK",
								"EMAIL_OTP"
							].includes(view) || magicLink && ["SIGN_IN", "MAGIC_LINK"].includes(view)) && /* @__PURE__ */ jsx(EmailOTPButton, {
								classNames,
								localization,
								view,
								isSubmitting
							})
						]
					}),
					view !== "RESET_PASSWORD" && (((_a = social == null ? void 0 : social.providers) == null ? void 0 : _a.length) || ((_b = genericOAuth == null ? void 0 : genericOAuth.providers) == null ? void 0 : _b.length) || view === "SIGN_IN" && passkey) && /* @__PURE__ */ jsxs(Fragment$1, { children: [(credentials || magicLink || emailOTP) && /* @__PURE__ */ jsxs("div", {
						className: cn("flex items-center gap-2", classNames == null ? void 0 : classNames.continueWith),
						children: [
							/* @__PURE__ */ jsx(Separator3, { className: cn("!w-auto grow", classNames == null ? void 0 : classNames.separator) }),
							/* @__PURE__ */ jsx("span", {
								className: "flex-shrink-0 text-muted-foreground text-sm",
								children: localization.OR_CONTINUE_WITH
							}),
							/* @__PURE__ */ jsx(Separator3, { className: cn("!w-auto grow", classNames == null ? void 0 : classNames.separator) })
						]
					}), /* @__PURE__ */ jsxs("div", {
						className: "grid gap-4",
						children: [(((_c = social == null ? void 0 : social.providers) == null ? void 0 : _c.length) || ((_d = genericOAuth == null ? void 0 : genericOAuth.providers) == null ? void 0 : _d.length)) && /* @__PURE__ */ jsxs("div", {
							className: cn("flex w-full items-center justify-between gap-4", socialLayout === "horizontal" && "flex-wrap", socialLayout === "vertical" && "flex-col", socialLayout === "grid" && "grid grid-cols-2"),
							children: [(_e = social == null ? void 0 : social.providers) == null ? void 0 : _e.map((provider) => {
								const socialProvider = socialProviders.find((socialProvider2) => socialProvider2.provider === provider);
								if (!socialProvider) return null;
								return /* @__PURE__ */ jsx(ProviderButton, {
									classNames,
									callbackURL,
									isSubmitting,
									localization,
									provider: socialProvider,
									redirectTo,
									setIsSubmitting,
									socialLayout
								}, provider);
							}), (_f = genericOAuth == null ? void 0 : genericOAuth.providers) == null ? void 0 : _f.map((provider) => /* @__PURE__ */ jsx(ProviderButton, {
								classNames,
								callbackURL,
								isSubmitting,
								localization,
								provider,
								redirectTo,
								setIsSubmitting,
								socialLayout,
								other: true
							}, provider.provider))]
						}), passkey && [
							"SIGN_IN",
							"MAGIC_LINK",
							"EMAIL_OTP",
							"RECOVER_ACCOUNT",
							"TWO_FACTOR",
							"FORGOT_PASSWORD"
						].includes(view) && /* @__PURE__ */ jsx(PasskeyButton, {
							classNames,
							isSubmitting,
							localization,
							redirectTo,
							setIsSubmitting
						})]
					})] })
				]
			}),
			cardFooter && /* @__PURE__ */ jsx(CardFooter, {
				className: classNames == null ? void 0 : classNames.footer,
				children: cardFooter
			}),
			credentials && signUp && /* @__PURE__ */ jsxs(CardFooter, {
				className: cn("justify-center gap-1.5 text-muted-foreground text-sm", classNames == null ? void 0 : classNames.footer),
				children: [view === "SIGN_IN" || view === "MAGIC_LINK" || view === "EMAIL_OTP" ? localization.DONT_HAVE_AN_ACCOUNT : view === "SIGN_UP" ? localization.ALREADY_HAVE_AN_ACCOUNT : /* @__PURE__ */ jsx(ArrowLeftIcon, { className: "size-3" }), view === "SIGN_IN" || view === "MAGIC_LINK" || view === "EMAIL_OTP" || view === "SIGN_UP" ? /* @__PURE__ */ jsx(Link, {
					className: cn("text-foreground underline", classNames == null ? void 0 : classNames.footerLink),
					href: `${basePath}/${viewPaths[view === "SIGN_IN" || view === "MAGIC_LINK" || view === "EMAIL_OTP" ? "SIGN_UP" : "SIGN_IN"]}${isHydrated ? window.location.search : ""}`,
					children: /* @__PURE__ */ jsx(Button, {
						variant: "link",
						size: "sm",
						className: cn("px-0 text-foreground underline", classNames == null ? void 0 : classNames.footerLink),
						children: view === "SIGN_IN" || view === "MAGIC_LINK" || view === "EMAIL_OTP" ? localization.SIGN_UP : localization.SIGN_IN
					})
				}) : /* @__PURE__ */ jsx(Button, {
					variant: "link",
					size: "sm",
					className: cn("px-0 text-foreground underline", classNames == null ? void 0 : classNames.footerLink),
					onClick: () => window.history.back(),
					children: localization.GO_BACK
				})]
			})
		]
	});
}
function AuthLoading({ children }) {
	const { hooks: { useSession } } = useContext(AuthUIContext);
	const { isPending } = useSession();
	return isPending ? children : null;
}
function CreateTeamDialog({ classNames, localization: localizationProp, refetch, organizationId, onOpenChange, ...props }) {
	var _a, _b, _c;
	const { authClient: authClient2, localization: contextLocalization, localizeErrors, toast: toast$1 } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const form = useForm({
		resolver: zodResolver(z$1.object({ name: z$1.string().min(1, { message: `${localization.TEAM_NAME} ${localization.IS_REQUIRED}` }).max(64, { message: localization.TEAM_NAME_INSTRUCTIONS }) })),
		defaultValues: { name: "" }
	});
	const isSubmitting = form.formState.isSubmitting;
	async function onSubmit({ name }) {
		if (!organizationId) return;
		try {
			await authClient2.organization.createTeam({
				name,
				organizationId,
				fetchOptions: { throw: true }
			});
			await (refetch == null ? void 0 : refetch());
			onOpenChange?.(false);
			form.reset();
			toast$1({
				variant: "success",
				message: localization.CREATE_TEAM_SUCCESS
			});
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
	}
	return /* @__PURE__ */ jsx(Dialog, {
		onOpenChange,
		...props,
		children: /* @__PURE__ */ jsxs(DialogContent, {
			className: (_a = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _a.content,
			children: [/* @__PURE__ */ jsxs(DialogHeader, {
				className: (_b = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _b.header,
				children: [/* @__PURE__ */ jsx(DialogTitle, {
					className: cn("text-lg md:text-xl", classNames == null ? void 0 : classNames.title),
					children: localization.CREATE_TEAM
				}), /* @__PURE__ */ jsx(DialogDescription, {
					className: cn("text-xs md:text-sm", classNames == null ? void 0 : classNames.description),
					children: localization.TEAM_NAME_DESCRIPTION
				})]
			}), /* @__PURE__ */ jsx(Form, {
				...form,
				children: /* @__PURE__ */ jsxs("form", {
					onSubmit: form.handleSubmit(onSubmit),
					className: "space-y-6",
					children: [/* @__PURE__ */ jsx(FormField, {
						control: form.control,
						name: "name",
						render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
							/* @__PURE__ */ jsx(FormLabel, { children: localization.TEAM_NAME }),
							/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(Input, {
								placeholder: localization.TEAM_NAME_PLACEHOLDER,
								...field
							}) }),
							/* @__PURE__ */ jsx(FormMessage, {})
						] })
					}), /* @__PURE__ */ jsxs(DialogFooter, {
						className: (_c = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _c.footer,
						children: [/* @__PURE__ */ jsx(Button, {
							type: "button",
							variant: "outline",
							onClick: () => onOpenChange == null ? void 0 : onOpenChange(false),
							className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.outlineButton),
							children: localization.CANCEL
						}), /* @__PURE__ */ jsxs(Button, {
							type: "submit",
							className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.primaryButton),
							disabled: isSubmitting || !organizationId,
							children: [isSubmitting && /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }), localization.CREATE_TEAM]
						})]
					})]
				})
			})]
		})
	});
}
function DeleteOrganizationDialog({ classNames, localization: localizationProp, onOpenChange, organization, ...props }) {
	var _a, _b, _c;
	const { authClient: authClient2, account: accountOptions, hooks: { useListOrganizations }, localization: contextLocalization, navigate, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const { refetch: refetchOrganizations } = useListOrganizations();
	const form = useForm({
		resolver: zodResolver(z$1.object({ slug: z$1.string().min(1, { message: localization.SLUG_REQUIRED }).refine((val) => val === organization.slug, { message: localization.SLUG_DOES_NOT_MATCH }) })),
		defaultValues: { slug: "" }
	});
	const { isSubmitting } = form.formState;
	const deleteOrganization = async () => {
		try {
			await authClient2.organization.delete({
				organizationId: organization.id,
				fetchOptions: { throw: true }
			});
			await (refetchOrganizations == null ? void 0 : refetchOrganizations());
			toast$1({
				variant: "success",
				message: localization.DELETE_ORGANIZATION_SUCCESS
			});
			navigate(`${accountOptions == null ? void 0 : accountOptions.basePath}/${accountOptions == null ? void 0 : accountOptions.viewPaths.ORGANIZATIONS}`);
			onOpenChange?.(false);
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
	};
	return /* @__PURE__ */ jsx(Dialog, {
		onOpenChange,
		...props,
		children: /* @__PURE__ */ jsxs(DialogContent, {
			className: cn("sm:max-w-md", (_a = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _a.content),
			children: [
				/* @__PURE__ */ jsxs(DialogHeader, {
					className: (_b = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _b.header,
					children: [/* @__PURE__ */ jsx(DialogTitle, {
						className: cn("text-lg md:text-xl", classNames == null ? void 0 : classNames.title),
						children: localization == null ? void 0 : localization.DELETE_ORGANIZATION
					}), /* @__PURE__ */ jsx(DialogDescription, {
						className: cn("text-xs md:text-sm", classNames == null ? void 0 : classNames.description),
						children: localization == null ? void 0 : localization.DELETE_ORGANIZATION_DESCRIPTION
					})]
				}),
				/* @__PURE__ */ jsx(Card, {
					className: cn("my-2 flex-row p-4", classNames == null ? void 0 : classNames.cell),
					children: /* @__PURE__ */ jsx(OrganizationCellView, {
						organization,
						localization
					})
				}),
				/* @__PURE__ */ jsx(Form, {
					...form,
					children: /* @__PURE__ */ jsxs("form", {
						onSubmit: form.handleSubmit(deleteOrganization),
						className: "grid gap-6",
						children: [/* @__PURE__ */ jsx(FormField, {
							control: form.control,
							name: "slug",
							render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
								/* @__PURE__ */ jsxs(FormLabel, {
									className: classNames == null ? void 0 : classNames.label,
									children: [localization == null ? void 0 : localization.DELETE_ORGANIZATION_INSTRUCTIONS, /* @__PURE__ */ jsx("span", {
										className: "font-bold",
										children: organization.slug
									})]
								}),
								/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(Input, {
									placeholder: organization.slug,
									className: classNames == null ? void 0 : classNames.input,
									autoComplete: "off",
									...field
								}) }),
								/* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })
							] })
						}), /* @__PURE__ */ jsxs(DialogFooter, {
							className: (_c = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _c.footer,
							children: [/* @__PURE__ */ jsx(Button, {
								type: "button",
								variant: "secondary",
								className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.secondaryButton),
								onClick: () => onOpenChange == null ? void 0 : onOpenChange(false),
								children: localization.CANCEL
							}), /* @__PURE__ */ jsxs(Button, {
								className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.destructiveButton),
								disabled: isSubmitting,
								variant: "destructive",
								type: "submit",
								children: [isSubmitting && /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }), localization == null ? void 0 : localization.DELETE_ORGANIZATION]
							})]
						})]
					})
				})
			]
		})
	});
}
function DeleteOrganizationCard({ className, classNames, localization: localizationProp, slug, ...props }) {
	const { localization: contextLocalization } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const { data: organization } = useCurrentOrganization({ slug });
	if (!organization) return /* @__PURE__ */ jsx(SettingsCard, {
		className,
		classNames,
		actionLabel: localization == null ? void 0 : localization.DELETE_ORGANIZATION,
		description: localization == null ? void 0 : localization.DELETE_ORGANIZATION_DESCRIPTION,
		isPending: true,
		title: localization == null ? void 0 : localization.DELETE_ORGANIZATION,
		variant: "destructive"
	});
	return /* @__PURE__ */ jsx(DeleteOrganizationForm, {
		className,
		classNames,
		localization,
		organization,
		...props
	});
}
function DeleteOrganizationForm({ className, classNames, localization: localizationProp, organization }) {
	const { localization: contextLocalization, hooks: { useHasPermission } } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const { data: hasPermission, isPending } = useHasPermission({
		organizationId: organization.id,
		permissions: { organization: ["delete"] }
	});
	const [showDialog, setShowDialog] = useState(false);
	if (!(hasPermission == null ? void 0 : hasPermission.success)) return null;
	return /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(SettingsCard, {
		className,
		classNames,
		actionLabel: localization == null ? void 0 : localization.DELETE_ORGANIZATION,
		description: localization == null ? void 0 : localization.DELETE_ORGANIZATION_DESCRIPTION,
		isPending,
		title: localization == null ? void 0 : localization.DELETE_ORGANIZATION,
		variant: "destructive",
		action: () => setShowDialog(true)
	}), /* @__PURE__ */ jsx(DeleteOrganizationDialog, {
		classNames,
		localization,
		open: showDialog,
		onOpenChange: setShowDialog,
		organization
	})] });
}
function DeleteTeamDialog({ classNames, team, localization: localizationProp, refetch, onOpenChange, ...props }) {
	var _a, _b, _c;
	const { authClient: authClient2, localization: contextLocalization, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const [isDeleting, setIsDeleting] = useState(false);
	const handleDelete = async () => {
		try {
			setIsDeleting(true);
			await authClient2.organization.removeTeam({
				teamId: team.id,
				organizationId: team.organizationId,
				fetchOptions: { throw: true }
			});
			toast$1({
				variant: "success",
				message: localization.DELETE_TEAM_SUCCESS
			});
			await (refetch == null ? void 0 : refetch());
			onOpenChange?.(false);
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		} finally {
			setIsDeleting(false);
		}
	};
	return /* @__PURE__ */ jsx(Dialog, {
		onOpenChange,
		...props,
		children: /* @__PURE__ */ jsxs(DialogContent, {
			className: (_a = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _a.content,
			onOpenAutoFocus: (e) => e.preventDefault(),
			children: [
				/* @__PURE__ */ jsxs(DialogHeader, {
					className: (_b = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _b.header,
					children: [/* @__PURE__ */ jsx(DialogTitle, {
						className: cn("text-lg md:text-xl", classNames == null ? void 0 : classNames.title),
						children: localization.DELETE_TEAM
					}), /* @__PURE__ */ jsx(DialogDescription, {
						className: cn("text-xs md:text-sm", classNames == null ? void 0 : classNames.description),
						children: localization.REMOVE_TEAM_CONFIRM
					})]
				}),
				/* @__PURE__ */ jsxs(Card, {
					className: cn("my-2 flex-row items-center gap-3 px-4 py-3", classNames == null ? void 0 : classNames.cell),
					children: [/* @__PURE__ */ jsx(UsersIcon, { className: cn("size-5 flex-shrink-0", classNames == null ? void 0 : classNames.icon) }), /* @__PURE__ */ jsxs("div", {
						className: "flex flex-col truncate",
						children: [/* @__PURE__ */ jsx("div", {
							className: "flex items-center gap-2",
							children: /* @__PURE__ */ jsx("span", {
								className: "truncate font-semibold text-sm",
								children: team.name
							})
						}), /* @__PURE__ */ jsx("div", {
							className: "truncate text-muted-foreground text-xs",
							children: localization == null ? void 0 : localization.TEAM
						})]
					})]
				}),
				/* @__PURE__ */ jsxs(DialogFooter, {
					className: (_c = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _c.footer,
					children: [/* @__PURE__ */ jsx(Button, {
						className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.secondaryButton),
						disabled: isDeleting,
						onClick: () => onOpenChange == null ? void 0 : onOpenChange(false),
						type: "button",
						variant: "secondary",
						children: localization.CANCEL
					}), /* @__PURE__ */ jsxs(Button, {
						className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.destructiveButton),
						disabled: isDeleting,
						onClick: handleDelete,
						type: "button",
						variant: "destructive",
						children: [isDeleting && /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }), localization.DELETE]
					})]
				})
			]
		})
	});
}
function InvitationCell({ className, classNames, invitation, localization: localizationProp, organization }) {
	const { authClient: authClient2, hooks: { useListInvitations }, organization: organizationOptions, localization: contextLocalization, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const { lang } = useLang();
	const [isLoading, setIsLoading] = useState(false);
	const role$1 = [...[
		{
			role: "owner",
			label: localization.OWNER
		},
		{
			role: "admin",
			label: localization.ADMIN
		},
		{
			role: "member",
			label: localization.MEMBER
		}
	], ...(organizationOptions == null ? void 0 : organizationOptions.customRoles) || []].find((r) => r.role === invitation.role);
	const { refetch } = useListInvitations({ query: { organizationId: organization == null ? void 0 : organization.id } });
	const handleCancelInvitation = async () => {
		setIsLoading(true);
		try {
			await authClient2.organization.cancelInvitation({
				invitationId: invitation.id,
				fetchOptions: { throw: true }
			});
			await (refetch == null ? void 0 : refetch());
			toast$1({
				variant: "success",
				message: localization.INVITATION_CANCELLED
			});
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
		setIsLoading(false);
	};
	return /* @__PURE__ */ jsxs(Card, {
		className: cn("flex-row items-center p-4", className, classNames == null ? void 0 : classNames.cell),
		children: [
			/* @__PURE__ */ jsxs("div", {
				className: "flex flex-1 items-center gap-2",
				children: [/* @__PURE__ */ jsx(UserAvatar, {
					className: "my-0.5",
					user: invitation,
					localization
				}), /* @__PURE__ */ jsxs("div", {
					className: "grid flex-1 text-left leading-tight",
					children: [/* @__PURE__ */ jsx("span", {
						className: "truncate font-semibold text-sm",
						children: invitation.email
					}), /* @__PURE__ */ jsxs("span", {
						className: "truncate text-muted-foreground text-xs",
						children: [
							localization.EXPIRES,
							" ",
							invitation.expiresAt.toLocaleDateString(lang ?? "en")
						]
					})]
				})]
			}),
			/* @__PURE__ */ jsx("span", {
				className: "truncate text-sm opacity-70",
				children: role$1 == null ? void 0 : role$1.label
			}),
			/* @__PURE__ */ jsxs(DropdownMenu, { children: [/* @__PURE__ */ jsx(DropdownMenuTrigger, {
				asChild: true,
				children: /* @__PURE__ */ jsx(Button, {
					className: cn("relative ms-auto", classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.outlineButton),
					disabled: isLoading,
					size: "icon",
					type: "button",
					variant: "outline",
					children: isLoading ? /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }) : /* @__PURE__ */ jsx(EllipsisIcon, { className: classNames == null ? void 0 : classNames.icon })
				})
			}), /* @__PURE__ */ jsx(DropdownMenuContent, {
				onCloseAutoFocus: (e) => e.preventDefault(),
				children: /* @__PURE__ */ jsxs(DropdownMenuItem, {
					onClick: handleCancelInvitation,
					disabled: isLoading,
					variant: "destructive",
					children: [/* @__PURE__ */ jsx(XIcon, { className: classNames == null ? void 0 : classNames.icon }), localization.CANCEL_INVITATION]
				})
			})] })
		]
	});
}
function OrganizationInvitationsCard({ className, classNames, localization: localizationProp, slug: slugProp, emptyState, ...props }) {
	const { localization: contextLocalization, organization: organizationOptions } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const { data: organization } = useCurrentOrganization({ slug: slugProp || (organizationOptions == null ? void 0 : organizationOptions.slug) });
	if (!organization) return null;
	return /* @__PURE__ */ jsx(OrganizationInvitationsContent, {
		className,
		classNames,
		localization,
		organization,
		...props
	});
}
function OrganizationInvitationsContent({ className, classNames, localization: localizationProp, organization, emptyState, ...props }) {
	const { hooks: { useListInvitations }, localization: contextLocalization } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const { data: invitations } = useListInvitations({ query: { organizationId: organization.id } });
	const pendingInvitations = invitations == null ? void 0 : invitations.filter((invitation) => invitation.status === "pending");
	if (!(pendingInvitations == null ? void 0 : pendingInvitations.length)) return /* @__PURE__ */ jsx(Fragment$1, { children: emptyState });
	return /* @__PURE__ */ jsx(SettingsCard, {
		className,
		classNames,
		title: localization.PENDING_INVITATIONS,
		description: localization.PENDING_INVITATIONS_DESCRIPTION,
		...props,
		children: /* @__PURE__ */ jsx(CardContent, {
			className: cn("grid gap-4", classNames == null ? void 0 : classNames.content),
			children: pendingInvitations.map((invitation) => /* @__PURE__ */ jsx(InvitationCell, {
				classNames,
				invitation,
				localization,
				organization
			}, invitation.id))
		})
	});
}
function OrganizationLogoCard({ className, classNames, localization: localizationProp, slug, ...props }) {
	const { localization: contextLocalization } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const { data: organization } = useCurrentOrganization({ slug });
	if (!organization) return /* @__PURE__ */ jsxs(Card, {
		className: cn("w-full pb-0 text-start", className, classNames == null ? void 0 : classNames.base),
		...props,
		children: [/* @__PURE__ */ jsxs("div", {
			className: "flex justify-between",
			children: [/* @__PURE__ */ jsx(SettingsCardHeader, {
				className: "grow self-start",
				title: localization.LOGO,
				description: localization.LOGO_DESCRIPTION,
				isPending: true,
				classNames
			}), /* @__PURE__ */ jsx(Button, {
				type: "button",
				className: "me-6 size-fit rounded-full",
				size: "icon",
				variant: "ghost",
				disabled: true,
				children: /* @__PURE__ */ jsx(OrganizationLogo, {
					isPending: true,
					className: "size-20 text-2xl",
					classNames: classNames == null ? void 0 : classNames.avatar,
					localization
				})
			})]
		}), /* @__PURE__ */ jsx(SettingsCardFooter, {
			className: "!py-5",
			instructions: localization.LOGO_INSTRUCTIONS,
			classNames,
			isPending: true
		})]
	});
	return /* @__PURE__ */ jsx(OrganizationLogoForm, {
		className,
		classNames,
		localization,
		organization,
		...props
	});
}
function OrganizationLogoForm({ className, classNames, localization: localizationProp, organization, ...props }) {
	const { hooks: { useHasPermission }, localization: authLocalization2, organization: organizationOptions, mutators: { updateOrganization }, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...authLocalization2,
		...localizationProp
	}), [authLocalization2, localizationProp]);
	const { refetch: refetchOrganization } = useCurrentOrganization({ slug: organization.slug });
	const { data: hasPermission, isPending: permissionPending } = useHasPermission({
		organizationId: organization.id,
		permissions: { organization: ["update"] }
	});
	const isPending = permissionPending;
	const fileInputRef = useRef(null);
	const [loading, setLoading] = useState(false);
	const handleLogoChange = async (file) => {
		if (!(organizationOptions == null ? void 0 : organizationOptions.logo) || !(hasPermission == null ? void 0 : hasPermission.success)) return;
		setLoading(true);
		const resizedFile = await resizeAndCropImage(file, crypto.randomUUID(), organizationOptions.logo.size, organizationOptions.logo.extension);
		let image;
		if (organizationOptions.logo.upload) image = await organizationOptions.logo.upload(resizedFile);
		else image = await fileToBase64(resizedFile);
		if (!image) {
			setLoading(false);
			return;
		}
		try {
			await updateOrganization({
				organizationId: organization.id,
				data: { logo: image }
			});
			await (refetchOrganization == null ? void 0 : refetchOrganization());
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
		setLoading(false);
	};
	const handleDeleteLogo = async () => {
		var _a, _b;
		if (!(hasPermission == null ? void 0 : hasPermission.success)) return;
		setLoading(true);
		try {
			if (organization.logo) await ((_b = (_a = organizationOptions == null ? void 0 : organizationOptions.logo) == null ? void 0 : _a.delete) == null ? void 0 : _b.call(_a, organization.logo));
			await updateOrganization({
				organizationId: organization.id,
				data: { logo: "" }
			});
			await (refetchOrganization == null ? void 0 : refetchOrganization());
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
		setLoading(false);
	};
	const openFileDialog = () => {
		var _a;
		(_a = fileInputRef.current) == null || _a.click();
	};
	return /* @__PURE__ */ jsxs(Card, {
		className: cn("w-full pb-0 text-start", className, classNames == null ? void 0 : classNames.base),
		...props,
		children: [
			/* @__PURE__ */ jsx("input", {
				ref: fileInputRef,
				accept: "image/*",
				disabled: loading || !(hasPermission == null ? void 0 : hasPermission.success),
				hidden: true,
				type: "file",
				onChange: (e) => {
					var _a;
					const file = (_a = e.target.files) == null ? void 0 : _a.item(0);
					if (file) handleLogoChange(file);
					e.target.value = "";
				}
			}),
			/* @__PURE__ */ jsxs("div", {
				className: "flex justify-between",
				children: [/* @__PURE__ */ jsx(SettingsCardHeader, {
					className: "grow self-start",
					title: localization.LOGO,
					description: localization.LOGO_DESCRIPTION,
					isPending,
					classNames
				}), /* @__PURE__ */ jsxs(DropdownMenu, { children: [/* @__PURE__ */ jsx(DropdownMenuTrigger, {
					asChild: true,
					children: /* @__PURE__ */ jsx(Button, {
						type: "button",
						className: "me-6 size-fit rounded-full",
						size: "icon",
						variant: "ghost",
						disabled: !(hasPermission == null ? void 0 : hasPermission.success),
						children: /* @__PURE__ */ jsx(OrganizationLogo, {
							isPending: isPending || loading,
							className: "size-20 text-2xl",
							classNames: classNames == null ? void 0 : classNames.avatar,
							organization,
							localization
						}, organization.logo)
					})
				}), /* @__PURE__ */ jsxs(DropdownMenuContent, {
					align: "end",
					onCloseAutoFocus: (e) => e.preventDefault(),
					children: [/* @__PURE__ */ jsxs(DropdownMenuItem, {
						onClick: openFileDialog,
						disabled: loading || !(hasPermission == null ? void 0 : hasPermission.success),
						children: [/* @__PURE__ */ jsx(UploadCloudIcon, {}), localization.UPLOAD_LOGO]
					}), organization.logo && /* @__PURE__ */ jsxs(DropdownMenuItem, {
						onClick: handleDeleteLogo,
						disabled: loading || !(hasPermission == null ? void 0 : hasPermission.success),
						variant: "destructive",
						children: [/* @__PURE__ */ jsx(Trash2Icon, {}), localization.DELETE_LOGO]
					})]
				})] })]
			}),
			/* @__PURE__ */ jsx(SettingsCardFooter, {
				className: "!py-5",
				instructions: localization.LOGO_INSTRUCTIONS,
				classNames,
				isPending,
				isSubmitting: loading
			})
		]
	});
}
function InviteMemberDialog({ classNames, localization: localizationProp, onOpenChange, organization, ...props }) {
	var _a, _b, _c;
	const { authClient: authClient2, hooks: { useListInvitations, useListMembers, useSession }, localization: contextLocalization, toast: toast$1, organization: organizationOptions, localizeErrors } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const { data } = useListMembers({ query: { organizationId: organization.id } });
	const { refetch } = useListInvitations({ query: { organizationId: organization.id } });
	const members = data == null ? void 0 : data.members;
	const { data: sessionData } = useSession();
	const membership = members == null ? void 0 : members.find((m) => m.userId === (sessionData == null ? void 0 : sessionData.user.id));
	const availableRoles = [...[
		{
			role: "owner",
			label: localization.OWNER
		},
		{
			role: "admin",
			label: localization.ADMIN
		},
		{
			role: "member",
			label: localization.MEMBER
		}
	], ...(organizationOptions == null ? void 0 : organizationOptions.customRoles) || []].filter((role$1) => (membership == null ? void 0 : membership.role) === "owner" || role$1.role !== "owner");
	const form = useForm({
		resolver: zodResolver(z$1.object({
			email: z$1.string().min(1, { message: localization.EMAIL_REQUIRED }).email({ message: localization.INVALID_EMAIL }),
			role: z$1.string().min(1, { message: `${localization.ROLE} ${localization.IS_REQUIRED}` })
		})),
		defaultValues: {
			email: "",
			role: "member"
		}
	});
	const isSubmitting = form.formState.isSubmitting;
	async function onSubmit({ email, role: role$1 }) {
		try {
			await authClient2.organization.inviteMember({
				email,
				role: role$1,
				organizationId: organization.id,
				fetchOptions: { throw: true }
			});
			await (refetch == null ? void 0 : refetch());
			onOpenChange?.(false);
			form.reset();
			toast$1({
				variant: "success",
				message: localization.SEND_INVITATION_SUCCESS || "Invitation sent successfully"
			});
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
	}
	return /* @__PURE__ */ jsx(Dialog, {
		onOpenChange,
		...props,
		children: /* @__PURE__ */ jsxs(DialogContent, {
			className: (_a = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _a.content,
			children: [/* @__PURE__ */ jsxs(DialogHeader, {
				className: (_b = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _b.header,
				children: [/* @__PURE__ */ jsx(DialogTitle, {
					className: cn("text-lg md:text-xl", classNames == null ? void 0 : classNames.title),
					children: localization.INVITE_MEMBER
				}), /* @__PURE__ */ jsx(DialogDescription, {
					className: cn("text-xs md:text-sm", classNames == null ? void 0 : classNames.description),
					children: localization.INVITE_MEMBER_DESCRIPTION
				})]
			}), /* @__PURE__ */ jsx(Form, {
				...form,
				children: /* @__PURE__ */ jsxs("form", {
					onSubmit: form.handleSubmit(onSubmit),
					className: "space-y-6",
					children: [
						/* @__PURE__ */ jsx(FormField, {
							control: form.control,
							name: "email",
							render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
								/* @__PURE__ */ jsx(FormLabel, {
									className: classNames == null ? void 0 : classNames.label,
									children: localization.EMAIL
								}),
								/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(Input, {
									placeholder: localization.EMAIL_PLACEHOLDER,
									type: "email",
									...field,
									className: classNames == null ? void 0 : classNames.input
								}) }),
								/* @__PURE__ */ jsx(FormMessage, {})
							] })
						}),
						/* @__PURE__ */ jsx(FormField, {
							control: form.control,
							name: "role",
							render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [
								/* @__PURE__ */ jsx(FormLabel, {
									className: classNames == null ? void 0 : classNames.label,
									children: localization.ROLE
								}),
								/* @__PURE__ */ jsxs(Select, {
									onValueChange: field.onChange,
									defaultValue: field.value,
									children: [/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(SelectTrigger, { children: /* @__PURE__ */ jsx(SelectValue, {}) }) }), /* @__PURE__ */ jsx(SelectContent, { children: availableRoles.map((role$1) => /* @__PURE__ */ jsx(SelectItem, {
										value: role$1.role,
										children: role$1.label
									}, role$1.role)) })]
								}),
								/* @__PURE__ */ jsx(FormMessage, {})
							] })
						}),
						/* @__PURE__ */ jsxs(DialogFooter, {
							className: (_c = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _c.footer,
							children: [/* @__PURE__ */ jsx(Button, {
								type: "button",
								variant: "outline",
								onClick: () => onOpenChange == null ? void 0 : onOpenChange(false),
								className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.outlineButton),
								children: localization.CANCEL
							}), /* @__PURE__ */ jsxs(Button, {
								type: "submit",
								className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.primaryButton),
								disabled: isSubmitting,
								children: [isSubmitting && /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }), localization.SEND_INVITATION]
							})]
						})
					]
				})
			})]
		})
	});
}
function RemoveMemberDialog({ member, classNames, localization: localizationProp, onOpenChange, ...props }) {
	var _a, _b, _c;
	const { authClient: authClient2, hooks: { useListMembers }, localization: contextLocalization, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const { refetch } = useListMembers({ query: { organizationId: member.organizationId } });
	const [isRemoving, setIsRemoving] = useState(false);
	const removeMember = async () => {
		setIsRemoving(true);
		try {
			await authClient2.organization.removeMember({
				memberIdOrEmail: member.id,
				organizationId: member.organizationId,
				fetchOptions: { throw: true }
			});
			toast$1({
				variant: "success",
				message: localization.REMOVE_MEMBER_SUCCESS
			});
			await (refetch == null ? void 0 : refetch());
			onOpenChange?.(false);
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
		setIsRemoving(false);
	};
	return /* @__PURE__ */ jsx(Dialog, {
		onOpenChange,
		...props,
		children: /* @__PURE__ */ jsxs(DialogContent, {
			className: (_a = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _a.content,
			onOpenAutoFocus: (e) => e.preventDefault(),
			children: [
				/* @__PURE__ */ jsxs(DialogHeader, {
					className: (_b = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _b.header,
					children: [/* @__PURE__ */ jsx(DialogTitle, {
						className: cn("text-lg md:text-xl", classNames == null ? void 0 : classNames.title),
						children: localization.REMOVE_MEMBER
					}), /* @__PURE__ */ jsx(DialogDescription, {
						className: cn("text-xs md:text-sm", classNames == null ? void 0 : classNames.description),
						children: localization.REMOVE_MEMBER_CONFIRM
					})]
				}),
				/* @__PURE__ */ jsx(MemberCell, {
					className: classNames == null ? void 0 : classNames.cell,
					member,
					localization,
					hideActions: true
				}),
				/* @__PURE__ */ jsxs(DialogFooter, {
					className: (_c = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _c.footer,
					children: [/* @__PURE__ */ jsx(Button, {
						type: "button",
						variant: "outline",
						onClick: () => onOpenChange == null ? void 0 : onOpenChange(false),
						className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.outlineButton),
						disabled: isRemoving,
						children: localization.CANCEL
					}), /* @__PURE__ */ jsxs(Button, {
						type: "button",
						variant: "destructive",
						onClick: removeMember,
						className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.destructiveButton),
						disabled: isRemoving,
						children: [isRemoving && /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }), localization.REMOVE_MEMBER]
					})]
				})
			]
		})
	});
}
function UpdateMemberRoleDialog({ member, classNames, localization: localizationProp, onOpenChange, ...props }) {
	var _a, _b, _c, _d;
	const { authClient: authClient2, hooks: { useSession, useListMembers }, localization: contextLocalization, organization, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const { data, refetch } = useListMembers({ query: { organizationId: member.organizationId } });
	const members = data == null ? void 0 : data.members;
	const { data: sessionData } = useSession();
	const [isUpdating, setIsUpdating] = useState(false);
	const [selectedRole, setSelectedRole] = useState(member.role);
	const roles = [...[
		{
			role: "owner",
			label: localization.OWNER
		},
		{
			role: "admin",
			label: localization.ADMIN
		},
		{
			role: "member",
			label: localization.MEMBER
		}
	], ...(organization == null ? void 0 : organization.customRoles) || []];
	const currentUserRole = (_a = members == null ? void 0 : members.find((m) => {
		var _a2;
		return ((_a2 = m.user) == null ? void 0 : _a2.id) === (sessionData == null ? void 0 : sessionData.user.id);
	})) == null ? void 0 : _a.role;
	const availableRoles = roles.filter((role$1) => {
		if (role$1.role === "owner") return currentUserRole === "owner";
		if (role$1.role === "admin") return currentUserRole === "owner" || currentUserRole === "admin";
		return true;
	});
	const updateMemberRole = async () => {
		if (selectedRole === member.role) {
			toast$1({
				variant: "error",
				message: `${localization.ROLE} ${localization.IS_THE_SAME}`
			});
			return;
		}
		setIsUpdating(true);
		try {
			await authClient2.organization.updateMemberRole({
				memberId: member.id,
				role: selectedRole,
				organizationId: member.organizationId,
				fetchOptions: { throw: true }
			});
			toast$1({
				variant: "success",
				message: localization.MEMBER_ROLE_UPDATED
			});
			await (refetch == null ? void 0 : refetch());
			onOpenChange?.(false);
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
		setIsUpdating(false);
	};
	return /* @__PURE__ */ jsx(Dialog, {
		onOpenChange,
		...props,
		children: /* @__PURE__ */ jsxs(DialogContent, {
			className: (_b = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _b.content,
			onOpenAutoFocus: (e) => e.preventDefault(),
			children: [
				/* @__PURE__ */ jsxs(DialogHeader, {
					className: (_c = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _c.header,
					children: [/* @__PURE__ */ jsx(DialogTitle, {
						className: cn("text-lg md:text-xl", classNames == null ? void 0 : classNames.title),
						children: localization.UPDATE_ROLE
					}), /* @__PURE__ */ jsx(DialogDescription, {
						className: cn("text-xs md:text-sm", classNames == null ? void 0 : classNames.description),
						children: localization.UPDATE_ROLE_DESCRIPTION
					})]
				}),
				/* @__PURE__ */ jsxs("div", {
					className: "grid gap-6 py-4",
					children: [/* @__PURE__ */ jsx(MemberCell, {
						className: classNames == null ? void 0 : classNames.cell,
						member,
						localization,
						hideActions: true
					}), /* @__PURE__ */ jsxs(Select, {
						value: selectedRole,
						onValueChange: setSelectedRole,
						children: [/* @__PURE__ */ jsx(SelectTrigger, {
							className: "w-full",
							children: /* @__PURE__ */ jsx(SelectValue, { placeholder: localization.SELECT_ROLE })
						}), /* @__PURE__ */ jsx(SelectContent, { children: availableRoles.map((role$1) => /* @__PURE__ */ jsx(SelectItem, {
							value: role$1.role,
							children: role$1.label
						}, role$1.role)) })]
					})]
				}),
				/* @__PURE__ */ jsxs(DialogFooter, {
					className: (_d = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _d.footer,
					children: [/* @__PURE__ */ jsx(Button, {
						type: "button",
						variant: "outline",
						onClick: () => onOpenChange == null ? void 0 : onOpenChange(false),
						className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.outlineButton),
						disabled: isUpdating,
						children: localization.CANCEL
					}), /* @__PURE__ */ jsxs(Button, {
						type: "button",
						onClick: updateMemberRole,
						className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.primaryButton),
						disabled: isUpdating,
						children: [isUpdating && /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }), localization.UPDATE_ROLE]
					})]
				})
			]
		})
	});
}
function MemberCell({ className, classNames, member, localization: localizationProp, hideActions }) {
	var _a;
	const { organization: organizationOptions, hooks: { useListMembers, useSession, useListOrganizations, useHasPermission }, localization: contextLocalization } = useContext(AuthUIContext);
	const localization = {
		...contextLocalization,
		...localizationProp
	};
	const { data: sessionData } = useSession();
	const [removeDialogOpen, setRemoveDialogOpen] = useState(false);
	const [leaveDialogOpen, setLeaveDialogOpen] = useState(false);
	const [updateRoleDialogOpen, setUpdateRoleDialogOpen] = useState(false);
	const builtInRoles = [
		{
			role: "owner",
			label: localization.OWNER
		},
		{
			role: "admin",
			label: localization.ADMIN
		},
		{
			role: "member",
			label: localization.MEMBER
		}
	];
	const { data } = useListMembers({ query: { organizationId: member.organizationId } });
	const members = data == null ? void 0 : data.members;
	const myRole = (_a = members == null ? void 0 : members.find((m) => {
		var _a2;
		return ((_a2 = m.user) == null ? void 0 : _a2.id) === (sessionData == null ? void 0 : sessionData.user.id);
	})) == null ? void 0 : _a.role;
	const role$1 = [...builtInRoles, ...(organizationOptions == null ? void 0 : organizationOptions.customRoles) || []].find((r) => r.role === member.role);
	const isSelf = (sessionData == null ? void 0 : sessionData.user.id) === (member == null ? void 0 : member.userId);
	const { data: organizations } = useListOrganizations();
	const organization = organizations == null ? void 0 : organizations.find((org) => org.id === member.organizationId);
	const { data: hasPermissionToUpdateMember } = useHasPermission({
		organizationId: member.organizationId,
		permission: { member: ["update"] }
	});
	return /* @__PURE__ */ jsxs(Fragment$1, { children: [
		/* @__PURE__ */ jsxs(Card, {
			className: cn("flex-row items-center p-4", className, classNames == null ? void 0 : classNames.cell),
			children: [
				/* @__PURE__ */ jsx(UserView, {
					user: member.user,
					localization,
					className: "flex-1"
				}),
				/* @__PURE__ */ jsx("span", {
					className: "text-xs opacity-70",
					children: role$1 == null ? void 0 : role$1.label
				}),
				!hideActions && (isSelf || member.role !== "owner" || myRole === "owner") && /* @__PURE__ */ jsxs(DropdownMenu, { children: [/* @__PURE__ */ jsx(DropdownMenuTrigger, {
					asChild: true,
					children: /* @__PURE__ */ jsx(Button, {
						className: cn("relative ms-auto", classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.outlineButton),
						size: "icon",
						type: "button",
						variant: "outline",
						children: /* @__PURE__ */ jsx(EllipsisIcon, { className: classNames == null ? void 0 : classNames.icon })
					})
				}), /* @__PURE__ */ jsxs(DropdownMenuContent, {
					onCloseAutoFocus: (e) => e.preventDefault(),
					children: [(hasPermissionToUpdateMember == null ? void 0 : hasPermissionToUpdateMember.success) && /* @__PURE__ */ jsxs(DropdownMenuItem, {
						onClick: () => setUpdateRoleDialogOpen(true),
						children: [/* @__PURE__ */ jsx(UserCogIcon, { className: classNames == null ? void 0 : classNames.icon }), localization == null ? void 0 : localization.UPDATE_ROLE]
					}), /* @__PURE__ */ jsxs(DropdownMenuItem, {
						onClick: () => isSelf ? setLeaveDialogOpen(true) : setRemoveDialogOpen(true),
						variant: "destructive",
						children: [/* @__PURE__ */ jsx(UserXIcon, { className: classNames == null ? void 0 : classNames.icon }), isSelf ? localization == null ? void 0 : localization.LEAVE_ORGANIZATION : localization == null ? void 0 : localization.REMOVE_MEMBER]
					})]
				})] })
			]
		}),
		/* @__PURE__ */ jsx(RemoveMemberDialog, {
			open: removeDialogOpen,
			onOpenChange: setRemoveDialogOpen,
			member,
			classNames,
			localization
		}),
		organization && /* @__PURE__ */ jsx(LeaveOrganizationDialog, {
			open: leaveDialogOpen,
			onOpenChange: setLeaveDialogOpen,
			organization,
			classNames,
			localization
		}),
		/* @__PURE__ */ jsx(UpdateMemberRoleDialog, {
			open: updateRoleDialogOpen,
			onOpenChange: setUpdateRoleDialogOpen,
			member,
			classNames,
			localization
		})
	] });
}
function OrganizationMembersCard({ className, classNames, localization: localizationProp, slug: slugProp, ...props }) {
	const { localization: contextLocalization, organization: organizationOptions } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const { data: organization } = useCurrentOrganization({ slug: slugProp || (organizationOptions == null ? void 0 : organizationOptions.slug) });
	if (!organization) return /* @__PURE__ */ jsx(SettingsCard, {
		className,
		classNames,
		title: localization.MEMBERS,
		description: localization.MEMBERS_DESCRIPTION,
		instructions: localization.MEMBERS_INSTRUCTIONS,
		actionLabel: localization.INVITE_MEMBER,
		isPending: true,
		...props
	});
	return /* @__PURE__ */ jsx(OrganizationMembersContent, {
		className,
		classNames,
		localization,
		organization,
		...props
	});
}
function OrganizationMembersContent({ className, classNames, localization: localizationProp, organization, ...props }) {
	const { hooks: { useHasPermission, useListMembers }, localization: contextLocalization } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const { data: hasPermissionInvite, isPending: isPendingInvite } = useHasPermission({
		organizationId: organization.id,
		permissions: { invitation: ["create"] }
	});
	const { data: hasPermissionUpdateMember, isPending: isPendingUpdateMember } = useHasPermission({
		organizationId: organization.id,
		permission: { member: ["update"] }
	});
	const isPending = isPendingInvite || isPendingUpdateMember;
	const { data } = useListMembers({ query: { organizationId: organization.id } });
	const members = data == null ? void 0 : data.members;
	const [inviteDialogOpen, setInviteDialogOpen] = useState(false);
	return /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(SettingsCard, {
		className,
		classNames,
		title: localization.MEMBERS,
		description: localization.MEMBERS_DESCRIPTION,
		instructions: localization.MEMBERS_INSTRUCTIONS,
		actionLabel: localization.INVITE_MEMBER,
		action: () => setInviteDialogOpen(true),
		isPending,
		disabled: !(hasPermissionInvite == null ? void 0 : hasPermissionInvite.success),
		...props,
		children: !isPending && members && members.length > 0 && /* @__PURE__ */ jsx(CardContent, {
			className: cn("grid gap-4", classNames == null ? void 0 : classNames.content),
			children: members.sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()).map((member) => /* @__PURE__ */ jsx(MemberCell, {
				classNames,
				member,
				localization,
				hideActions: !(hasPermissionUpdateMember == null ? void 0 : hasPermissionUpdateMember.success)
			}, member.id))
		})
	}), /* @__PURE__ */ jsx(InviteMemberDialog, {
		open: inviteDialogOpen,
		onOpenChange: setInviteDialogOpen,
		classNames,
		localization,
		organization
	})] });
}
function OrganizationNameCard({ className, classNames, localization: localizationProp, slug, ...props }) {
	const { localization: contextLocalization } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const { data: organization } = useCurrentOrganization({ slug });
	if (!organization) return /* @__PURE__ */ jsx(SettingsCard, {
		className,
		classNames,
		actionLabel: localization.SAVE,
		description: localization.ORGANIZATION_NAME_DESCRIPTION,
		instructions: localization.ORGANIZATION_NAME_INSTRUCTIONS,
		isPending: true,
		title: localization.ORGANIZATION_NAME,
		...props,
		children: /* @__PURE__ */ jsx(CardContent, {
			className: classNames == null ? void 0 : classNames.content,
			children: /* @__PURE__ */ jsx(Skeleton, { className: cn("h-9 w-full", classNames == null ? void 0 : classNames.skeleton) })
		})
	});
	return /* @__PURE__ */ jsx(OrganizationNameForm, {
		className,
		classNames,
		localization,
		organization,
		...props
	});
}
function OrganizationNameForm({ className, classNames, localization: localizationProp, organization, ...props }) {
	const { localization: contextLocalization, hooks: { useHasPermission }, mutators: { updateOrganization }, optimistic, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	const localization = {
		...contextLocalization,
		...localizationProp
	};
	const { data: hasPermission, isPending: permissionPending } = useHasPermission({
		organizationId: organization.id,
		permissions: { organization: ["update"] }
	});
	const { refetch: refetchOrganization } = useCurrentOrganization({ slug: organization.slug });
	const isPending = permissionPending;
	const form = useForm({
		resolver: zodResolver(z$1.object({ name: z$1.string().min(1, { message: `${localization.ORGANIZATION_NAME} ${localization.IS_REQUIRED}` }) })),
		values: { name: organization.name || "" }
	});
	const { isSubmitting } = form.formState;
	const updateOrganizationName = async ({ name }) => {
		if (organization.name === name) {
			toast$1({
				variant: "error",
				message: `${localization.ORGANIZATION_NAME} ${localization.IS_THE_SAME}`
			});
			return;
		}
		try {
			await updateOrganization({
				organizationId: organization.id,
				data: { name }
			});
			await (refetchOrganization == null ? void 0 : refetchOrganization());
			toast$1({
				variant: "success",
				message: `${localization.ORGANIZATION_NAME} ${localization.UPDATED_SUCCESSFULLY}`
			});
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
	};
	return /* @__PURE__ */ jsx(Form, {
		...form,
		children: /* @__PURE__ */ jsx("form", {
			onSubmit: form.handleSubmit(updateOrganizationName),
			children: /* @__PURE__ */ jsx(SettingsCard, {
				className,
				classNames,
				description: localization.ORGANIZATION_NAME_DESCRIPTION,
				instructions: localization.ORGANIZATION_NAME_INSTRUCTIONS,
				isPending,
				title: localization.ORGANIZATION_NAME,
				actionLabel: localization.SAVE,
				optimistic,
				disabled: !(hasPermission == null ? void 0 : hasPermission.success),
				...props,
				children: /* @__PURE__ */ jsx(CardContent, {
					className: classNames == null ? void 0 : classNames.content,
					children: isPending ? /* @__PURE__ */ jsx(Skeleton, { className: cn("h-9 w-full", classNames == null ? void 0 : classNames.skeleton) }) : /* @__PURE__ */ jsx(FormField, {
						control: form.control,
						name: "name",
						render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(Input, {
							className: classNames == null ? void 0 : classNames.input,
							placeholder: localization.ORGANIZATION_NAME_PLACEHOLDER,
							disabled: isSubmitting || !(hasPermission == null ? void 0 : hasPermission.success),
							...field
						}) }), /* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })] })
					})
				})
			})
		})
	});
}
function OrganizationSlugCard({ className, classNames, localization: localizationProp, slug: slugProp, ...props }) {
	const { localization: contextLocalization, organization: organizationOptions } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const { data: organization } = useCurrentOrganization({ slug: slugProp || (organizationOptions == null ? void 0 : organizationOptions.slug) });
	if (!organization) return /* @__PURE__ */ jsx(SettingsCard, {
		className,
		classNames,
		description: localization.ORGANIZATION_SLUG_DESCRIPTION,
		instructions: localization.ORGANIZATION_SLUG_INSTRUCTIONS,
		isPending: true,
		title: localization.ORGANIZATION_SLUG,
		actionLabel: localization.SAVE,
		...props,
		children: /* @__PURE__ */ jsx(CardContent, {
			className: classNames == null ? void 0 : classNames.content,
			children: /* @__PURE__ */ jsx(Skeleton, { className: cn("h-9 w-full", classNames == null ? void 0 : classNames.skeleton) })
		})
	});
	return /* @__PURE__ */ jsx(OrganizationSlugForm, {
		className,
		classNames,
		localization,
		organization,
		...props
	});
}
function OrganizationSlugForm({ className, classNames, localization: localizationProp, organization, ...props }) {
	const { localization: contextLocalization, hooks: { useHasPermission }, mutators: { updateOrganization }, optimistic, toast: toast$1, organization: organizationOptions, replace, localizeErrors } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const { refetch: refetchOrganization } = useCurrentOrganization({ slug: organization.slug });
	const { data: hasPermission, isPending } = useHasPermission({
		organizationId: organization.id,
		permissions: { organization: ["update"] }
	});
	const form = useForm({
		resolver: zodResolver(z$1.object({ slug: z$1.string().min(1, { message: `${localization.ORGANIZATION_SLUG} ${localization.IS_REQUIRED}` }).regex(/^[a-z0-9-]+$/, { message: `${localization.ORGANIZATION_SLUG} ${localization.IS_INVALID}` }) })),
		values: { slug: organization.slug || "" }
	});
	const { isSubmitting } = form.formState;
	const updateOrganizationSlug = async ({ slug }) => {
		if (organization.slug === slug) {
			toast$1({
				variant: "error",
				message: `${localization.ORGANIZATION_SLUG} ${localization.IS_THE_SAME}`
			});
			return;
		}
		try {
			await updateOrganization({
				organizationId: organization.id,
				data: { slug }
			});
			await (refetchOrganization == null ? void 0 : refetchOrganization());
			toast$1({
				variant: "success",
				message: `${localization.ORGANIZATION_SLUG} ${localization.UPDATED_SUCCESSFULLY}`
			});
			if ((organizationOptions == null ? void 0 : organizationOptions.pathMode) === "slug") {
				const basePath = organizationOptions.basePath;
				const settingsPath = organizationOptions.viewPaths.SETTINGS;
				replace(`${basePath}/${slug}/${settingsPath}`);
			}
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		}
	};
	return /* @__PURE__ */ jsx(Form, {
		...form,
		children: /* @__PURE__ */ jsx("form", {
			onSubmit: form.handleSubmit(updateOrganizationSlug),
			children: /* @__PURE__ */ jsx(SettingsCard, {
				className,
				classNames,
				description: localization.ORGANIZATION_SLUG_DESCRIPTION,
				instructions: localization.ORGANIZATION_SLUG_INSTRUCTIONS,
				isPending,
				title: localization.ORGANIZATION_SLUG,
				actionLabel: localization.SAVE,
				optimistic,
				disabled: !(hasPermission == null ? void 0 : hasPermission.success),
				...props,
				children: /* @__PURE__ */ jsx(CardContent, {
					className: classNames == null ? void 0 : classNames.content,
					children: isPending ? /* @__PURE__ */ jsx(Skeleton, { className: cn("h-9 w-full", classNames == null ? void 0 : classNames.skeleton) }) : /* @__PURE__ */ jsx(FormField, {
						control: form.control,
						name: "slug",
						render: ({ field }) => /* @__PURE__ */ jsxs(FormItem, { children: [/* @__PURE__ */ jsx(FormControl, { children: /* @__PURE__ */ jsx(Input, {
							className: classNames == null ? void 0 : classNames.input,
							placeholder: localization.ORGANIZATION_SLUG_PLACEHOLDER,
							disabled: isSubmitting || !(hasPermission == null ? void 0 : hasPermission.success),
							...field
						}) }), /* @__PURE__ */ jsx(FormMessage, { className: classNames == null ? void 0 : classNames.error })] })
					})
				})
			})
		})
	});
}
function OrganizationSettingsCards({ className, classNames, localization, slug }) {
	const { organization: organizationOptions } = useContext(AuthUIContext);
	return /* @__PURE__ */ jsxs("div", {
		className: cn("flex w-full flex-col gap-4 md:gap-6", className, classNames == null ? void 0 : classNames.cards),
		children: [
			(organizationOptions == null ? void 0 : organizationOptions.logo) && /* @__PURE__ */ jsx(OrganizationLogoCard, {
				classNames: classNames == null ? void 0 : classNames.card,
				localization,
				slug
			}),
			/* @__PURE__ */ jsx(OrganizationNameCard, {
				classNames: classNames == null ? void 0 : classNames.card,
				localization,
				slug
			}),
			/* @__PURE__ */ jsx(OrganizationSlugCard, {
				classNames: classNames == null ? void 0 : classNames.card,
				localization,
				slug
			}),
			/* @__PURE__ */ jsx(DeleteOrganizationCard, {
				classNames: classNames == null ? void 0 : classNames.card,
				localization,
				slug
			})
		]
	});
}
function OrganizationSwitcher({ className, classNames, align, alignOffset, side, sideOffset, trigger, localization: localizationProp, slug: slugProp, size, onSetActive, hidePersonal, ...props }) {
	var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
	const { authClient: authClient2, basePath, hooks: { useSession, useListOrganizations }, localization: contextLocalization, account: accountOptions, organization: organizationOptions, redirectTo, navigate, toast: toast$1, viewPaths, Link, localizeErrors } = useContext(AuthUIContext);
	const { pathMode, slug: contextSlug, personalPath } = organizationOptions || {};
	const slug = slugProp || contextSlug;
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const [activeOrganizationPending, setActiveOrganizationPending] = useState(false);
	const [isCreateOrgDialogOpen, setIsCreateOrgDialogOpen] = useState(false);
	const [dropdownOpen, setDropdownOpen] = useState(false);
	const { data: sessionData, isPending: sessionPending } = useSession();
	const user = sessionData == null ? void 0 : sessionData.user;
	const { data: organizations, isPending: organizationsPending } = useListOrganizations();
	const { data: activeOrganization, isPending: organizationPending, isRefetching: organizationRefetching, refetch: organizationRefetch } = useCurrentOrganization({ slug });
	const isPending = organizationsPending || sessionPending || activeOrganizationPending || organizationPending;
	useEffect(() => {
		if (organizationRefetching) return;
		setActiveOrganizationPending(false);
	}, [activeOrganization, organizationRefetching]);
	const switchOrganization = useCallback(async (organization) => {
		if (hidePersonal && organization === null) return;
		if (pathMode === "slug") {
			if (organization) navigate(`${organizationOptions == null ? void 0 : organizationOptions.basePath}/${organization.slug}`);
			else navigate(personalPath ?? redirectTo);
			return;
		}
		setActiveOrganizationPending(true);
		try {
			onSetActive?.(organization);
			await authClient2.organization.setActive({
				organizationId: (organization == null ? void 0 : organization.id) || null,
				fetchOptions: { throw: true }
			});
			organizationRefetch?.();
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
			setActiveOrganizationPending(false);
		}
	}, [
		authClient2,
		toast$1,
		localization,
		localizeErrors,
		onSetActive,
		hidePersonal,
		pathMode,
		personalPath,
		organizationOptions == null ? void 0 : organizationOptions.basePath,
		redirectTo,
		navigate,
		organizationRefetch
	]);
	useEffect(() => {
		if (hidePersonal && !activeOrganization && !activeOrganizationPending && organizations && organizations.length > 0 && !sessionPending && !organizationPending && !slug) switchOrganization(organizations[0]);
	}, [
		hidePersonal,
		activeOrganization,
		activeOrganizationPending,
		organizations,
		sessionPending,
		organizationPending,
		switchOrganization,
		slug
	]);
	return /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsxs(DropdownMenu, {
		open: dropdownOpen,
		onOpenChange: setDropdownOpen,
		children: [/* @__PURE__ */ jsx(DropdownMenuTrigger, {
			asChild: true,
			children: trigger || (size === "icon" ? /* @__PURE__ */ jsx(Button, {
				size: "icon",
				className: cn("size-fit rounded-full", className, (_a = classNames == null ? void 0 : classNames.trigger) == null ? void 0 : _a.base),
				variant: "ghost",
				type: "button",
				...props,
				children: isPending || activeOrganization || !sessionData || (user == null ? void 0 : user.isAnonymous) || hidePersonal ? /* @__PURE__ */ jsx(OrganizationLogo, {
					className: cn(className, classNames == null ? void 0 : classNames.base),
					classNames: (_b = classNames == null ? void 0 : classNames.trigger) == null ? void 0 : _b.avatar,
					isPending,
					organization: activeOrganization,
					"aria-label": localization.ORGANIZATION,
					localization
				}, activeOrganization == null ? void 0 : activeOrganization.logo) : /* @__PURE__ */ jsx(UserAvatar, {
					className: cn(className, classNames == null ? void 0 : classNames.base),
					classNames: (_c = classNames == null ? void 0 : classNames.trigger) == null ? void 0 : _c.avatar,
					user,
					"aria-label": localization.ACCOUNT,
					localization
				}, user == null ? void 0 : user.image)
			}) : /* @__PURE__ */ jsxs(Button, {
				className: cn("!p-2 h-fit", className, (_d = classNames == null ? void 0 : classNames.trigger) == null ? void 0 : _d.base),
				size,
				...props,
				children: [isPending || activeOrganization || !sessionData || (user == null ? void 0 : user.isAnonymous) || hidePersonal ? /* @__PURE__ */ jsx(OrganizationCellView, {
					classNames: (_e = classNames == null ? void 0 : classNames.trigger) == null ? void 0 : _e.organization,
					isPending,
					localization,
					organization: activeOrganization,
					size
				}) : /* @__PURE__ */ jsx(PersonalAccountView, {
					classNames: (_f = classNames == null ? void 0 : classNames.trigger) == null ? void 0 : _f.user,
					localization,
					size,
					user
				}), /* @__PURE__ */ jsx(ChevronsUpDown, { className: "ml-auto" })]
			}))
		}), /* @__PURE__ */ jsxs(DropdownMenuContent, {
			className: cn("w-[--radix-dropdown-menu-trigger-width] min-w-56 max-w-64", (_g = classNames == null ? void 0 : classNames.content) == null ? void 0 : _g.base),
			align,
			alignOffset,
			side,
			sideOffset,
			onCloseAutoFocus: (e) => e.preventDefault(),
			children: [
				/* @__PURE__ */ jsx("div", {
					className: cn("flex items-center justify-between gap-2 p-2", (_h = classNames == null ? void 0 : classNames.content) == null ? void 0 : _h.menuItem),
					children: user && !user.isAnonymous || isPending ? /* @__PURE__ */ jsxs(Fragment$1, { children: [activeOrganizationPending || activeOrganization || hidePersonal ? /* @__PURE__ */ jsx(OrganizationCellView, {
						classNames: (_i = classNames == null ? void 0 : classNames.content) == null ? void 0 : _i.organization,
						isPending: isPending || activeOrganizationPending,
						organization: activeOrganization,
						localization
					}) : /* @__PURE__ */ jsx(PersonalAccountView, {
						classNames: (_j = classNames == null ? void 0 : classNames.content) == null ? void 0 : _j.user,
						isPending,
						localization,
						user
					}), !isPending && /* @__PURE__ */ jsx(Link, {
						href: activeOrganization ? pathMode === "slug" ? `${organizationOptions == null ? void 0 : organizationOptions.basePath}/${activeOrganization.slug}/${organizationOptions == null ? void 0 : organizationOptions.viewPaths.SETTINGS}` : `${organizationOptions == null ? void 0 : organizationOptions.basePath}/${organizationOptions == null ? void 0 : organizationOptions.viewPaths.SETTINGS}` : `${accountOptions == null ? void 0 : accountOptions.basePath}/${accountOptions == null ? void 0 : accountOptions.viewPaths.SETTINGS}`,
						children: /* @__PURE__ */ jsx(Button, {
							size: "icon",
							variant: "outline",
							className: "!size-8 ml-auto",
							onClick: () => setDropdownOpen(false),
							children: /* @__PURE__ */ jsx(SettingsIcon, { className: "size-4" })
						})
					})] }) : /* @__PURE__ */ jsx("div", {
						className: "-my-1 text-muted-foreground text-xs",
						children: localization.ORGANIZATION
					})
				}),
				/* @__PURE__ */ jsx(DropdownMenuSeparator, { className: (_k = classNames == null ? void 0 : classNames.content) == null ? void 0 : _k.separator }),
				activeOrganization && !hidePersonal && (pathMode === "slug" ? /* @__PURE__ */ jsx(Link, {
					href: personalPath ?? redirectTo,
					children: /* @__PURE__ */ jsx(DropdownMenuItem, { children: /* @__PURE__ */ jsx(PersonalAccountView, {
						classNames: (_l = classNames == null ? void 0 : classNames.content) == null ? void 0 : _l.user,
						isPending,
						localization,
						user
					}) })
				}) : /* @__PURE__ */ jsx(DropdownMenuItem, {
					onClick: () => switchOrganization(null),
					children: /* @__PURE__ */ jsx(PersonalAccountView, {
						classNames: (_m = classNames == null ? void 0 : classNames.content) == null ? void 0 : _m.user,
						isPending,
						localization,
						user
					})
				})),
				organizations == null ? void 0 : organizations.map((organization) => {
					var _a2, _b2;
					return organization.id !== (activeOrganization == null ? void 0 : activeOrganization.id) && (pathMode === "slug" ? /* @__PURE__ */ jsx(Link, {
						href: `${organizationOptions == null ? void 0 : organizationOptions.basePath}/${organization.slug}`,
						children: /* @__PURE__ */ jsx(DropdownMenuItem, { children: /* @__PURE__ */ jsx(OrganizationCellView, {
							classNames: (_a2 = classNames == null ? void 0 : classNames.content) == null ? void 0 : _a2.organization,
							isPending,
							localization,
							organization
						}) })
					}, organization.id) : /* @__PURE__ */ jsx(DropdownMenuItem, {
						onClick: () => switchOrganization(organization),
						children: /* @__PURE__ */ jsx(OrganizationCellView, {
							classNames: (_b2 = classNames == null ? void 0 : classNames.content) == null ? void 0 : _b2.organization,
							isPending,
							localization,
							organization
						})
					}, organization.id));
				}),
				organizations && organizations.length > 0 && (!hidePersonal || organizations.length > 1) && /* @__PURE__ */ jsx(DropdownMenuSeparator, { className: (_n = classNames == null ? void 0 : classNames.content) == null ? void 0 : _n.separator }),
				!isPending && sessionData && !user.isAnonymous ? /* @__PURE__ */ jsxs(DropdownMenuItem, {
					className: cn((_o = classNames == null ? void 0 : classNames.content) == null ? void 0 : _o.menuItem),
					onClick: () => setIsCreateOrgDialogOpen(true),
					children: [/* @__PURE__ */ jsx(PlusCircleIcon, {}), localization.CREATE_ORGANIZATION]
				}) : /* @__PURE__ */ jsx(Link, {
					href: `${basePath}/${viewPaths.SIGN_IN}`,
					children: /* @__PURE__ */ jsxs(DropdownMenuItem, {
						className: cn((_p = classNames == null ? void 0 : classNames.content) == null ? void 0 : _p.menuItem),
						children: [/* @__PURE__ */ jsx(LogInIcon, {}), localization.SIGN_IN]
					})
				})
			]
		})]
	}), /* @__PURE__ */ jsx(CreateOrganizationDialog, {
		open: isCreateOrgDialogOpen,
		onOpenChange: setIsCreateOrgDialogOpen,
		localization
	})] });
}
var fieldVariants = cva("group/field flex w-full gap-3 data-[invalid=true]:text-destructive", {
	variants: { orientation: {
		vertical: ["flex-col [&>*]:w-full [&>.sr-only]:w-auto"],
		horizontal: [
			"flex-row items-center",
			"[&>[data-slot=field-label]]:flex-auto",
			"has-[>[data-slot=field-content]]:items-start has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px"
		],
		responsive: [
			"flex-col [&>*]:w-full [&>.sr-only]:w-auto @md/field-group:flex-row @md/field-group:items-center @md/field-group:[&>*]:w-auto",
			"@md/field-group:[&>[data-slot=field-label]]:flex-auto",
			"@md/field-group:has-[>[data-slot=field-content]]:items-start @md/field-group:has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px"
		]
	} },
	defaultVariants: { orientation: "vertical" }
});
function Field({ className, orientation = "vertical", ...props }) {
	return /* @__PURE__ */ jsx("div", {
		role: "group",
		"data-slot": "field",
		"data-orientation": orientation,
		className: cn(fieldVariants({ orientation }), className),
		...props
	});
}
function FieldLabel({ className, ...props }) {
	return /* @__PURE__ */ jsx(Label2, {
		"data-slot": "field-label",
		className: cn("group/field-label peer/field-label flex w-fit gap-2 leading-snug group-data-[disabled=true]/field:opacity-50", "has-[>[data-slot=field]]:w-full has-[>[data-slot=field]]:flex-col has-[>[data-slot=field]]:rounded-md has-[>[data-slot=field]]:border [&>*]:data-[slot=field]:p-4", "has-data-[state=checked]:bg-primary/5 has-data-[state=checked]:border-primary dark:has-data-[state=checked]:bg-primary/10", className),
		...props
	});
}
function UpdateTeamDialog({ classNames, team, localization: localizationProp, refetch, onOpenChange, ...props }) {
	var _a, _b, _c;
	const { authClient: authClient2, localization: contextLocalization, toast: toast$1, localizeErrors } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const [isUpdating, setIsUpdating] = useState(false);
	const [name, setName] = useState(team.name);
	const handleUpdate = async () => {
		try {
			setIsUpdating(true);
			await authClient2.organization.updateTeam({
				teamId: team.id,
				data: { name },
				fetchOptions: { throw: true }
			});
			toast$1({
				variant: "success",
				message: localization.UPDATE_TEAM_SUCCESS
			});
			await (refetch == null ? void 0 : refetch());
			onOpenChange?.(false);
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
		} finally {
			setIsUpdating(false);
		}
	};
	return /* @__PURE__ */ jsx(Dialog, {
		onOpenChange,
		...props,
		children: /* @__PURE__ */ jsxs(DialogContent, {
			className: (_a = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _a.content,
			onOpenAutoFocus: (e) => e.preventDefault(),
			children: [
				/* @__PURE__ */ jsxs(DialogHeader, {
					className: (_b = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _b.header,
					children: [/* @__PURE__ */ jsx(DialogTitle, {
						className: cn("text-lg md:text-xl", classNames == null ? void 0 : classNames.title),
						children: localization.UPDATE_TEAM
					}), /* @__PURE__ */ jsx(DialogDescription, {
						className: cn("text-xs md:text-sm", classNames == null ? void 0 : classNames.description),
						children: localization.UPDATE_TEAM_DESCRIPTION
					})]
				}),
				/* @__PURE__ */ jsxs(Card, {
					className: cn("my-2 flex-row items-center gap-3 px-4 py-3", classNames == null ? void 0 : classNames.cell),
					children: [/* @__PURE__ */ jsx(UsersIcon, { className: cn("size-5 flex-shrink-0", classNames == null ? void 0 : classNames.icon) }), /* @__PURE__ */ jsxs("div", {
						className: "flex flex-col truncate",
						children: [/* @__PURE__ */ jsx("div", {
							className: "flex items-center gap-2",
							children: /* @__PURE__ */ jsx("span", {
								className: "truncate font-semibold text-sm",
								children: team.name
							})
						}), /* @__PURE__ */ jsx("div", {
							className: "truncate text-muted-foreground text-xs",
							children: localization == null ? void 0 : localization.TEAM
						})]
					})]
				}),
				/* @__PURE__ */ jsxs(Field, {
					className: "grid gap-2",
					children: [/* @__PURE__ */ jsx(FieldLabel, {
						htmlFor: "name",
						children: localization.TEAM_NAME
					}), /* @__PURE__ */ jsx(Input, {
						id: "name",
						onChange: (e) => setName(e.target.value),
						placeholder: localization.TEAM_NAME_PLACEHOLDER,
						required: true,
						value: name
					})]
				}),
				/* @__PURE__ */ jsxs(DialogFooter, {
					className: (_c = classNames == null ? void 0 : classNames.dialog) == null ? void 0 : _c.footer,
					children: [/* @__PURE__ */ jsx(Button, {
						className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.secondaryButton),
						disabled: isUpdating,
						onClick: () => onOpenChange == null ? void 0 : onOpenChange(false),
						type: "button",
						variant: "secondary",
						children: localization.CANCEL
					}), /* @__PURE__ */ jsxs(Button, {
						className: cn(classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.primaryButton),
						disabled: isUpdating || name.trim().length === 0,
						onClick: handleUpdate,
						type: "button",
						children: [isUpdating && /* @__PURE__ */ jsx(Loader2, { className: "animate-spin" }), localization.UPDATE]
					})]
				})
			]
		})
	});
}
function TeamCell({ className, classNames, team, localization, canDelete, canUpdate, refetch }) {
	const [showDeleteDialog, setShowDeleteDialog] = useState(false);
	const [showUpdateDialog, setShowUpdateDialog] = useState(false);
	return /* @__PURE__ */ jsxs(Fragment$1, { children: [
		/* @__PURE__ */ jsxs(Card, {
			className: cn("flex-row items-center gap-3 truncate px-4 py-3", className, classNames == null ? void 0 : classNames.cell),
			children: [
				/* @__PURE__ */ jsx(UsersIcon, { className: cn("size-5 flex-shrink-0", classNames == null ? void 0 : classNames.icon) }),
				/* @__PURE__ */ jsxs("div", {
					className: "flex flex-col truncate",
					children: [/* @__PURE__ */ jsx("div", {
						className: "flex items-center gap-2",
						children: /* @__PURE__ */ jsx("span", {
							className: "truncate font-semibold text-sm",
							children: team.name
						})
					}), /* @__PURE__ */ jsx("div", {
						className: "truncate text-muted-foreground text-xs",
						children: localization == null ? void 0 : localization.TEAM
					})]
				}),
				/* @__PURE__ */ jsxs(DropdownMenu, { children: [/* @__PURE__ */ jsx(DropdownMenuTrigger, {
					asChild: true,
					children: /* @__PURE__ */ jsx(Button, {
						className: cn("relative ms-auto", classNames == null ? void 0 : classNames.button, classNames == null ? void 0 : classNames.outlineButton),
						size: "icon",
						type: "button",
						variant: "outline",
						children: /* @__PURE__ */ jsx(EllipsisIcon, { className: classNames == null ? void 0 : classNames.icon })
					})
				}), /* @__PURE__ */ jsxs(DropdownMenuContent, {
					onCloseAutoFocus: (e) => e.preventDefault(),
					children: [/* @__PURE__ */ jsxs(DropdownMenuItem, {
						disabled: !canUpdate,
						onSelect: () => setShowUpdateDialog(true),
						children: [/* @__PURE__ */ jsx(Edit, { className: classNames == null ? void 0 : classNames.icon }), /* @__PURE__ */ jsxs("span", { children: [" ", localization == null ? void 0 : localization.UPDATE_TEAM] })]
					}), /* @__PURE__ */ jsxs(DropdownMenuItem, {
						disabled: !canDelete,
						onClick: () => setShowDeleteDialog(true),
						variant: "destructive",
						children: [/* @__PURE__ */ jsx(Archive, { className: classNames == null ? void 0 : classNames.icon }), /* @__PURE__ */ jsx("span", { children: localization == null ? void 0 : localization.DELETE_TEAM })]
					})]
				})] })
			]
		}),
		/* @__PURE__ */ jsx(UpdateTeamDialog, {
			classNames,
			localization,
			onOpenChange: setShowUpdateDialog,
			open: showUpdateDialog,
			refetch,
			team
		}),
		/* @__PURE__ */ jsx(DeleteTeamDialog, {
			classNames,
			localization,
			onOpenChange: setShowDeleteDialog,
			open: showDeleteDialog,
			refetch,
			team
		})
	] });
}
function TeamsCard({ className, classNames, localization, organizationId, ...props }) {
	const { hooks: { useHasPermission, useListTeams }, localization: contextLocalization } = useContext(AuthUIContext);
	localization = useMemo(() => ({
		...contextLocalization,
		...localization
	}), [contextLocalization, localization]);
	const isHydrated = useIsHydrated();
	const [createDialogOpen, setCreateDialogOpen] = useState(false);
	const { data: hasPermissionCreate, isPending: permissionCreatePending } = useHasPermission({
		organizationId,
		permissions: { team: ["create"] }
	});
	const { data: hasPermissionUpdate, isPending: permissionUpdatePending } = useHasPermission({
		organizationId,
		permissions: { team: ["update"] }
	});
	const { data: hasPermissionDelete, isPending: permissionDeletePending } = useHasPermission({
		organizationId,
		permissions: { team: ["delete"] }
	});
	const { data: teams, isPending: teamsPending, refetch } = useListTeams({ organizationId });
	const isPending = !isHydrated || permissionCreatePending || permissionUpdatePending || permissionDeletePending || teamsPending;
	return /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(SettingsCard, {
		action: () => setCreateDialogOpen(true),
		actionLabel: localization.CREATE_TEAM,
		className,
		classNames,
		description: localization.TEAMS_DESCRIPTION,
		disabled: !(hasPermissionCreate == null ? void 0 : hasPermissionCreate.success),
		instructions: localization.CREATE_TEAM_INSTRUCTIONS,
		isPending,
		title: localization.TEAMS,
		...props,
		children: /* @__PURE__ */ jsx(CardContent, {
			className: cn("grid gap-4", classNames == null ? void 0 : classNames.content),
			children: isPending ? /* @__PURE__ */ jsx(SettingsCellSkeleton, {}) : teams && teams.length > 0 ? teams.sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()).map((team) => /* @__PURE__ */ jsx(TeamCell, {
				canDelete: !!(hasPermissionDelete == null ? void 0 : hasPermissionDelete.success),
				canUpdate: !!(hasPermissionUpdate == null ? void 0 : hasPermissionUpdate.success),
				classNames,
				localization,
				refetch,
				team
			}, team.id)) : /* @__PURE__ */ jsx("p", {
				className: "text-muted-foreground text-sm",
				children: localization.NO_TEAMS_FOUND
			})
		})
	}), /* @__PURE__ */ jsx(CreateTeamDialog, {
		classNames,
		localization,
		onOpenChange: setCreateDialogOpen,
		open: createDialogOpen,
		organizationId,
		refetch
	})] });
}
function OrganizationView({ className, classNames, localization: localizationProp, path: pathProp, pathname, view: viewProp, hideNav, slug: slugProp }) {
	var _a, _b, _c;
	const { teams: teamOptions, organization: organizationOptions, localization: contextLocalization, account: accountOptions, Link, replace } = useContext(AuthUIContext);
	const { slug: contextSlug, viewPaths, apiKey } = organizationOptions || {};
	const { enabled: teamsEnabled } = teamOptions || {};
	useAuthenticate();
	const localization = useMemo(() => ({
		...contextLocalization,
		...localizationProp
	}), [contextLocalization, localizationProp]);
	const path = pathProp ?? (pathname == null ? void 0 : pathname.split("/").pop());
	const view = viewProp || getViewByPath(viewPaths, path) || "SETTINGS";
	const slug = slugProp || contextSlug;
	const { data: organization, isPending: organizationPending, isRefetching: organizationRefetching } = useCurrentOrganization({ slug });
	const navItems = [{
		view: "SETTINGS",
		label: localization.SETTINGS
	}, {
		view: "MEMBERS",
		label: localization.MEMBERS
	}];
	if (teamsEnabled) navItems.push({
		view: "TEAMS",
		label: localization.TEAMS
	});
	if (apiKey) navItems.push({
		view: "API_KEYS",
		label: localization.API_KEYS
	});
	useEffect(() => {
		var _a2;
		if (organization || organizationPending || organizationRefetching) return;
		replace(`${accountOptions == null ? void 0 : accountOptions.basePath}/${(_a2 = accountOptions == null ? void 0 : accountOptions.viewPaths) == null ? void 0 : _a2.ORGANIZATIONS}`);
	}, [
		organization,
		organizationPending,
		organizationRefetching,
		accountOptions == null ? void 0 : accountOptions.basePath,
		(_a = accountOptions == null ? void 0 : accountOptions.viewPaths) == null ? void 0 : _a.ORGANIZATIONS,
		replace
	]);
	return /* @__PURE__ */ jsxs("div", {
		className: cn("flex w-full grow flex-col gap-4 md:flex-row md:gap-12", className, classNames == null ? void 0 : classNames.base),
		children: [
			!hideNav && /* @__PURE__ */ jsxs("div", {
				className: "flex justify-between gap-2 md:hidden",
				children: [/* @__PURE__ */ jsx(Label2, {
					className: "font-semibold text-base",
					children: (_b = navItems.find((i) => i.view === view)) == null ? void 0 : _b.label
				}), /* @__PURE__ */ jsxs(Drawer$1, { children: [/* @__PURE__ */ jsx(DrawerTrigger, {
					asChild: true,
					children: /* @__PURE__ */ jsx(Button, {
						variant: "outline",
						children: /* @__PURE__ */ jsx(MenuIcon, {})
					})
				}), /* @__PURE__ */ jsxs(DrawerContent, { children: [/* @__PURE__ */ jsx(DrawerHeader, { children: /* @__PURE__ */ jsx(DrawerTitle, {
					className: "hidden",
					children: localization.ORGANIZATION
				}) }), /* @__PURE__ */ jsx("div", {
					className: "flex flex-col px-4 pb-4",
					children: navItems.map((item) => {
						var _a2;
						return /* @__PURE__ */ jsx(Link, {
							href: `${organizationOptions == null ? void 0 : organizationOptions.basePath}${(organizationOptions == null ? void 0 : organizationOptions.pathMode) === "slug" ? `/${slug}` : ""}/${organizationOptions == null ? void 0 : organizationOptions.viewPaths[item.view]}`,
							children: /* @__PURE__ */ jsx(Button, {
								size: "lg",
								className: cn("w-full justify-start px-4 transition-none", (_a2 = classNames == null ? void 0 : classNames.drawer) == null ? void 0 : _a2.menuItem, view === item.view ? "font-semibold" : "text-foreground/70"),
								variant: "ghost",
								children: item.label
							})
						}, item.view);
					})
				})] })] })]
			}),
			!hideNav && /* @__PURE__ */ jsx("div", {
				className: "hidden md:block",
				children: /* @__PURE__ */ jsx("div", {
					className: cn("flex w-48 flex-col gap-1 lg:w-60", (_c = classNames == null ? void 0 : classNames.sidebar) == null ? void 0 : _c.base),
					children: navItems.map((item) => {
						var _a2, _b2;
						return /* @__PURE__ */ jsx(Link, {
							href: `${organizationOptions == null ? void 0 : organizationOptions.basePath}${(organizationOptions == null ? void 0 : organizationOptions.pathMode) === "slug" ? `/${slug}` : ""}/${organizationOptions == null ? void 0 : organizationOptions.viewPaths[item.view]}`,
							children: /* @__PURE__ */ jsx(Button, {
								size: "lg",
								className: cn("w-full justify-start px-4 transition-none", (_a2 = classNames == null ? void 0 : classNames.sidebar) == null ? void 0 : _a2.button, view === item.view ? "font-semibold" : "text-foreground/70", view === item.view && ((_b2 = classNames == null ? void 0 : classNames.sidebar) == null ? void 0 : _b2.buttonActive)),
								variant: "ghost",
								children: item.label
							})
						}, item.view);
					})
				})
			}),
			view === "MEMBERS" && /* @__PURE__ */ jsxs("div", {
				className: cn("flex w-full flex-col gap-4 md:gap-6", className, classNames == null ? void 0 : classNames.cards),
				children: [/* @__PURE__ */ jsx(OrganizationMembersCard, {
					classNames: classNames == null ? void 0 : classNames.card,
					localization,
					slug
				}), /* @__PURE__ */ jsx(OrganizationInvitationsCard, {
					classNames: classNames == null ? void 0 : classNames.card,
					localization,
					slug
				})]
			}),
			view === "TEAMS" && (organization == null ? void 0 : organization.id) && teamsEnabled && /* @__PURE__ */ jsx(TeamsCard, {
				classNames,
				localization,
				organizationId: organization.id
			}),
			view === "API_KEYS" && /* @__PURE__ */ jsx(ApiKeysCard, {
				classNames: classNames == null ? void 0 : classNames.card,
				localization,
				isPending: organizationPending,
				organizationId: organization == null ? void 0 : organization.id
			}),
			view === "SETTINGS" && /* @__PURE__ */ jsx(OrganizationSettingsCards, {
				classNames,
				localization,
				slug
			})
		]
	});
}
function RedirectToSignIn() {
	useAuthenticate({ authView: "SIGN_IN" });
	return null;
}
function RedirectToSignUp() {
	useAuthenticate({ authView: "SIGN_UP" });
	return null;
}
function SignedIn({ children }) {
	const { hooks: { useSession } } = useContext(AuthUIContext);
	const { data } = useSession();
	return data ? children : null;
}
function SignedOut({ children }) {
	const { hooks: { useSession } } = useContext(AuthUIContext);
	const { data, isPending } = useSession();
	return !data && !isPending ? children : null;
}
function UserButton({ className, classNames, align, alignOffset, side, sideOffset, trigger, additionalLinks, disableDefaultLinks, localization: propLocalization, size, ...props }) {
	var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
	const { basePath, hooks: { useSession, useListDeviceSessions }, mutators: { setActiveSession }, localization: contextLocalization, multiSession, account: accountOptions, signUp, toast: toast$1, viewPaths, onSessionChange, Link, localizeErrors } = useContext(AuthUIContext);
	const localization = useMemo(() => ({
		...contextLocalization,
		...propLocalization
	}), [contextLocalization, propLocalization]);
	let deviceSessions = null;
	let deviceSessionsPending = false;
	if (multiSession) {
		const { data, isPending: isPending2 } = useListDeviceSessions();
		deviceSessions = data;
		deviceSessionsPending = isPending2;
	}
	const { data: sessionData, isPending: sessionPending } = useSession();
	const user = sessionData == null ? void 0 : sessionData.user;
	const [activeSessionPending, setActiveSessionPending] = useState(false);
	const isHydrated = useIsHydrated();
	const isPending = sessionPending || activeSessionPending || !isHydrated;
	const switchAccount = useCallback(async (sessionToken) => {
		setActiveSessionPending(true);
		try {
			await setActiveSession({ sessionToken });
			onSessionChange?.();
		} catch (error) {
			toast$1({
				variant: "error",
				message: getLocalizedError({
					error,
					localization,
					localizeErrors
				})
			});
			setActiveSessionPending(false);
		}
	}, [
		setActiveSession,
		onSessionChange,
		toast$1,
		localization,
		localizeErrors
	]);
	useEffect(() => {
		if (!multiSession) return;
		setActiveSessionPending(false);
	}, [sessionData, multiSession]);
	const warningLogged = useRef(false);
	useEffect(() => {
		if (size || warningLogged.current) return;
		console.warn("[Better Auth UI] The `size` prop of `UserButton` no longer defaults to `icon`. Please pass `size='icon'` to the `UserButton` component to get the same behaviour as before. This warning will be removed in a future release. It can be suppressed in the meantime by defining the `size` prop.");
		warningLogged.current = true;
	}, [size]);
	return /* @__PURE__ */ jsxs(DropdownMenu, { children: [/* @__PURE__ */ jsx(DropdownMenuTrigger, {
		asChild: true,
		className: cn(size === "icon" && "rounded-full", (_a = classNames == null ? void 0 : classNames.trigger) == null ? void 0 : _a.base),
		children: trigger || (size === "icon" ? /* @__PURE__ */ jsx(Button, {
			size: "icon",
			className: "size-fit rounded-full",
			variant: "ghost",
			children: /* @__PURE__ */ jsx(UserAvatar, {
				isPending,
				className: cn(className, classNames == null ? void 0 : classNames.base),
				classNames: (_b = classNames == null ? void 0 : classNames.trigger) == null ? void 0 : _b.avatar,
				user,
				"aria-label": localization.ACCOUNT,
				localization
			}, user == null ? void 0 : user.image)
		}) : /* @__PURE__ */ jsxs(Button, {
			className: cn("!p-2 h-fit", className, (_c = classNames == null ? void 0 : classNames.trigger) == null ? void 0 : _c.base),
			size,
			...props,
			children: [/* @__PURE__ */ jsx(UserView, {
				size,
				user: !(user == null ? void 0 : user.isAnonymous) ? user : null,
				isPending,
				classNames: (_d = classNames == null ? void 0 : classNames.trigger) == null ? void 0 : _d.user,
				localization
			}), /* @__PURE__ */ jsx(ChevronsUpDown, { className: "ml-auto" })]
		}))
	}), /* @__PURE__ */ jsxs(DropdownMenuContent, {
		className: cn("w-[--radix-dropdown-menu-trigger-width] min-w-56 max-w-64", (_e = classNames == null ? void 0 : classNames.content) == null ? void 0 : _e.base),
		align,
		alignOffset,
		side,
		sideOffset,
		onCloseAutoFocus: (e) => e.preventDefault(),
		children: [
			/* @__PURE__ */ jsx("div", {
				className: cn("p-2", (_f = classNames == null ? void 0 : classNames.content) == null ? void 0 : _f.menuItem),
				children: user && !user.isAnonymous || isPending ? /* @__PURE__ */ jsx(UserView, {
					user,
					isPending,
					classNames: (_g = classNames == null ? void 0 : classNames.content) == null ? void 0 : _g.user,
					localization
				}) : /* @__PURE__ */ jsx("div", {
					className: "-my-1 text-muted-foreground text-xs",
					children: localization.ACCOUNT
				})
			}),
			/* @__PURE__ */ jsx(DropdownMenuSeparator, { className: (_h = classNames == null ? void 0 : classNames.content) == null ? void 0 : _h.separator }),
			additionalLinks == null ? void 0 : additionalLinks.map((link, index) => {
				var _a2, _b2, _c2;
				if (!link || typeof link !== "object" || !("href" in link)) return /* @__PURE__ */ jsx(DropdownMenuItem, {
					className: (_a2 = classNames == null ? void 0 : classNames.content) == null ? void 0 : _a2.menuItem,
					asChild: true,
					children: link
				}, index);
				const { href, icon, label, signedIn, separator } = link;
				if (signedIn !== void 0 && (signedIn && !sessionData || !signedIn && sessionData)) return null;
				return /* @__PURE__ */ jsxs(Fragment, { children: [/* @__PURE__ */ jsx(Link, {
					href,
					children: /* @__PURE__ */ jsxs(DropdownMenuItem, {
						className: (_b2 = classNames == null ? void 0 : classNames.content) == null ? void 0 : _b2.menuItem,
						children: [icon, label]
					})
				}), separator && /* @__PURE__ */ jsx(DropdownMenuSeparator, { className: (_c2 = classNames == null ? void 0 : classNames.content) == null ? void 0 : _c2.separator })] }, index);
			}),
			!user || user.isAnonymous ? /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(Link, {
				href: `${basePath}/${viewPaths.SIGN_IN}`,
				children: /* @__PURE__ */ jsxs(DropdownMenuItem, {
					className: (_i = classNames == null ? void 0 : classNames.content) == null ? void 0 : _i.menuItem,
					children: [/* @__PURE__ */ jsx(LogInIcon, {}), localization.SIGN_IN]
				})
			}), signUp && /* @__PURE__ */ jsx(Link, {
				href: `${basePath}/${viewPaths.SIGN_UP}`,
				children: /* @__PURE__ */ jsxs(DropdownMenuItem, {
					className: (_j = classNames == null ? void 0 : classNames.content) == null ? void 0 : _j.menuItem,
					children: [/* @__PURE__ */ jsx(UserRoundPlus, {}), localization.SIGN_UP]
				})
			})] }) : /* @__PURE__ */ jsxs(Fragment$1, { children: [!disableDefaultLinks && accountOptions && /* @__PURE__ */ jsx(Link, {
				href: `${accountOptions.basePath}/${(_k = accountOptions.viewPaths) == null ? void 0 : _k.SETTINGS}`,
				children: /* @__PURE__ */ jsxs(DropdownMenuItem, {
					className: (_l = classNames == null ? void 0 : classNames.content) == null ? void 0 : _l.menuItem,
					children: [/* @__PURE__ */ jsx(SettingsIcon, {}), localization.SETTINGS]
				})
			}), /* @__PURE__ */ jsx(Link, {
				href: `${basePath}/${viewPaths.SIGN_OUT}`,
				children: /* @__PURE__ */ jsxs(DropdownMenuItem, {
					className: (_m = classNames == null ? void 0 : classNames.content) == null ? void 0 : _m.menuItem,
					children: [/* @__PURE__ */ jsx(LogOutIcon, {}), localization.SIGN_OUT]
				})
			})] }),
			user && multiSession && /* @__PURE__ */ jsxs(Fragment$1, { children: [
				/* @__PURE__ */ jsx(DropdownMenuSeparator, { className: (_n = classNames == null ? void 0 : classNames.content) == null ? void 0 : _n.separator }),
				!deviceSessions && deviceSessionsPending && /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(DropdownMenuItem, {
					disabled: true,
					className: (_o = classNames == null ? void 0 : classNames.content) == null ? void 0 : _o.menuItem,
					children: /* @__PURE__ */ jsx(UserView, {
						isPending: true,
						classNames: (_p = classNames == null ? void 0 : classNames.content) == null ? void 0 : _p.user
					})
				}), /* @__PURE__ */ jsx(DropdownMenuSeparator, { className: (_q = classNames == null ? void 0 : classNames.content) == null ? void 0 : _q.separator })] }),
				deviceSessions == null ? void 0 : deviceSessions.filter((sessionData2) => sessionData2.user.id !== (user == null ? void 0 : user.id)).map(({ session, user: user2 }) => {
					var _a2, _b2, _c2;
					return /* @__PURE__ */ jsxs(Fragment, { children: [/* @__PURE__ */ jsx(DropdownMenuItem, {
						className: (_a2 = classNames == null ? void 0 : classNames.content) == null ? void 0 : _a2.menuItem,
						onClick: () => switchAccount(session.token),
						children: /* @__PURE__ */ jsx(UserView, {
							user: user2,
							classNames: (_b2 = classNames == null ? void 0 : classNames.content) == null ? void 0 : _b2.user
						})
					}), /* @__PURE__ */ jsx(DropdownMenuSeparator, { className: (_c2 = classNames == null ? void 0 : classNames.content) == null ? void 0 : _c2.separator })] }, session.id);
				}),
				/* @__PURE__ */ jsx(Link, {
					href: `${basePath}/${viewPaths.SIGN_IN}`,
					children: /* @__PURE__ */ jsxs(DropdownMenuItem, {
						className: (_r = classNames == null ? void 0 : classNames.content) == null ? void 0 : _r.menuItem,
						children: [/* @__PURE__ */ jsx(PlusCircleIcon, {}), localization.ADD_ACCOUNT]
					})
				})
			] })
		]
	})] });
}
function isVanillaClient(client) {
	return typeof client.useSession !== "function";
}
/**
* Automatically adapt a vanilla better-auth client for React
*
* This function works with Proxy objects by creating a wrapper proxy that:
* 1. Intercepts all property access
* 2. Detects if it's a hook (starts with "use" and is an atom)
* 3. Wraps atoms with useStore for React compatibility
* 4. Passes through everything else unchanged
*/
function toReactClient(vanillaClient) {
	const hookCache = /* @__PURE__ */ new Map();
	return new Proxy(vanillaClient, { get(target, prop, receiver) {
		const value = Reflect.get(target, prop, receiver);
		if (typeof prop === "string" && prop.startsWith("use") && value && typeof value === "object" && "subscribe" in value && "get" in value) {
			if (hookCache.has(prop)) return hookCache.get(prop);
			const reactHook = function useReactHook() {
				return useStore(value);
			};
			hookCache.set(prop, reactHook);
			return reactHook;
		}
		return value;
	} });
}
function getReactClient(client) {
	if (isVanillaClient(client)) return toReactClient(client);
	return client;
}
function cn$1(...inputs) {
	return twMerge(clsx(inputs));
}
function NeonAuthUIProvider({ authClient: authClient$1, children, className, defaultTheme = "system", ...props }) {
	const reactClient = useMemo(() => {
		return "getBetterAuthInstance" in authClient$1 ? getReactClient(authClient$1.getBetterAuthInstance()) : getReactClient(authClient$1);
	}, [authClient$1]);
	return /* @__PURE__ */ jsx("div", {
		className: cn$1("neon-auth-ui", className),
		children: /* @__PURE__ */ jsx(ThemeProvider, {
			attribute: "class",
			defaultTheme,
			enableSystem: true,
			children: /* @__PURE__ */ jsxs(AuthUIProvider, {
				authClient: reactClient,
				...props,
				multiSession: false,
				apiKey: false,
				magicLink: false,
				passkey: false,
				oneTap: false,
				genericOAuth: void 0,
				twoFactor: void 0,
				children: [children, /* @__PURE__ */ jsx(Toaster, {})]
			})
		})
	});
}

//#endregion
export { RobloxIcon as $, MagicLinkForm as A, useAuthenticate as At, OrganizationSettingsCards as B, GitLabIcon as C, UserInvitationsCard as Ct, KickIcon as D, ZoomIcon as Dt, InputFieldSkeleton as E, XIcon3 as Et, OrganizationInvitationsCard as F, PasskeysCard as G, OrganizationSwitcher as H, OrganizationLogo as I, RecoverAccountForm as J, PasswordInput as K, OrganizationLogoCard as L, NeonAuthUIProvider as M, useTheme as Mt, NotionIcon as N, LinearIcon as O, socialProviders as Ot, OrganizationCellView as P, ResetPasswordForm as Q, OrganizationMembersCard as R, GitHubIcon as S, UserButton as St, HuggingFaceIcon as T, VKIcon as Tt, OrganizationView as U, OrganizationSlugCard as V, OrganizationsCard as W, RedirectToSignIn as X, RedditIcon as Y, RedirectToSignUp as Z, DeleteOrganizationCard as _, UpdateAvatarCard as _t, AppleIcon as a, SignOut as at, FacebookIcon as b, UpdateUsernameCard as bt, AuthLoading as c, SignedOut as ct, AuthView as d, TeamCell as dt, SecuritySettingsCards as et, ChangeEmailCard as f, TeamsCard as ft, DeleteAccountCard as g, TwoFactorForm as gt, CreateTeamDialog as h, TwoFactorCard as ht, AccountsCard as i, SignInForm as it, MicrosoftIcon as j, useCurrentOrganization as jt, LinkedInIcon as k, useAuthData as kt, AuthUIContext as l, SlackIcon as lt, CreateOrganizationDialog as m, TwitchIcon as mt, AccountSettingsCards as n, SettingsCard as nt, AuthCallback as o, SignUpForm as ot, ChangePasswordCard as p, TikTokIcon as pt, ProvidersCard as q, AccountView as r, SettingsCellSkeleton as rt, AuthForm as s, SignedIn as st, AcceptInvitationCard as t, SessionsCard as tt, AuthUIProvider as u, SpotifyIcon as ut, DiscordIcon as v, UpdateFieldCard as vt, GoogleIcon as w, UserView as wt, ForgotPasswordForm as x, UserAvatar as xt, DropboxIcon as y, UpdateNameCard as yt, OrganizationNameCard as z };