"use client";
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// ../internal/dist/index.mjs
var RetryError = class extends Error {
};
var TimeoutError = class extends Error {
};
var backoff = (retryCount) => Math.exp(retryCount) * 150;
var withRetry = (_0, ..._1) => __async(void 0, [_0, ..._1], function* (callback, { attempts = 4 } = {}) {
  var _a;
  let error;
  for (let i = 0; i < attempts; i++) {
    try {
      return yield callback();
    } catch (err) {
      error = err;
      yield new Promise((r) => setTimeout(r, backoff(i)));
    }
  }
  throw new RetryError((_a = error == null ? void 0 : error.message) != null ? _a : "Exhausted all retries");
});
var mountInstance;
var LOAD_FUNC_KEY = "captchaFoxOnLoad";
var SCRIPT_SRC = `https://cdn.captchafox.com/api.js?render=explicit&onload=${LOAD_FUNC_KEY}`;
function loadScript() {
  return __async(this, arguments, function* ({ nonce } = {}) {
    if (mountInstance && document.querySelector(`script[src="${SCRIPT_SRC}"]`)) {
      return mountInstance;
    }
    mountInstance = new Promise((resolve, reject) => {
      window[LOAD_FUNC_KEY] = resolve;
      const script = document.createElement("script");
      script.src = SCRIPT_SRC;
      script.async = true;
      script.defer = true;
      script.onerror = (e) => {
        script.remove();
        mountInstance = void 0;
        reject(e);
      };
      if (nonce) {
        script.nonce = nonce;
      }
      document.body.appendChild(script);
    });
    return mountInstance;
  });
}
function loadCaptchaScript() {
  return __async(this, arguments, function* (props = {}) {
    return withRetry(() => loadScript(props));
  });
}
var isApiReady = () => typeof (window == null ? void 0 : window.captchafox) !== "undefined";

// src/CaptchaFox.tsx
import React, { forwardRef, useEffect, useImperativeHandle, useRef, useState } from "react";
var CaptchaFox = forwardRef(
  ({
    executeTimeoutSeconds = 30,
    sitekey,
    lang,
    mode,
    theme,
    className,
    nonce,
    i18n,
    onError,
    onVerify,
    onLoad,
    onFail,
    onClose,
    onChallengeChange,
    onChallengeOpen
  }, ref) => {
    const [containerRef, setContainerRef] = useState();
    const [widgetId, setWidgetId] = useState();
    const firstRendered = useRef(false);
    const onReady = useRef();
    const executeTimeout = useRef();
    const scriptErrorListener = useRef();
    const hasScriptError = useRef(false);
    useImperativeHandle(
      ref,
      () => {
        return {
          getResponse() {
            if (!isApiReady() || !widgetId) {
              console.warn("[CaptchaFox] Widget has not been loaded");
              return "";
            }
            return window.captchafox.getResponse(widgetId);
          },
          reset() {
            if (!isApiReady() || !widgetId) {
              console.warn("[CaptchaFox] Widget has not been loaded");
              return;
            }
            window.captchafox.reset(widgetId);
          },
          remove() {
            if (!isApiReady() || !widgetId) {
              console.warn("[CaptchaFox] Widget has not been loaded");
              return;
            }
            setWidgetId(void 0);
            window.captchafox.remove(widgetId);
          },
          execute: () => __async(void 0, null, function* () {
            if (hasScriptError.current) {
              return Promise.reject(new RetryError());
            }
            if (!isApiReady() || !widgetId) {
              return waitAndExecute();
            }
            try {
              const token = yield window.captchafox.execute(widgetId);
              return token;
            } catch (error) {
              const errorType = getErrorType(error);
              return Promise.reject(errorType);
            }
          })
        };
      },
      [widgetId]
    );
    useEffect(() => {
      if (widgetId) {
        onLoad == null ? void 0 : onLoad();
      }
    }, [widgetId]);
    useEffect(() => {
      return () => {
        clearEvents();
      };
    }, []);
    useEffect(() => {
      if (!containerRef) return;
      if (firstRendered.current) {
        if (isApiReady()) {
          renderCaptcha();
        }
      } else {
        loadCaptchaScript({ nonce }).then(() => __async(void 0, null, function* () {
          if (isApiReady()) {
            firstRendered.current = true;
            yield renderCaptcha();
          }
        })).catch((err) => {
          var _a;
          onError == null ? void 0 : onError(err);
          hasScriptError.current = true;
          (_a = scriptErrorListener.current) == null ? void 0 : _a.call(scriptErrorListener);
          console.error("[CaptchaFox] Could not load script:", err);
        });
      }
    }, [containerRef, sitekey, lang, mode]);
    const clearEvents = () => {
      clearTimeout(executeTimeout.current);
    };
    const waitAndExecute = () => {
      return new Promise((resolve, reject) => {
        scriptErrorListener.current = () => {
          clearEvents();
          reject(new RetryError());
        };
        executeTimeout.current = setTimeout(() => {
          reject(new TimeoutError("Execute timed out"));
        }, executeTimeoutSeconds * 1e3);
        onReady.current = (id) => {
          clearEvents();
          window.captchafox.execute(id).then(resolve).catch((error) => {
            const errorType = getErrorType(error);
            reject(errorType);
          });
        };
      });
    };
    const getErrorType = (error) => {
      if (error !== "challenge-aborted" && error !== "rate-limited") {
        return new RetryError();
      }
      return error;
    };
    const renderCaptcha = () => __async(void 0, null, function* () {
      var _a, _b, _c;
      (_a = window.captchafox) == null ? void 0 : _a.remove(widgetId);
      if (!containerRef || ((_b = containerRef == null ? void 0 : containerRef.children) == null ? void 0 : _b.length) === 1) return;
      const newWidgetId = yield (_c = window.captchafox) == null ? void 0 : _c.render(containerRef, {
        lang,
        sitekey,
        mode,
        theme,
        i18n,
        onError,
        onFail,
        onClose,
        onVerify,
        onChallengeChange,
        onChallengeOpen
      });
      if (!newWidgetId) {
        return;
      }
      setWidgetId(newWidgetId);
      if (onReady.current) {
        onReady.current(newWidgetId);
        onReady.current = void 0;
      }
    });
    return /* @__PURE__ */ React.createElement("div", { ref: setContainerRef, id: widgetId, className });
  }
);
CaptchaFox.displayName = "CaptchaFox";

// src/index.tsx
var CAPTCHA_RESPONSE_KEY = "cf-captcha-response";
export {
  CAPTCHA_RESPONSE_KEY,
  CaptchaFox,
  RetryError,
  TimeoutError
};
