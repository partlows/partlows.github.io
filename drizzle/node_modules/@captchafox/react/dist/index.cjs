"use client";
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.tsx
var src_exports = {};
__export(src_exports, {
  CAPTCHA_RESPONSE_KEY: () => CAPTCHA_RESPONSE_KEY,
  CaptchaFox: () => CaptchaFox,
  RetryError: () => RetryError,
  TimeoutError: () => TimeoutError
});
module.exports = __toCommonJS(src_exports);

// ../internal/dist/index.mjs
var RetryError = class extends Error {
};
var TimeoutError = class extends Error {
};
var backoff = (retryCount) => Math.exp(retryCount) * 150;
var withRetry = (_0, ..._1) => __async(void 0, [_0, ..._1], function* (callback, { attempts = 4 } = {}) {
  var _a;
  let error;
  for (let i = 0; i < attempts; i++) {
    try {
      return yield callback();
    } catch (err) {
      error = err;
      yield new Promise((r) => setTimeout(r, backoff(i)));
    }
  }
  throw new RetryError((_a = error == null ? void 0 : error.message) != null ? _a : "Exhausted all retries");
});
var mountInstance;
var LOAD_FUNC_KEY = "captchaFoxOnLoad";
var SCRIPT_SRC = `https://cdn.captchafox.com/api.js?render=explicit&onload=${LOAD_FUNC_KEY}`;
function loadScript() {
  return __async(this, arguments, function* ({ nonce } = {}) {
    if (mountInstance && document.querySelector(`script[src="${SCRIPT_SRC}"]`)) {
      return mountInstance;
    }
    mountInstance = new Promise((resolve, reject) => {
      window[LOAD_FUNC_KEY] = resolve;
      const script = document.createElement("script");
      script.src = SCRIPT_SRC;
      script.async = true;
      script.defer = true;
      script.onerror = (e) => {
        script.remove();
        mountInstance = void 0;
        reject(e);
      };
      if (nonce) {
        script.nonce = nonce;
      }
      document.body.appendChild(script);
    });
    return mountInstance;
  });
}
function loadCaptchaScript() {
  return __async(this, arguments, function* (props = {}) {
    return withRetry(() => loadScript(props));
  });
}
var isApiReady = () => typeof (window == null ? void 0 : window.captchafox) !== "undefined";

// src/CaptchaFox.tsx
var import_react = __toESM(require("react"), 1);
var CaptchaFox = (0, import_react.forwardRef)(
  ({
    executeTimeoutSeconds = 30,
    sitekey,
    lang,
    mode,
    theme,
    className,
    nonce,
    i18n,
    onError,
    onVerify,
    onLoad,
    onFail,
    onClose,
    onChallengeChange,
    onChallengeOpen
  }, ref) => {
    const [containerRef, setContainerRef] = (0, import_react.useState)();
    const [widgetId, setWidgetId] = (0, import_react.useState)();
    const firstRendered = (0, import_react.useRef)(false);
    const onReady = (0, import_react.useRef)();
    const executeTimeout = (0, import_react.useRef)();
    const scriptErrorListener = (0, import_react.useRef)();
    const hasScriptError = (0, import_react.useRef)(false);
    (0, import_react.useImperativeHandle)(
      ref,
      () => {
        return {
          getResponse() {
            if (!isApiReady() || !widgetId) {
              console.warn("[CaptchaFox] Widget has not been loaded");
              return "";
            }
            return window.captchafox.getResponse(widgetId);
          },
          reset() {
            if (!isApiReady() || !widgetId) {
              console.warn("[CaptchaFox] Widget has not been loaded");
              return;
            }
            window.captchafox.reset(widgetId);
          },
          remove() {
            if (!isApiReady() || !widgetId) {
              console.warn("[CaptchaFox] Widget has not been loaded");
              return;
            }
            setWidgetId(void 0);
            window.captchafox.remove(widgetId);
          },
          execute: () => __async(void 0, null, function* () {
            if (hasScriptError.current) {
              return Promise.reject(new RetryError());
            }
            if (!isApiReady() || !widgetId) {
              return waitAndExecute();
            }
            try {
              const token = yield window.captchafox.execute(widgetId);
              return token;
            } catch (error) {
              const errorType = getErrorType(error);
              return Promise.reject(errorType);
            }
          })
        };
      },
      [widgetId]
    );
    (0, import_react.useEffect)(() => {
      if (widgetId) {
        onLoad == null ? void 0 : onLoad();
      }
    }, [widgetId]);
    (0, import_react.useEffect)(() => {
      return () => {
        clearEvents();
      };
    }, []);
    (0, import_react.useEffect)(() => {
      if (!containerRef) return;
      if (firstRendered.current) {
        if (isApiReady()) {
          renderCaptcha();
        }
      } else {
        loadCaptchaScript({ nonce }).then(() => __async(void 0, null, function* () {
          if (isApiReady()) {
            firstRendered.current = true;
            yield renderCaptcha();
          }
        })).catch((err) => {
          var _a;
          onError == null ? void 0 : onError(err);
          hasScriptError.current = true;
          (_a = scriptErrorListener.current) == null ? void 0 : _a.call(scriptErrorListener);
          console.error("[CaptchaFox] Could not load script:", err);
        });
      }
    }, [containerRef, sitekey, lang, mode]);
    const clearEvents = () => {
      clearTimeout(executeTimeout.current);
    };
    const waitAndExecute = () => {
      return new Promise((resolve, reject) => {
        scriptErrorListener.current = () => {
          clearEvents();
          reject(new RetryError());
        };
        executeTimeout.current = setTimeout(() => {
          reject(new TimeoutError("Execute timed out"));
        }, executeTimeoutSeconds * 1e3);
        onReady.current = (id) => {
          clearEvents();
          window.captchafox.execute(id).then(resolve).catch((error) => {
            const errorType = getErrorType(error);
            reject(errorType);
          });
        };
      });
    };
    const getErrorType = (error) => {
      if (error !== "challenge-aborted" && error !== "rate-limited") {
        return new RetryError();
      }
      return error;
    };
    const renderCaptcha = () => __async(void 0, null, function* () {
      var _a, _b, _c;
      (_a = window.captchafox) == null ? void 0 : _a.remove(widgetId);
      if (!containerRef || ((_b = containerRef == null ? void 0 : containerRef.children) == null ? void 0 : _b.length) === 1) return;
      const newWidgetId = yield (_c = window.captchafox) == null ? void 0 : _c.render(containerRef, {
        lang,
        sitekey,
        mode,
        theme,
        i18n,
        onError,
        onFail,
        onClose,
        onVerify,
        onChallengeChange,
        onChallengeOpen
      });
      if (!newWidgetId) {
        return;
      }
      setWidgetId(newWidgetId);
      if (onReady.current) {
        onReady.current(newWidgetId);
        onReady.current = void 0;
      }
    });
    return /* @__PURE__ */ import_react.default.createElement("div", { ref: setContainerRef, id: widgetId, className });
  }
);
CaptchaFox.displayName = "CaptchaFox";

// src/index.tsx
var CAPTCHA_RESPONSE_KEY = "cf-captcha-response";
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CAPTCHA_RESPONSE_KEY,
  CaptchaFox,
  RetryError,
  TimeoutError
});
