"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useQueryInternal = useQueryInternal;
const core_1 = require("@instantdb/core");
const react_1 = require("react");
const defaultState = {
    isLoading: true,
    data: undefined,
    pageInfo: undefined,
    error: undefined,
};
function stateForResult(result) {
    return {
        isLoading: !Boolean(result),
        data: undefined,
        pageInfo: undefined,
        error: undefined,
        ...(result ? result : {}),
    };
}
function useQueryInternal(_core, _query, _opts) {
    if (_query && _opts && 'ruleParams' in _opts) {
        _query = { $$ruleParams: _opts['ruleParams'], ..._query };
    }
    const query = _query ? (0, core_1.coerceQuery)(_query) : null;
    const queryHash = (0, core_1.weakHash)(query);
    // We use a ref to store the result of the query.
    // This is becuase `useSyncExternalStore` uses `Object.is`
    // to compare the previous and next state.
    // If we don't use a ref, the state will always be considered different, so
    // the component will always re-render.
    const resultCacheRef = (0, react_1.useRef)(stateForResult(_core._reactor.getPreviousResult(query)));
    // Similar to `resultCacheRef`, `useSyncExternalStore` will unsubscribe
    // if `subscribe` changes, so we use `useCallback` to memoize the function.
    const subscribe = (0, react_1.useCallback)((cb) => {
        // Update the ref when the query changes to avoid showing stale data
        resultCacheRef.current = stateForResult(_core._reactor.getPreviousResult(query));
        // before the subscribeQuery is connected and calls it's own callback,
        // we might have data in the store via SSR, we need to notify useSyncExternalStore that
        // the data has changed.
        cb();
        // Don't subscribe if query is null
        if (!query) {
            const unsubscribe = () => { };
            return unsubscribe;
        }
        const unsubscribe = _core.subscribeQuery(query, (result) => {
            resultCacheRef.current = {
                isLoading: !Boolean(result),
                // @ts-expect-error: ts thinks this will always be overwritten
                data: undefined,
                // @ts-expect-error: ts thinks this will always be overwritten
                pageInfo: undefined,
                // @ts-expect-error: ts thinks this will always be overwritten
                error: undefined,
                ...result,
            };
            cb();
        });
        return unsubscribe;
    }, 
    // Build a new subscribe function if the query changes
    [queryHash]);
    const state = (0, react_1.useSyncExternalStore)(subscribe, () => resultCacheRef.current, () => defaultState);
    return { state, query };
}
//# sourceMappingURL=useQuery.js.map