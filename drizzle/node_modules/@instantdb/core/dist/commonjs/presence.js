"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildPresenceSlice = buildPresenceSlice;
exports.hasPresenceResponseChanged = hasPresenceResponseChanged;
const pick_js_1 = require("./utils/pick.js");
const object_js_1 = require("./utils/object.js");
function buildPresenceSlice(data, opts, userPeerId) {
    const slice = {
        peers: {},
    };
    const includeUser = opts && 'user' in opts ? opts.user : true;
    if (includeUser) {
        const user = (0, pick_js_1.pick)(data.user ?? {}, opts?.keys);
        slice.user = { ...user, peerId: userPeerId };
    }
    for (const id of Object.keys(data.peers ?? {})) {
        const shouldIncludeAllPeers = opts?.peers === undefined;
        const isPeerIncluded = Array.isArray(opts?.peers) && opts?.peers.includes(id);
        if (shouldIncludeAllPeers || isPeerIncluded) {
            const peer = (0, pick_js_1.pick)(data.peers[id], opts?.keys);
            slice.peers[id] = { ...peer, peerId: id };
        }
    }
    return slice;
}
/**
 * Compare two presence slices
 * 0. compare isLoading and error
 * 1. shallow compare user
 * 2. compare peers keys
 * 3. shallow compare each peer
 */
function hasPresenceResponseChanged(a, b) {
    if (a.isLoading !== b.isLoading)
        return true;
    if (a.error !== b.error)
        return true;
    if (a.user || b.user) {
        if (!a.user || !b.user)
            return true;
        const same = (0, object_js_1.areObjectsShallowEqual)(a.user, b.user);
        if (!same)
            return true;
    }
    const sameKeys = (0, object_js_1.areObjectKeysEqual)(a.peers, b.peers);
    if (!sameKeys)
        return true;
    for (const id of Object.keys(a.peers)) {
        const same = (0, object_js_1.areObjectsShallowEqual)(a.peers[id], b.peers[id]);
        if (!same)
            return true;
    }
    return false;
}
//# sourceMappingURL=presence.js.map