import type { Logger } from './log.ts';
export declare const META_KEY = "__meta";
export type ObjectMeta = {
    createdAt: number;
    updatedAt: number;
    size: number;
};
export type Meta<K extends string> = {
    objects: Record<K, ObjectMeta>;
};
export type StoreInterfaceStoreName = 'kv' | 'querySubs' | 'syncSubs';
export declare abstract class StoreInterface {
    constructor(appId: string, storeName: StoreInterfaceStoreName);
    abstract getItem(key: string): Promise<any>;
    abstract removeItem(key: string): Promise<void>;
    abstract multiSet(keyValuePairs: Array<[string, any]>): Promise<void>;
    abstract getAllKeys(): Promise<string[]>;
}
export type StoreInterfaceClass = new (appId: string, storeName: StoreInterfaceStoreName) => StoreInterface;
export type GCOpts = {
    maxSize: number;
    maxAgeMs: number;
    maxEntries: number;
};
export type Opts<K, T, SerializedT> = {
    persister: StoreInterface;
    /**
     * Merges data from storage with in-memory value on load.
     * The value returned from merge will become the current value.
     */
    merge: (key: K, fromStorage: T | null | undefined, inMemoryValue: T | null | undefined) => T;
    serialize: (key: K, input: T) => SerializedT;
    parse: (key: K, value: SerializedT) => T;
    objectSize: (x: SerializedT) => number;
    logger: Logger;
    gc: GCOpts | null | undefined;
    saveThrottleMs?: number | null | undefined;
    idleCallbackMaxWaitMs?: number | null | undefined;
    preloadEntryCount?: number | null | undefined;
};
export declare class PersistedObject<K extends string, T, SerializedT> {
    currentValue: Record<K, T>;
    private _subs;
    private _persister;
    private _merge;
    private serialize;
    private parse;
    private _saveThrottleMs;
    private _idleCallbackMaxWaitMs;
    private _nextSave;
    private _nextGc;
    private _pendingSaveKeys;
    private _loadedKeys;
    private _loadingKeys;
    private _objectSize;
    private _log;
    onKeyLoaded: (key: string) => void | null | undefined;
    private _version;
    private _meta;
    private _gcOpts;
    constructor(opts: Opts<K, T, SerializedT>);
    private _initMeta;
    private _getMeta;
    private _refreshMeta;
    private _preloadEntries;
    private _getFromStorage;
    waitForKeyToLoad(k: K): Promise<Record<K, T>[K]>;
    waitForMetaToLoad(): Promise<Meta<K> | null>;
    unloadKey(k: K): void;
    private _loadKey;
    private _writeToStorage;
    flush(): Promise<number | undefined>;
    private _gc;
    gc(): void;
    private _enqueuePersist;
    version(): number;
    updateInPlace(f: (prev: Record<string, T>) => void): Record<string, T>;
    subscribe(cb: (value: Record<K, T>) => void): () => void;
}
//# sourceMappingURL=PersistedObject.d.ts.map