{"version":3,"file":"fetch.js","sourceRoot":"","sources":["../../../src/utils/fetch.ts"],"names":[],"mappings":";;;AA8GA,8BASC;AAvHD,wDAAkD;AAiFlD,MAAa,eAAgB,SAAQ,8BAAY;IAC/C,IAAI,CAAmB;IACvB,MAAM,CAAS;IAEf,YAAY,KAAmB;QAC7B,kDAAkD;QAClD,MAAM,OAAO,GAAG,KAAK,CAAC,IAAI,EAAE,OAAO,IAAI,cAAc,KAAK,CAAC,MAAM,GAAG,CAAC;QACrE,KAAK,CAAC,OAAO,EAAG,KAAK,CAAC,IAAY,CAAC,IAAI,CAAC,CAAC;QAEzC,MAAM,WAAW,GAAG,GAAG,CAAC,MAAM,CAAC,SAAS,CAAC;QACzC,IAAI,MAAM,CAAC,cAAc,EAAE,CAAC;YAC1B,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC;QAC3C,CAAC;QAED,6DAA6D;QAC7D,IAAI,KAAK,CAAC,iBAAiB,EAAE,CAAC;YAC5B,KAAK,CAAC,iBAAiB,CAAC,IAAI,EAAE,eAAe,CAAC,CAAC;QACjD,CAAC;QAED,IAAI,CAAC,IAAI,GAAG,iBAAiB,CAAC;QAC9B,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC;QAC3B,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC;IACzB,CAAC;IAED,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC;QACtB,OAAO,iBAAiB,CAAC;IAC3B,CAAC;CACF;AA3BD,0CA2BC;AAEM,KAAK,UAAU,SAAS,CAC7B,KAAkB,EAClB,IAA6B;IAE7B,MAAM,GAAG,GAAG,MAAM,KAAK,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;IACrC,MAAM,IAAI,GAAG,MAAM,GAAG,CAAC,IAAI,EAAE,CAAC;IAC9B,OAAO,GAAG,CAAC,MAAM,KAAK,GAAG;QACvB,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC;QACvB,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,eAAe,CAAC,EAAE,MAAM,EAAE,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;AAC9E,CAAC","sourcesContent":["import { InstantError } from '../InstantError.ts';\n\ntype InstantIssueBody =\n  | { type: 'param-missing'; message: string; hint: { in: string[] } }\n  | { type: 'param-malformed'; message: string; hint: { in: string[] } }\n  | {\n      type: 'record-not-found';\n      message: string;\n      hint: { 'record-type': string };\n    }\n  | {\n      type: 'record-not-unique';\n      message: string;\n      hint: { 'record-type': string };\n    }\n  | {\n      type: 'validation-failed';\n      message: string;\n      hint: { 'data-type': string; errors: any[] };\n    }\n  | {\n      type: 'record-expired';\n      message: string;\n      hint: { 'record-type': string };\n    }\n  | {\n      type: 'record-foreign-key-invalid';\n      message: string;\n      hint: { table?: string; condition?: string; constraint?: string };\n    }\n  | {\n      type: 'record-check-violation';\n      message: string;\n      hint: { table?: string; condition?: string; constraint?: string };\n    }\n  | {\n      type: 'permission-denied';\n      message: string;\n      hint: { input: any; expected: string };\n    }\n  | {\n      type: 'permission-evaluation-failed';\n      message: string;\n      hint: {\n        rule: [string, string];\n        error?: { type: string; message: string; hint: any };\n      };\n    }\n  | {\n      type: 'sql-raise';\n      message: string;\n      hint: { table?: string; condition?: string; constraint?: string };\n    }\n  | {\n      type: 'sql-exception';\n      message: string;\n      hint: { table?: string; condition?: string; constraint?: string };\n    }\n  | {\n      type: 'rate-limited';\n      message: string;\n    }\n  | {\n      type: 'session-missing';\n      message: string;\n      hint: { 'sess-id': string };\n    }\n  | {\n      type: 'socket-missing';\n      message: string;\n      hint: { 'sess-id': string; 'exception-message'?: string };\n    }\n  | { type: undefined; [k: string]: any }\n  | undefined;\n// Note that InstantIssueBody is not exported and is only necessary for making InstantAPIError\n// below to have all the members and typecheck as InstantIssue\nexport type InstantIssue = {\n  body: InstantIssueBody;\n  status: number;\n};\n\nexport class InstantAPIError extends InstantError {\n  body: InstantIssueBody;\n  status: number;\n\n  constructor(error: InstantIssue) {\n    // Create a descriptive message based on the error\n    const message = error.body?.message || `API Error (${error.status})`;\n    super(message, (error.body as any).hint);\n\n    const actualProto = new.target.prototype;\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(this, actualProto);\n    }\n\n    // Maintain proper stack trace for where our error was thrown\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, InstantAPIError);\n    }\n\n    this.name = 'InstantAPIError';\n    this.status = error.status;\n    this.body = error.body;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'InstantAPIError';\n  }\n}\n\nexport async function jsonFetch(\n  input: RequestInfo,\n  init: RequestInit | undefined,\n): Promise<any> {\n  const res = await fetch(input, init);\n  const json = await res.json();\n  return res.status === 200\n    ? Promise.resolve(json)\n    : Promise.reject(new InstantAPIError({ status: res.status, body: json }));\n}\n"]}