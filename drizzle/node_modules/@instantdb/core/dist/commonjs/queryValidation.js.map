{"version":3,"file":"queryValidation.js","sourceRoot":"","sources":["../../src/queryValidation.ts"],"names":[],"mappings":";;;AAAA,qDAI0B;AAC1B,+BAAgD;AAEhD,MAAa,oBAAqB,SAAQ,KAAK;IAC7C,YAAY,OAAe,EAAE,IAAa;QACxC,MAAM,WAAW,GAAG,IAAI,CAAC,CAAC,CAAC,YAAY,IAAI,MAAM,OAAO,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC;QACrE,KAAK,CAAC,WAAW,CAAC,CAAC;QACnB,IAAI,CAAC,IAAI,GAAG,sBAAsB,CAAC;IACrC,CAAC;CACF;AAND,oDAMC;AAED,MAAM,cAAc,GAAG;IACrB,OAAO;IACP,OAAO;IACP,OAAO;IACP,MAAM;IACN,OAAO;IACP,QAAQ;IACR,OAAO;IACP,QAAQ;IACR,QAAQ;IACR,WAAW;CACZ,CAAC;AAIF,MAAM,WAAW,GAAG,CAClB,OAAmC,EAChB,EAAE;IACrB,OAAO,OAAO,CAAC,SAAS,IAAI,SAAS,CAAC;AACxC,CAAC,CAAC;AAEF,MAAM,mBAAmB,GAAG,CAC1B,KAAc,EACd,YAA+B,EAC/B,YAAqB,KAAK,EACjB,EAAE;IACX,IAAI,SAAS;QAAE,OAAO,IAAI,CAAC;IAC3B,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS;QAAE,OAAO,IAAI,CAAC;IAEvD,QAAQ,YAAY,EAAE,CAAC;QACrB,KAAK,QAAQ;YACX,OAAO,OAAO,KAAK,KAAK,QAAQ,CAAC;QACnC,KAAK,QAAQ;YACX,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QACpD,KAAK,SAAS;YACZ,OAAO,OAAO,KAAK,KAAK,SAAS,CAAC;QACpC,KAAK,MAAM;YACT,OAAO,CACL,KAAK,YAAY,IAAI;gBACrB,OAAO,KAAK,KAAK,QAAQ;gBACzB,OAAO,KAAK,KAAK,QAAQ,CAC1B,CAAC;QACJ;YACE,OAAO,IAAI,CAAC;IAChB,CAAC;AACH,CAAC,CAAC;AAEF,MAAM,gBAAgB,GAAG,CACvB,EAAU,EACV,OAAgB,EAChB,YAA+B,EAC/B,QAAgB,EAChB,UAAkB,EAClB,OAAmC,EACnC,IAAY,EACZ,EAAE;IACF,MAAM,SAAS,GAAG,OAAO,CAAC,SAAS,KAAK,MAAM,CAAC;IAC/C,MAAM,gBAAgB,GAAG,CACvB,EAAU,EACV,YAA+B,EAC/B,OAAgB,EAChB,EAAE;QACF,IAAI,CAAC,mBAAmB,CAAC,OAAO,EAAE,YAAY,EAAE,SAAS,CAAC,EAAE,CAAC;YAC3D,MAAM,IAAI,oBAAoB,CAC5B,+BAA+B,EAAE,mBAAmB,QAAQ,gBAAgB,UAAU,eAAe,YAAY,mBAAmB,OAAO,OAAO,EAAE,EACpJ,IAAI,CACL,CAAC;QACJ,CAAC;IACH,CAAC,CAAC;IAEF,QAAQ,EAAE,EAAE,CAAC;QACX,KAAK,IAAI,CAAC;QACV,KAAK,KAAK;YACR,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC;gBAC5B,MAAM,IAAI,oBAAoB,CAC5B,aAAa,EAAE,oBAAoB,QAAQ,gBAAgB,UAAU,qCAAqC,OAAO,OAAO,EAAE,EAC1H,IAAI,CACL,CAAC;YACJ,CAAC;YACD,KAAK,MAAM,IAAI,IAAI,OAAO,EAAE,CAAC;gBAC3B,gBAAgB,CAAC,EAAE,EAAE,YAAY,EAAE,IAAI,CAAC,CAAC;YAC3C,CAAC;YACD,MAAM;QACR,KAAK,MAAM,CAAC;QACZ,KAAK,KAAK,CAAC;QACX,KAAK,KAAK,CAAC;QACX,KAAK,KAAK,CAAC;QACX,KAAK,MAAM,CAAC;QACZ,KAAK,MAAM;YACT,gBAAgB,CAAC,EAAE,EAAE,YAAY,EAAE,OAAO,CAAC,CAAC;YAC5C,MAAM;QACR,KAAK,OAAO,CAAC;QACb,KAAK,QAAQ;YACX,gBAAgB,CAAC,EAAE,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;YAExC,IAAI,EAAE,KAAK,QAAQ,EAAE,CAAC;gBACpB,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,CAAC;oBACvB,MAAM,IAAI,oBAAoB,CAC5B,aAAa,EAAE,oDAAoD,QAAQ,gBAAgB,UAAU,kBAAkB,EACvH,IAAI,CACL,CAAC;gBACJ,CAAC;YACH,CAAC;YAED,MAAM;QACR,KAAK,SAAS;YACZ,gBAAgB,CAAC,EAAE,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;YACzC,MAAM;QACR;YACE,MAAM,IAAI,oBAAoB,CAC5B,qBAAqB,EAAE,oBAAoB,QAAQ,gBAAgB,UAAU,GAAG,EAChF,IAAI,CACL,CAAC;IACN,CAAC;AACH,CAAC,CAAC;AAEF,MAAM,wBAAwB,GAAG,CAC/B,KAAc,EACd,QAAgB,EAChB,OAAmC,EACnC,UAAkB,EAClB,IAAY,EACN,EAAE;IACR,MAAM,YAAY,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC;IAC1C,MAAM,SAAS,GAAG,OAAO,CAAC,SAAS,KAAK,MAAM,CAAC;IAE/C,MAAM,eAAe,GACnB,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;IACvE,IAAI,eAAe,EAAE,CAAC;QACpB,yEAAyE;QACzE,IAAI,SAAS,EAAE,CAAC;YACd,OAAO,CAAC,wDAAwD;QAClE,CAAC;QAED,MAAM,SAAS,GAAG,KAAgC,CAAC;QAEnD,KAAK,MAAM,CAAC,EAAE,EAAE,OAAO,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE,CAAC;YACtD,gBAAgB,CACd,EAAE,EACF,OAAO,EACP,YAAY,EACZ,QAAQ,EACR,UAAU,EACV,OAAO,EACP,GAAG,IAAI,IAAI,EAAE,EAAE,CAChB,CAAC;QACJ,CAAC;IACH,CAAC;SAAM,CAAC;QACN,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,YAAY,EAAE,SAAS,CAAC,EAAE,CAAC;YACzD,MAAM,IAAI,oBAAoB,CAC5B,gCAAgC,QAAQ,gBAAgB,UAAU,eAAe,YAAY,mBAAmB,OAAO,KAAK,EAAE,EAC9H,IAAI,CACL,CAAC;QACJ,CAAC;IACH,CAAC;AACH,CAAC,CAAC;AAEF,MAAM,4BAA4B,GAAG,CACnC,OAAe,EACf,KAAc,EACd,eAAuB,EACvB,MAA0C,EAC1C,IAAY,EACN,EAAE;IACR,MAAM,SAAS,GAAG,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IACrC,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QACzB,MAAM,IAAI,oBAAoB,CAC5B,8BAA8B,OAAO,mCAAmC,EACxE,IAAI,CACL,CAAC;IACJ,CAAC;IAED,IAAI,iBAAiB,GAAG,eAAe,CAAC;IAExC,6EAA6E;IAC7E,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;QAC9C,MAAM,QAAQ,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;QAC9B,MAAM,aAAa,GAAG,MAAM,CAAC,QAAQ,CAAC,iBAAiB,CAAC,CAAC;QAEzD,IAAI,CAAC,aAAa,EAAE,CAAC;YACnB,MAAM,IAAI,oBAAoB,CAC5B,WAAW,iBAAiB,kEAAkE,OAAO,IAAI,EACzG,IAAI,CACL,CAAC;QACJ,CAAC;QAED,MAAM,IAAI,GAAG,aAAa,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;QAC3C,IAAI,CAAC,IAAI,EAAE,CAAC;YACV,MAAM,cAAc,GAAG,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;YACxD,MAAM,IAAI,oBAAoB,CAC5B,SAAS,QAAQ,+BAA+B,iBAAiB,2BAA2B,OAAO,uBAAuB,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE,EAC1L,IAAI,CACL,CAAC;QACJ,CAAC;QAED,iBAAiB,GAAG,IAAI,CAAC,UAAU,CAAC;IACtC,CAAC;IAED,+BAA+B;IAC/B,MAAM,aAAa,GAAG,SAAS,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IACtD,MAAM,WAAW,GAAG,MAAM,CAAC,QAAQ,CAAC,iBAAiB,CAAC,CAAC;IAEvD,IAAI,CAAC,WAAW,EAAE,CAAC;QACjB,MAAM,IAAI,oBAAoB,CAC5B,kBAAkB,iBAAiB,qDAAqD,OAAO,IAAI,EACnG,IAAI,CACL,CAAC;IACJ,CAAC;IAED,6DAA6D;IAC7D,IAAI,aAAa,KAAK,IAAI,EAAE,CAAC;QAC3B,IAAI,OAAO,KAAK,IAAI,QAAQ,IAAI,CAAC,IAAA,eAAY,EAAC,KAAK,CAAC,EAAE,CAAC;YACrD,MAAM,IAAI,oBAAoB,CAC5B,yCAAyC,iBAAiB,qCAAqC,KAAK,EAAE,EACtG,IAAI,CACL,CAAC;QACJ,CAAC;QACD,wBAAwB,CACtB,KAAK,EACL,OAAO,EACP,IAAI,4BAAW,CAAC,QAAQ,EAAE,KAAK,EAAE,IAAI,CAAC,EACtC,eAAe,EACf,IAAI,CACL,CAAC;QACF,OAAO;IACT,CAAC;IAED,MAAM,OAAO,GAAG,WAAW,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC;IAEjD,IAAI,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,QAAQ,CAAC,aAAa,CAAC,EAAE,CAAC;QAC3D,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,CAAC,IAAA,eAAY,EAAC,KAAK,CAAC,EAAE,CAAC;YACtD,MAAM,IAAI,oBAAoB,CAC5B,2BAA2B,aAAa,gBAAgB,iBAAiB,qCAAqC,KAAK,EAAE,EACrH,IAAI,CACL,CAAC;QACJ,CAAC;QAED,wBAAwB,CACtB,KAAK,EACL,OAAO,EACP,IAAI,4BAAW,CAAC,QAAQ,EAAE,KAAK,EAAE,IAAI,CAAC,EACtC,eAAe,EACf,IAAI,CACL,CAAC;QACF,OAAO;IACT,CAAC;IAED,IAAI,CAAC,OAAO,EAAE,CAAC;QACb,MAAM,cAAc,GAAG,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QACtD,MAAM,IAAI,oBAAoB,CAC5B,cAAc,aAAa,+BAA+B,iBAAiB,2BAA2B,OAAO,4BAA4B,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,IAAI,EAAE,EAChN,IAAI,CACL,CAAC;IACJ,CAAC;IAED,gDAAgD;IAChD,wBAAwB,CAAC,KAAK,EAAE,OAAO,EAAE,OAAO,EAAE,eAAe,EAAE,IAAI,CAAC,CAAC;AAC3E,CAAC,CAAC;AAEF,MAAM,mBAAmB,GAAG,CAC1B,WAAoC,EACpC,UAAkB,EAClB,MAA0C,EAC1C,IAAY,EACN,EAAE;IACR,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,EAAE,CAAC;QACvD,IAAI,GAAG,KAAK,IAAI,IAAI,GAAG,KAAK,KAAK,EAAE,CAAC;YAClC,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC;gBACzB,KAAK,MAAM,MAAM,IAAI,KAAK,EAAE,CAAC;oBAC3B,IAAI,OAAO,MAAM,KAAK,QAAQ,IAAI,MAAM,KAAK,IAAI,EAAE,CAAC;wBAClD,mBAAmB,CACjB,MAAiC,EACjC,UAAU,EACV,MAAM,EACN,GAAG,IAAI,IAAI,GAAG,IAAI,MAAM,GAAG,CAC5B,CAAC;oBACJ,CAAC;gBACH,CAAC;YACH,CAAC;YACD,SAAS;QACX,CAAC;QAED,IAAI,GAAG,KAAK,IAAI,EAAE,CAAC;YACjB,wBAAwB,CACtB,KAAK,EACL,IAAI,EACJ,IAAI,4BAAW,CAAC,QAAQ,EAAE,KAAK,EAAE,IAAI,CAAC,EACtC,UAAU,EACV,GAAG,IAAI,KAAK,CACb,CAAC;YACF,SAAS;QACX,CAAC;QAED,IAAI,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,CAAC;YACtB,4BAA4B,CAC1B,GAAG,EACH,KAAK,EACL,UAAU,EACV,MAAM,EACN,GAAG,IAAI,IAAI,GAAG,EAAE,CACjB,CAAC;YACF,SAAS;QACX,CAAC;QAED,MAAM,SAAS,GAAG,MAAM,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;QAC9C,IAAI,CAAC,SAAS;YAAE,SAAS;QAEzB,MAAM,OAAO,GAAG,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACrC,MAAM,OAAO,GAAG,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAErC,IAAI,CAAC,OAAO,IAAI,CAAC,OAAO,EAAE,CAAC;YACzB,MAAM,cAAc,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;YACpD,MAAM,cAAc,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;YACpD,MAAM,IAAI,oBAAoB,CAC5B,sBAAsB,GAAG,+BAA+B,UAAU,4BAA4B,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,sBAAsB,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE,EAClP,GAAG,IAAI,IAAI,GAAG,EAAE,CACjB,CAAC;QACJ,CAAC;QAED,IAAI,OAAO,EAAE,CAAC;YACZ,wBAAwB,CACtB,KAAK,EACL,GAAG,EACH,OAAO,EACP,UAAU,EACV,GAAG,IAAI,IAAI,GAAG,EAAE,CACjB,CAAC;QACJ,CAAC;aAAM,IAAI,OAAO,EAAE,CAAC;YACnB,0EAA0E;YAC1E,gEAAgE;YAChE,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,CAAC,IAAA,eAAY,EAAC,KAAK,CAAC,EAAE,CAAC;gBACtD,MAAM,IAAI,oBAAoB,CAC5B,2BAA2B,GAAG,gBAAgB,UAAU,qCAAqC,KAAK,EAAE,EACpG,GAAG,IAAI,IAAI,GAAG,EAAE,CACjB,CAAC;YACJ,CAAC;YACD,MAAM,gBAAgB,GAAG,IAAI,4BAAW,CAAC,QAAQ,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;YAChE,wBAAwB,CACtB,KAAK,EACL,GAAG,EACH,gBAAgB,EAChB,UAAU,EACV,GAAG,IAAI,IAAI,GAAG,EAAE,CACjB,CAAC;QACJ,CAAC;IACH,CAAC;AACH,CAAC,CAAC;AAEF,MAAM,oBAAoB,GAAG,CAC3B,SAAkC,EAClC,UAAkB,EAClB,MAA8D,EAC9D,IAAa,EACb,QAAgB,CAAC,EACX,EAAE;IACR,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC;QACzC,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,CAAC;YAClC,MAAM,IAAI,oBAAoB,CAC5B,4BAA4B,GAAG,wCAAwC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,GAAG,EAAE,EACjH,IAAI,CACL,CAAC;QACJ,CAAC;IACH,CAAC;IAED,iEAAiE;IACjE,MAAM,gBAAgB,GAAG;QACvB,yCAAyC;QACzC,QAAQ;QACR,QAAQ;QACR,OAAO;QACP,OAAO;QACP,MAAM;KACP,CAAC;IACF,KAAK,MAAM,KAAK,IAAI,gBAAgB,EAAE,CAAC;QACrC,IAAI,SAAS,CAAC,KAAK,CAAC,KAAK,SAAS,IAAI,KAAK,GAAG,CAAC,EAAE,CAAC;YAChD,MAAM,IAAI,oBAAoB,CAC5B,IAAI,KAAK,kFAAkF,EAC3F,IAAI,CACL,CAAC;QACJ,CAAC;IACH,CAAC;IAED,IAAI,SAAS,CAAC,KAAK,IAAI,MAAM,EAAE,CAAC;QAC9B,IAAI,OAAO,SAAS,CAAC,KAAK,KAAK,QAAQ,IAAI,SAAS,CAAC,KAAK,KAAK,IAAI,EAAE,CAAC;YACpE,MAAM,IAAI,oBAAoB,CAC5B,+CAA+C,UAAU,oBAAoB,OAAO,SAAS,CAAC,KAAK,EAAE,EACrG,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,QAAQ,CAAC,CAAC,CAAC,SAAS,CACnC,CAAC;QACJ,CAAC;QACD,mBAAmB,CACjB,SAAS,CAAC,KAAgC,EAC1C,UAAU,EACV,MAAM,EACN,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,QAAQ,CAAC,CAAC,CAAC,OAAO,CACjC,CAAC;IACJ,CAAC;AACH,CAAC,CAAC;AAEF,MAAM,qBAAqB,GAAG,CAC5B,SAAkC,EAClC,UAAkB,EAClB,MAA6D,EAC7D,IAAY,EACZ,QAAgB,CAAC,EACX,EAAE;IACR,IAAI,CAAC,SAAS,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE,CAAC;QAChD,MAAM,IAAI,oBAAoB,CAC5B,0BAA0B,UAAU,sCAAsC,OAAO,SAAS,EAAE,EAC5F,IAAI,CACL,CAAC;IACJ,CAAC;IAED,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC;QACzC,IAAI,GAAG,KAAK,GAAG,EAAE,CAAC;YAChB,uBAAuB;YACvB,IAAI,MAAM,IAAI,CAAC,CAAC,GAAG,IAAI,MAAM,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC;gBAC1D,MAAM,cAAc,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,KAAK,CAAC,CAAC;gBACtE,MAAM,IAAI,oBAAoB,CAC5B,SAAS,GAAG,+BAA+B,UAAU,uBAAuB,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE,EAC5I,GAAG,IAAI,IAAI,GAAG,EAAE,CACjB,CAAC;YACJ,CAAC;YAED,oCAAoC;YACpC,MAAM,WAAW,GAAG,SAAS,CAAC,GAAG,CAAC,CAAC;YACnC,IAAI,OAAO,WAAW,KAAK,QAAQ,IAAI,WAAW,KAAK,IAAI,EAAE,CAAC;gBAC5D,MAAM,gBAAgB,GACpB,MAAM,EAAE,QAAQ,CAAC,UAAU,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,UAAU,CAAC;gBACtD,IAAI,gBAAgB,EAAE,CAAC;oBACrB,qBAAqB,CACnB,WAAsC,EACtC,gBAAgB,EAChB,MAAM,EACN,GAAG,IAAI,IAAI,GAAG,EAAE,EAChB,KAAK,GAAG,CAAC,CACV,CAAC;gBACJ,CAAC;YACH,CAAC;QACH,CAAC;aAAM,CAAC;YACN,oBAAoB;YACpB,MAAM,SAAS,GAAG,SAAS,CAAC,GAAG,CAAC,CAAC;YACjC,IAAI,OAAO,SAAS,KAAK,QAAQ,IAAI,SAAS,KAAK,IAAI,EAAE,CAAC;gBACxD,MAAM,IAAI,oBAAoB,CAC5B,oDAAoD,UAAU,oBAAoB,OAAO,SAAS,EAAE,EACpG,GAAG,IAAI,IAAI,CACZ,CAAC;YACJ,CAAC;YAED,oBAAoB,CAClB,SAAoC,EACpC,UAAU,EACV,MAAM,EACN,GAAG,IAAI,IAAI,EACX,KAAK,CACN,CAAC;QACJ,CAAC;IACH,CAAC;AACH,CAAC,CAAC;AAEK,MAAM,aAAa,GAAG,CAC3B,CAAU,EACV,MAA2C,EACrC,EAAE;IACR,IAAI,OAAO,CAAC,KAAK,QAAQ,IAAI,CAAC,KAAK,IAAI,EAAE,CAAC;QACxC,MAAM,IAAI,oBAAoB,CAC5B,0CAA0C,OAAO,CAAC,GAAG,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,CACnF,CAAC;IACJ,CAAC;IAED,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC;QACrB,MAAM,IAAI,oBAAoB,CAC5B,0CAA0C,OAAO,CAAC,EAAE,CACrD,CAAC;IACJ,CAAC;IAED,MAAM,QAAQ,GAAG,CAA4B,CAAC;IAE9C,KAAK,MAAM,WAAW,IAAI,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC;QAChD,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,EAAE,CAAC;YAClC,MAAM,IAAI,oBAAoB,CAC5B,sDAAsD,OAAO,WAAW,EAAE,EAC1E,WAAW,CACZ,CAAC;QACJ,CAAC;QAED,IAAI,OAAO,WAAW,KAAK,QAAQ,EAAE,CAAC;YACpC,MAAM,IAAI,oBAAoB,CAC5B,sDAAsD,OAAO,WAAW,EAAE,EAC1E,WAAW,CACZ,CAAC;QACJ,CAAC;QAED,IAAI,WAAW,KAAK,cAAc,EAAE,CAAC;YACnC,SAAS;QACX,CAAC;QAED,uCAAuC;QACvC,IAAI,MAAM,EAAE,CAAC;YACX,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAE,CAAC;gBAClC,MAAM,iBAAiB,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;gBACvD,MAAM,IAAI,oBAAoB,CAC5B,WAAW,WAAW,mDAAmD,iBAAiB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE,EAC/I,WAAW,CACZ,CAAC;YACJ,CAAC;QACH,CAAC;QAED,qBAAqB,CACnB,QAAQ,CAAC,WAAW,CAA4B,EAChD,WAAW,EACX,MAAM,EACN,WAAW,EACX,CAAC,CACF,CAAC;IACJ,CAAC;AACH,CAAC,CAAC;AAxDW,QAAA,aAAa,iBAwDxB","sourcesContent":["import {\n  IContainEntitiesAndLinks,\n  DataAttrDef,\n  ValueTypes,\n} from './schemaTypes.ts';\nimport { validate as validateUUID } from 'uuid';\n\nexport class QueryValidationError extends Error {\n  constructor(message: string, path?: string) {\n    const fullMessage = path ? `At path '${path}': ${message}` : message;\n    super(fullMessage);\n    this.name = 'QueryValidationError';\n  }\n}\n\nconst dollarSignKeys = [\n  'where',\n  'order',\n  'limit',\n  'last',\n  'first',\n  'offset',\n  'after',\n  'before',\n  'fields',\n  'aggregate',\n];\n\ntype PossibleAttrTypes = ValueTypes | 'unknown';\n\nconst getAttrType = (\n  attrDef: DataAttrDef<any, any, any>,\n): PossibleAttrTypes => {\n  return attrDef.valueType || 'unknown';\n};\n\nconst isValidValueForType = (\n  value: unknown,\n  expectedType: PossibleAttrTypes,\n  isAnyType: boolean = false,\n): boolean => {\n  if (isAnyType) return true;\n  if (value === null || value === undefined) return true;\n\n  switch (expectedType) {\n    case 'string':\n      return typeof value === 'string';\n    case 'number':\n      return typeof value === 'number' && !isNaN(value);\n    case 'boolean':\n      return typeof value === 'boolean';\n    case 'date':\n      return (\n        value instanceof Date ||\n        typeof value === 'string' ||\n        typeof value === 'number'\n      );\n    default:\n      return true;\n  }\n};\n\nconst validateOperator = (\n  op: string,\n  opValue: unknown,\n  expectedType: PossibleAttrTypes,\n  attrName: string,\n  entityName: string,\n  attrDef: DataAttrDef<any, any, any>,\n  path: string,\n) => {\n  const isAnyType = attrDef.valueType === 'json';\n  const assertValidValue = (\n    op: string,\n    expectedType: PossibleAttrTypes,\n    opValue: unknown,\n  ) => {\n    if (!isValidValueForType(opValue, expectedType, isAnyType)) {\n      throw new QueryValidationError(\n        `Invalid value for operator '${op}' on attribute '${attrName}' in entity '${entityName}'. Expected ${expectedType}, but received: ${typeof opValue}`,\n        path,\n      );\n    }\n  };\n\n  switch (op) {\n    case 'in':\n    case '$in':\n      if (!Array.isArray(opValue)) {\n        throw new QueryValidationError(\n          `Operator '${op}' for attribute '${attrName}' in entity '${entityName}' must be an array, but received: ${typeof opValue}`,\n          path,\n        );\n      }\n      for (const item of opValue) {\n        assertValidValue(op, expectedType, item);\n      }\n      break;\n    case '$not':\n    case '$ne':\n    case '$gt':\n    case '$lt':\n    case '$gte':\n    case '$lte':\n      assertValidValue(op, expectedType, opValue);\n      break;\n    case '$like':\n    case '$ilike':\n      assertValidValue(op, 'string', opValue);\n\n      if (op === '$ilike') {\n        if (!attrDef.isIndexed) {\n          throw new QueryValidationError(\n            `Operator '${op}' can only be used with indexed attributes, but '${attrName}' in entity '${entityName}' is not indexed`,\n            path,\n          );\n        }\n      }\n\n      break;\n    case '$isNull':\n      assertValidValue(op, 'boolean', opValue);\n      break;\n    default:\n      throw new QueryValidationError(\n        `Unknown operator '${op}' for attribute '${attrName}' in entity '${entityName}'`,\n        path,\n      );\n  }\n};\n\nconst validateWhereClauseValue = (\n  value: unknown,\n  attrName: string,\n  attrDef: DataAttrDef<any, any, any>,\n  entityName: string,\n  path: string,\n): void => {\n  const expectedType = getAttrType(attrDef);\n  const isAnyType = attrDef.valueType === 'json';\n\n  const isComplexObject =\n    typeof value === 'object' && value !== null && !Array.isArray(value);\n  if (isComplexObject) {\n    // For any type, allow complex objects without treating them as operators\n    if (isAnyType) {\n      return; // Any type accepts any value, including complex objects\n    }\n\n    const operators = value as Record<string, unknown>;\n\n    for (const [op, opValue] of Object.entries(operators)) {\n      validateOperator(\n        op,\n        opValue,\n        expectedType,\n        attrName,\n        entityName,\n        attrDef,\n        `${path}.${op}`,\n      );\n    }\n  } else {\n    if (!isValidValueForType(value, expectedType, isAnyType)) {\n      throw new QueryValidationError(\n        `Invalid value for attribute '${attrName}' in entity '${entityName}'. Expected ${expectedType}, but received: ${typeof value}`,\n        path,\n      );\n    }\n  }\n};\n\nconst validateDotNotationAttribute = (\n  dotPath: string,\n  value: unknown,\n  startEntityName: string,\n  schema: IContainEntitiesAndLinks<any, any>,\n  path: string,\n): void => {\n  const pathParts = dotPath.split('.');\n  if (pathParts.length < 2) {\n    throw new QueryValidationError(\n      `Invalid dot notation path '${dotPath}'. Must contain at least one dot.`,\n      path,\n    );\n  }\n\n  let currentEntityName = startEntityName;\n\n  // Traverse all path parts except the last one (which should be an attribute)\n  for (let i = 0; i < pathParts.length - 1; i++) {\n    const linkName = pathParts[i];\n    const currentEntity = schema.entities[currentEntityName];\n\n    if (!currentEntity) {\n      throw new QueryValidationError(\n        `Entity '${currentEntityName}' does not exist in schema while traversing dot notation path '${dotPath}'.`,\n        path,\n      );\n    }\n\n    const link = currentEntity.links[linkName];\n    if (!link) {\n      const availableLinks = Object.keys(currentEntity.links);\n      throw new QueryValidationError(\n        `Link '${linkName}' does not exist on entity '${currentEntityName}' in dot notation path '${dotPath}'. Available links: ${availableLinks.length > 0 ? availableLinks.join(', ') : 'none'}`,\n        path,\n      );\n    }\n\n    currentEntityName = link.entityName;\n  }\n\n  // Validate the final attribute\n  const finalAttrName = pathParts[pathParts.length - 1];\n  const finalEntity = schema.entities[currentEntityName];\n\n  if (!finalEntity) {\n    throw new QueryValidationError(\n      `Target entity '${currentEntityName}' does not exist in schema for dot notation path '${dotPath}'.`,\n      path,\n    );\n  }\n\n  // Handle 'id' field specially - every entity has an id field\n  if (finalAttrName === 'id') {\n    if (typeof value == 'string' && !validateUUID(value)) {\n      throw new QueryValidationError(\n        `Invalid value for id field in entity '${currentEntityName}'. Expected a UUID, but received: ${value}`,\n        path,\n      );\n    }\n    validateWhereClauseValue(\n      value,\n      dotPath,\n      new DataAttrDef('string', false, true),\n      startEntityName,\n      path,\n    );\n    return;\n  }\n\n  const attrDef = finalEntity.attrs[finalAttrName];\n\n  if (Object.keys(finalEntity.links).includes(finalAttrName)) {\n    if (typeof value === 'string' && !validateUUID(value)) {\n      throw new QueryValidationError(\n        `Invalid value for link '${finalAttrName}' in entity '${currentEntityName}'. Expected a UUID, but received: ${value}`,\n        path,\n      );\n    }\n\n    validateWhereClauseValue(\n      value,\n      dotPath,\n      new DataAttrDef('string', false, true),\n      startEntityName,\n      path,\n    );\n    return;\n  }\n\n  if (!attrDef) {\n    const availableAttrs = Object.keys(finalEntity.attrs);\n    throw new QueryValidationError(\n      `Attribute '${finalAttrName}' does not exist on entity '${currentEntityName}' in dot notation path '${dotPath}'. Available attributes: ${availableAttrs.length > 0 ? availableAttrs.join(', ') + ', id' : 'id'}`,\n      path,\n    );\n  }\n\n  // Validate the value against the attribute type\n  validateWhereClauseValue(value, dotPath, attrDef, startEntityName, path);\n};\n\nconst validateWhereClause = (\n  whereClause: Record<string, unknown>,\n  entityName: string,\n  schema: IContainEntitiesAndLinks<any, any>,\n  path: string,\n): void => {\n  for (const [key, value] of Object.entries(whereClause)) {\n    if (key === 'or' || key === 'and') {\n      if (Array.isArray(value)) {\n        for (const clause of value) {\n          if (typeof clause === 'object' && clause !== null) {\n            validateWhereClause(\n              clause as Record<string, unknown>,\n              entityName,\n              schema,\n              `${path}.${key}[${clause}]`,\n            );\n          }\n        }\n      }\n      continue;\n    }\n\n    if (key === 'id') {\n      validateWhereClauseValue(\n        value,\n        'id',\n        new DataAttrDef('string', false, true),\n        entityName,\n        `${path}.id`,\n      );\n      continue;\n    }\n\n    if (key.includes('.')) {\n      validateDotNotationAttribute(\n        key,\n        value,\n        entityName,\n        schema,\n        `${path}.${key}`,\n      );\n      continue;\n    }\n\n    const entityDef = schema.entities[entityName];\n    if (!entityDef) continue;\n\n    const attrDef = entityDef.attrs[key];\n    const linkDef = entityDef.links[key];\n\n    if (!attrDef && !linkDef) {\n      const availableAttrs = Object.keys(entityDef.attrs);\n      const availableLinks = Object.keys(entityDef.links);\n      throw new QueryValidationError(\n        `Attribute or link '${key}' does not exist on entity '${entityName}'. Available attributes: ${availableAttrs.length > 0 ? availableAttrs.join(', ') : 'none'}. Available links: ${availableLinks.length > 0 ? availableLinks.join(', ') : 'none'}`,\n        `${path}.${key}`,\n      );\n    }\n\n    if (attrDef) {\n      validateWhereClauseValue(\n        value,\n        key,\n        attrDef,\n        entityName,\n        `${path}.${key}`,\n      );\n    } else if (linkDef) {\n      // For links, we expect the value to be a string (ID of the linked entity)\n      // Create a synthetic string attribute definition for validation\n      if (typeof value === 'string' && !validateUUID(value)) {\n        throw new QueryValidationError(\n          `Invalid value for link '${key}' in entity '${entityName}'. Expected a UUID, but received: ${value}`,\n          `${path}.${key}`,\n        );\n      }\n      const syntheticAttrDef = new DataAttrDef('string', false, true);\n      validateWhereClauseValue(\n        value,\n        key,\n        syntheticAttrDef,\n        entityName,\n        `${path}.${key}`,\n      );\n    }\n  }\n};\n\nconst validateDollarObject = (\n  dollarObj: Record<string, unknown>,\n  entityName: string,\n  schema?: IContainEntitiesAndLinks<any, any> | null | undefined,\n  path?: string,\n  depth: number = 0,\n): void => {\n  for (const key of Object.keys(dollarObj)) {\n    if (!dollarSignKeys.includes(key)) {\n      throw new QueryValidationError(\n        `Invalid query parameter '${key}' in $ object. Valid parameters are: ${dollarSignKeys.join(', ')}. Found: ${key}`,\n        path,\n      );\n    }\n  }\n\n  // Validate that pagination parameters are only used at top-level\n  const paginationParams = [\n    // 'limit', // only supported client side\n    'offset',\n    'before',\n    'after',\n    'first',\n    'last',\n  ];\n  for (const param of paginationParams) {\n    if (dollarObj[param] !== undefined && depth > 0) {\n      throw new QueryValidationError(\n        `'${param}' can only be used on top-level namespaces. It cannot be used in nested queries.`,\n        path,\n      );\n    }\n  }\n\n  if (dollarObj.where && schema) {\n    if (typeof dollarObj.where !== 'object' || dollarObj.where === null) {\n      throw new QueryValidationError(\n        `'where' clause must be an object in entity '${entityName}', but received: ${typeof dollarObj.where}`,\n        path ? `${path}.where` : undefined,\n      );\n    }\n    validateWhereClause(\n      dollarObj.where as Record<string, unknown>,\n      entityName,\n      schema,\n      path ? `${path}.where` : 'where',\n    );\n  }\n};\n\nconst validateEntityInQuery = (\n  queryPart: Record<string, unknown>,\n  entityName: string,\n  schema: IContainEntitiesAndLinks<any, any> | null | undefined,\n  path: string,\n  depth: number = 0,\n): void => {\n  if (!queryPart || typeof queryPart !== 'object') {\n    throw new QueryValidationError(\n      `Query part for entity '${entityName}' must be an object, but received: ${typeof queryPart}`,\n      path,\n    );\n  }\n\n  for (const key of Object.keys(queryPart)) {\n    if (key !== '$') {\n      // Validate link exists\n      if (schema && !(key in schema.entities[entityName].links)) {\n        const availableLinks = Object.keys(schema.entities[entityName].links);\n        throw new QueryValidationError(\n          `Link '${key}' does not exist on entity '${entityName}'. Available links: ${availableLinks.length > 0 ? availableLinks.join(', ') : 'none'}`,\n          `${path}.${key}`,\n        );\n      }\n\n      // Recursively validate nested query\n      const nestedQuery = queryPart[key];\n      if (typeof nestedQuery === 'object' && nestedQuery !== null) {\n        const linkedEntityName =\n          schema?.entities[entityName].links[key]?.entityName;\n        if (linkedEntityName) {\n          validateEntityInQuery(\n            nestedQuery as Record<string, unknown>,\n            linkedEntityName,\n            schema,\n            `${path}.${key}`,\n            depth + 1,\n          );\n        }\n      }\n    } else {\n      // Validate $ object\n      const dollarObj = queryPart[key];\n      if (typeof dollarObj !== 'object' || dollarObj === null) {\n        throw new QueryValidationError(\n          `Query parameter '$' must be an object in entity '${entityName}', but received: ${typeof dollarObj}`,\n          `${path}.$`,\n        );\n      }\n\n      validateDollarObject(\n        dollarObj as Record<string, unknown>,\n        entityName,\n        schema,\n        `${path}.$`,\n        depth,\n      );\n    }\n  }\n};\n\nexport const validateQuery = (\n  q: unknown,\n  schema?: IContainEntitiesAndLinks<any, any>,\n): void => {\n  if (typeof q !== 'object' || q === null) {\n    throw new QueryValidationError(\n      `Query must be an object, but received: ${typeof q}${q === null ? ' (null)' : ''}`,\n    );\n  }\n\n  if (Array.isArray(q)) {\n    throw new QueryValidationError(\n      `Query must be an object, but received: ${typeof q}`,\n    );\n  }\n\n  const queryObj = q as Record<string, unknown>;\n\n  for (const topLevelKey of Object.keys(queryObj)) {\n    if (Array.isArray(q[topLevelKey])) {\n      throw new QueryValidationError(\n        `Query keys must be strings, but found key of type: ${typeof topLevelKey}`,\n        topLevelKey,\n      );\n    }\n\n    if (typeof topLevelKey !== 'string') {\n      throw new QueryValidationError(\n        `Query keys must be strings, but found key of type: ${typeof topLevelKey}`,\n        topLevelKey,\n      );\n    }\n\n    if (topLevelKey === '$$ruleParams') {\n      continue;\n    }\n\n    // Check if the key is top level entity\n    if (schema) {\n      if (!schema.entities[topLevelKey]) {\n        const availableEntities = Object.keys(schema.entities);\n        throw new QueryValidationError(\n          `Entity '${topLevelKey}' does not exist in schema. Available entities: ${availableEntities.length > 0 ? availableEntities.join(', ') : 'none'}`,\n          topLevelKey,\n        );\n      }\n    }\n\n    validateEntityInQuery(\n      queryObj[topLevelKey] as Record<string, unknown>,\n      topLevelKey,\n      schema,\n      topLevelKey,\n      0, // Start at depth 0 for top-level entities\n    );\n  }\n};\n"]}