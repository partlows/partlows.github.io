{"version":3,"file":"instatx.js","sourceRoot":"","sources":["../../src/instatx.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  IContainEntitiesAndLinks,\n  LinkParams,\n  CreateParams,\n  UpdateParams,\n  UpdateOpts,\n  RuleParams,\n  UniqueKeys,\n  ResolveEntityAttrs,\n} from './schemaTypes.ts';\n\ntype Action =\n  | 'create'\n  | 'update'\n  | 'link'\n  | 'unlink'\n  | 'delete'\n  | 'merge'\n  | 'ruleParams';\ntype EType = string;\ntype Id = string;\ntype Args = any;\ntype LookupRef = [string, any];\ntype Lookup = string;\ntype Opts = UpdateOpts;\nexport type Op = [Action, EType, Id | LookupRef, Args, Opts?];\n\nexport interface TransactionChunk<\n  Schema extends IContainEntitiesAndLinks<any, any>,\n  EntityName extends keyof Schema['entities'],\n> {\n  __ops: Op[];\n  __etype: EntityName;\n  /**\n   * Create objects. Throws an error if the object with the provided ID already\n   * exists.\n   */\n  create: (\n    args: CreateParams<Schema, EntityName>,\n  ) => TransactionChunk<Schema, EntityName>;\n\n  /**\n   * Create and update objects. By default works in upsert mode (will create\n   * entity if that doesn't exist). Can be optionally put into \"strict update\"\n   * mode by providing { upsert: false } option as second argument:\n   *\n   * @example\n   *  const goalId = id();\n   *  // upsert\n   *  db.tx.goals[goalId].update({title: \"Get fit\", difficulty: 5})\n   *\n   *  // strict update\n   *  db.tx.goals[goalId].update({title: \"Get fit\"}, {upsert: false})\n   */\n  update: (\n    args: UpdateParams<Schema, EntityName>,\n    opts?: UpdateOpts,\n  ) => TransactionChunk<Schema, EntityName>;\n\n  /**\n   * Link two objects together\n   *\n   * @example\n   * const goalId = id();\n   * const todoId = id();\n   * db.transact([\n   *   db.tx.goals[goalId].update({title: \"Get fit\"}),\n   *   db.tx.todos[todoId].update({title: \"Go on a run\"}),\n   *   db.tx.goals[goalId].link({todos: todoId}),\n   * ])\n   *\n   * // Now, if you query:\n   * useQuery({ goals: { todos: {} } })\n   * // You'll get back:\n   *\n   * // { goals: [{ title: \"Get fit\", todos: [{ title: \"Go on a run\" }]}\n   */\n  link: (\n    args: LinkParams<Schema, EntityName>,\n  ) => TransactionChunk<Schema, EntityName>;\n  /**\n   * Unlink two objects\n   * @example\n   *  // to \"unlink\" a todo from a goal:\n   *  db.tx.goals[goalId].unlink({todos: todoId})\n   */\n  unlink: (\n    args: LinkParams<Schema, EntityName>,\n  ) => TransactionChunk<Schema, EntityName>;\n  /**\n   * Delete an object, alongside all of its links.\n   *\n   * @example\n   *   db.tx.goals[goalId].delete()\n   */\n  delete: () => TransactionChunk<Schema, EntityName>;\n\n  /**\n   *\n   * Similar to `update`, but instead of overwriting the current value, it will merge the provided values into the current value.\n   *\n   * This is useful for deeply nested, document-style values, or for updating a single attribute at an arbitrary depth without overwriting the rest of the object.\n   *\n   * For example, if you have a goal with a nested `metrics` object:\n   *\n   * ```js\n   * goal = { name: \"Get fit\", metrics: { progress: 0.3 } }\n   * ```\n   *\n   * You can update the `progress` attribute like so:\n   *\n   * ```js\n   * db.tx.goals[goalId].merge({ metrics: { progress: 0.5 }, category: \"Fitness\" })\n   * ```\n   *\n   * And the resulting object will be:\n   *\n   * ```js\n   * goal = { name: \"Get fit\", metrics: { progress: 0.5 }, category: \"Fitness\"  }\n   *  ```\n   *\n   * @example\n   *  const goalId = id();\n   *  db.tx.goals[goalId].merge({title: \"Get fitter\"})\n   */\n  merge: (\n    args: {\n      [attribute: string]: any;\n    },\n    opts?: UpdateOpts,\n  ) => TransactionChunk<Schema, EntityName>;\n\n  ruleParams: (args: RuleParams) => TransactionChunk<Schema, EntityName>;\n}\n\n// This is a hack to get typescript to enforce that\n// `allTransactionChunkKeys` contains all the keys of `TransactionChunk`\ntype TransactionChunkKey = keyof TransactionChunk<any, any>;\nfunction getAllTransactionChunkKeys(): Set<TransactionChunkKey> {\n  const v: any = 1;\n  const _dummy: TransactionChunk<any, any> = {\n    __etype: v,\n    __ops: v,\n    create: v,\n    update: v,\n    link: v,\n    unlink: v,\n    delete: v,\n    merge: v,\n    ruleParams: v,\n  };\n  return new Set(Object.keys(_dummy)) as Set<TransactionChunkKey>;\n}\nconst allTransactionChunkKeys = getAllTransactionChunkKeys();\n\nexport type ETypeChunk<\n  Schema extends IContainEntitiesAndLinks<any, any>,\n  EntityName extends keyof Schema['entities'],\n> = {\n  [id: Id]: TransactionChunk<Schema, EntityName>;\n} & {\n  lookup: <Name extends UniqueKeys<Schema['entities'][EntityName]['attrs']>>(\n    attrName: Name,\n    value: ResolveEntityAttrs<Schema['entities'][EntityName]>[Name],\n  ) => TransactionChunk<Schema, EntityName>;\n};\n\nexport type TxChunk<Schema extends IContainEntitiesAndLinks<any, any>> = {\n  [EntityName in keyof Schema['entities']]: ETypeChunk<Schema, EntityName>;\n};\n\nfunction transactionChunk(\n  etype: EType,\n  id: Id | LookupRef,\n  prevOps: Op[],\n): TransactionChunk<any, any> {\n  const target = {\n    __etype: etype,\n    __ops: prevOps,\n  };\n  return new Proxy(target as unknown as TransactionChunk<any, any>, {\n    get: (_target, cmd: keyof TransactionChunk<any, any>) => {\n      if (cmd === '__ops') return prevOps;\n      if (cmd === '__etype') return etype;\n      if (!allTransactionChunkKeys.has(cmd)) {\n        return undefined;\n      }\n      return (args: Args, opts?: Opts) => {\n        return transactionChunk(etype, id, [\n          ...prevOps,\n          opts ? [cmd, etype, id, args, opts] : [cmd, etype, id, args],\n        ]);\n      };\n    },\n  });\n}\n\n/**\n * Creates a lookup to use in place of an id in a transaction\n *\n * @example\n * db.tx.users[lookup('email', 'lyndon@example.com')].update({name: 'Lyndon'})\n */\nexport function lookup(attribute: string, value: any): Lookup {\n  return `lookup__${attribute}__${JSON.stringify(value)}`;\n}\n\nexport function isLookup(k: string): boolean {\n  return k.startsWith('lookup__');\n}\n\nexport function parseLookup(k: string): LookupRef {\n  const [_, attribute, ...vJSON] = k.split('__');\n  return [attribute, JSON.parse(vJSON.join('__'))];\n}\n\nfunction etypeChunk(etype: EType): ETypeChunk<any, EType> {\n  return new Proxy(\n    {\n      __etype: etype,\n    } as unknown as ETypeChunk<any, EType>,\n    {\n      get(_target, cmd: Id) {\n        if (cmd === 'lookup') {\n          return (attrName: string, value: any) =>\n            transactionChunk(etype, parseLookup(lookup(attrName, value)), []);\n        }\n        if (cmd === '__etype') return etype;\n        const id = cmd;\n        if (isLookup(id)) {\n          return transactionChunk(etype, parseLookup(id), []);\n        }\n        return transactionChunk(etype, id, []);\n      },\n    },\n  );\n}\n\nexport function txInit<\n  Schema extends IContainEntitiesAndLinks<any, any>,\n>(): TxChunk<Schema> {\n  return new Proxy(\n    {},\n    {\n      get(_target, ns: EType) {\n        return etypeChunk(ns);\n      },\n    },\n  ) as any;\n}\n\n/**\n * A handy builder for changes.\n *\n * You must start with the `namespace` you want to change:\n *\n * @example\n *   db.tx.goals[goalId].update({title: \"Get fit\"})\n *   // Note: you don't need to create `goals` ahead of time.\n */\nexport const tx = txInit();\n\nexport function getOps(x: TransactionChunk<any, any>): Op[] {\n  return x.__ops;\n}\n"]}