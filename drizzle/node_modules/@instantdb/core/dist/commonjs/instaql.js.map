{"version":3,"file":"instaql.js","sourceRoot":"","sources":["../../src/instaql.ts"],"names":[],"mappings":"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","sourcesContent":["import { query as datalogQuery } from './datalog.js';\nimport { uuidCompare } from './utils/id.ts';\nimport { stringCompare } from './utils/strings.ts';\nimport * as s from './store.ts';\nimport { InstantDBAttr } from './attrTypes.ts';\nimport { Cursor } from './queryTypes.ts';\n\ntype Pat = [string | any, string, string | any, string | number];\ntype Pats = Array<Pat>;\ntype OrPat = {\n  or: {\n    patterns: FullPats;\n    joinSym: string;\n  };\n};\ntype AndPat = {\n  and: {\n    patterns: FullPats;\n    joinSym: string;\n  };\n};\ntype FullPat = Pat | OrPat | AndPat;\ntype FullPats = Array<FullPat>;\n\n// Pattern variables\n// -----------------\n\ntype MakeVar = (x: string, level: number) => string;\n\nlet _seed = 0;\n\nfunction wildcard(friendlyName: string) {\n  return makeVarImpl(`_${friendlyName}`, _seed++);\n}\n\nfunction makeVarImpl(x: string, level: number): string {\n  return `?${x}-${level}`;\n}\n\n// Where\n// -----------------\n\nclass AttrNotFoundError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'AttrNotFoundError';\n  }\n}\n\nfunction idAttr(attrsStore: s.AttrsStore, ns: string): InstantDBAttr {\n  const attr = s.getPrimaryKeyAttr(attrsStore, ns);\n\n  if (!attr) {\n    throw new AttrNotFoundError(`Could not find id attr for ${ns}`);\n  }\n  return attr;\n}\n\nfunction defaultWhere(\n  makeVar: MakeVar,\n  attrsStore: s.AttrsStore,\n  etype: string,\n  level: number,\n): Pats {\n  return [eidWhere(makeVar, attrsStore, etype, level)];\n}\n\nfunction eidWhere(\n  makeVar: MakeVar,\n  attrsStore: s.AttrsStore,\n  etype: string,\n  level: number,\n): Pat {\n  return [\n    makeVar(etype, level),\n    idAttr(attrsStore, etype).id,\n    makeVar(etype, level),\n    makeVar('time', level),\n  ];\n}\n\nfunction replaceInAttrPat(attrPat: Pat, needle: string, v: any): Pat {\n  return attrPat.map((x) => (x === needle ? v : x)) as Pat;\n}\n\nfunction refAttrPat(\n  makeVar: MakeVar,\n  attrsStore: s.AttrsStore,\n  etype: string,\n  level: number,\n  label: string,\n): [string, number, Pat, InstantDBAttr, boolean] {\n  const fwdAttr = s.getAttrByFwdIdentName(attrsStore, etype, label);\n  const revAttr = s.getAttrByReverseIdentName(attrsStore, etype, label);\n  const attr = fwdAttr || revAttr;\n\n  if (!attr) {\n    throw new AttrNotFoundError(`Could not find attr for ${[etype, label]}`);\n  }\n\n  if (attr['value-type'] !== 'ref') {\n    throw new Error(`Attr ${attr.id} is not a ref`);\n  }\n\n  const [_f, fwdEtype] = attr['forward-identity'];\n  const [_r, revEtype] = attr['reverse-identity']!;\n  const nextLevel = level + 1;\n  const attrPat: Pat = fwdAttr\n    ? [\n        makeVar(fwdEtype, level),\n        attr.id,\n        makeVar(revEtype, nextLevel),\n        wildcard('time'),\n      ]\n    : [\n        makeVar(fwdEtype, nextLevel),\n        attr.id,\n        makeVar(revEtype, level),\n        wildcard('time'),\n      ];\n\n  const nextEtype = fwdAttr ? revEtype : fwdEtype;\n\n  const isForward = Boolean(fwdAttr);\n\n  return [nextEtype, nextLevel, attrPat, attr, isForward];\n}\n\nfunction makeLikeMatcher(caseSensitive: boolean, pattern: string) {\n  if (typeof pattern !== 'string') {\n    return function likeMatcher(_value) {\n      return false;\n    };\n  }\n\n  const escapedPattern = pattern.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  const regexPattern = escapedPattern.replace(/%/g, '.*').replace(/_/g, '.');\n\n  const regex = new RegExp(\n    `^${regexPattern}$`,\n    caseSensitive ? undefined : 'i',\n  );\n\n  return function likeMatcher(value) {\n    if (typeof value !== 'string') {\n      return false;\n    }\n    return regex.test(value);\n  };\n}\n\nfunction parseValue(attr: InstantDBAttr, v: any) {\n  if (\n    typeof v !== 'object' ||\n    v.hasOwnProperty('$in') ||\n    v.hasOwnProperty('in')\n  ) {\n    return v;\n  }\n\n  const isDate = attr['checked-data-type'] === 'date';\n\n  if (v.hasOwnProperty('$gt')) {\n    return {\n      $comparator: true,\n      $op: isDate\n        ? function gtDate(triple) {\n            return new Date(triple[2]) > new Date(v.$gt);\n          }\n        : function gt(triple) {\n            return triple[2] > v.$gt;\n          },\n    };\n  }\n  if (v.hasOwnProperty('$gte')) {\n    return {\n      $comparator: true,\n      $op: isDate\n        ? function gteDate(triple) {\n            return new Date(triple[2]) >= new Date(v.$gte);\n          }\n        : function gte(triple) {\n            return triple[2] >= v.$gte;\n          },\n    };\n  }\n\n  if (v.hasOwnProperty('$lt')) {\n    return {\n      $comparator: true,\n      $op: isDate\n        ? function ltDate(triple) {\n            return new Date(triple[2]) < new Date(v.$lt);\n          }\n        : function lt(triple) {\n            return triple[2] < v.$lt;\n          },\n    };\n  }\n  if (v.hasOwnProperty('$lte')) {\n    return {\n      $comparator: true,\n      $op: isDate\n        ? function lteDate(triple) {\n            return new Date(triple[2]) <= new Date(v.$lte);\n          }\n        : function lte(triple) {\n            return triple[2] <= v.$lte;\n          },\n    };\n  }\n\n  if (v.hasOwnProperty('$like')) {\n    const matcher = makeLikeMatcher(true, v.$like);\n    return {\n      $comparator: true,\n      $op: function like(triple) {\n        return matcher(triple[2]);\n      },\n    };\n  }\n\n  if (v.hasOwnProperty('$ilike')) {\n    const matcher = makeLikeMatcher(false, v.$ilike);\n    return {\n      $comparator: true,\n      $op: function ilike(triple) {\n        return matcher(triple[2]);\n      },\n    };\n  }\n\n  return v;\n}\n\nfunction valueAttrPat(\n  makeVar: MakeVar,\n  attrsStore: s.AttrsStore,\n  valueEtype: string,\n  valueLevel: number,\n  valueLabel: string,\n  v: any,\n): Pat {\n  const fwdAttr = s.getAttrByFwdIdentName(attrsStore, valueEtype, valueLabel);\n  const revAttr = s.getAttrByReverseIdentName(\n    attrsStore,\n    valueEtype,\n    valueLabel,\n  );\n  const attr = fwdAttr || revAttr;\n\n  if (!attr) {\n    throw new AttrNotFoundError(\n      `No attr for etype = ${valueEtype} label = ${valueLabel}`,\n    );\n  }\n\n  if (v?.hasOwnProperty('$isNull')) {\n    const idAttr = s.getAttrByFwdIdentName(attrsStore, valueEtype, 'id');\n    if (!idAttr) {\n      throw new AttrNotFoundError(\n        `No attr for etype = ${valueEtype} label = id`,\n      );\n    }\n\n    return [\n      makeVar(valueEtype, valueLevel),\n      idAttr.id,\n      { $isNull: { attrId: attr.id, isNull: v.$isNull, reverse: !fwdAttr } },\n      wildcard('time'),\n    ];\n  }\n\n  if (fwdAttr) {\n    return [\n      makeVar(valueEtype, valueLevel),\n      attr.id,\n      parseValue(attr, v),\n      wildcard('time'),\n    ];\n  }\n  return [v, attr.id, makeVar(valueEtype, valueLevel), wildcard('time')];\n}\n\nfunction refAttrPats(\n  makeVar: MakeVar,\n  attrsStore: s.AttrsStore,\n  etype: string,\n  level: number,\n  refsPath: string[],\n): [string, number, Pats] {\n  const [lastEtype, lastLevel, attrPats] = refsPath.reduce(\n    (acc, label) => {\n      const [etype, level, attrPats] = acc;\n      const [nextEtype, nextLevel, attrPat] = refAttrPat(\n        makeVar,\n        attrsStore,\n        etype,\n        level,\n        label,\n      );\n      return [nextEtype, nextLevel, [...attrPats, attrPat]];\n    },\n    [etype, level, []],\n  );\n\n  return [lastEtype, lastLevel, attrPats];\n}\n\nfunction whereCondAttrPats(\n  makeVar: MakeVar,\n  attrsStore: s.AttrsStore,\n  etype: string,\n  level: number,\n  path: string[],\n  v: any,\n): Pats {\n  const refsPath = path.slice(0, path.length - 1);\n  const valueLabel = path[path.length - 1];\n  const [lastEtype, lastLevel, refPats] = refAttrPats(\n    makeVar,\n    attrsStore,\n    etype,\n    level,\n    refsPath,\n  );\n  const valuePat = valueAttrPat(\n    makeVar,\n    attrsStore,\n    lastEtype,\n    lastLevel,\n    valueLabel,\n    v,\n  );\n\n  return refPats.concat([valuePat]);\n}\n\nfunction withJoin(where, join) {\n  return join ? [join].concat(where) : where;\n}\n\nfunction isOrClauses([k, v]): boolean {\n  return k === 'or' && Array.isArray(v);\n}\n\nfunction isAndClauses([k, v]): boolean {\n  return k === 'and' && Array.isArray(v);\n}\n\n// Creates a makeVar that will namespace symbols for or clauses\n// to prevent conflicts, except for the base etype\nfunction genMakeVar(baseMakeVar: MakeVar, joinSym: string, orIdx: number) {\n  return (x, lvl) => {\n    const base = baseMakeVar(x, lvl);\n    if (joinSym == base) {\n      return base;\n    }\n    return `${base}-${orIdx}`;\n  };\n}\n\nfunction parseWhereClauses(\n  makeVar: MakeVar,\n  clauseType: 'or' | 'and' /* 'or' | 'and' */,\n  attrsStore: s.AttrsStore,\n  etype: string,\n  level: number,\n  whereValue: any,\n): FullPat {\n  const joinSym = makeVar(etype, level);\n  const patterns: FullPats = whereValue.map((w, i) => {\n    const makeNamespacedVar = genMakeVar(makeVar, joinSym, i);\n    return parseWhere(makeNamespacedVar, attrsStore, etype, level, w);\n  });\n  return { [clauseType]: { patterns, joinSym } } as AndPat | OrPat;\n}\n\n// Given a path, returns a list of paths leading up to this path:\n// growPath([1, 2, 3]) -> [[1], [1, 2], [1, 2, 3]]\nfunction growPath<T>(path: T[]) {\n  const ret: Array<T[]> = [];\n  for (let i = 1; i <= path.length; i++) {\n    ret.push(path.slice(0, i));\n  }\n  return ret;\n}\n\n// Returns array of pattern arrays that should be grouped in OR\n// to capture any intermediate nulls\nfunction whereCondAttrPatsForNullIsTrue(\n  makeVar: MakeVar,\n  attrsStore: s.AttrsStore,\n  etype: string,\n  level: number,\n  path: string[],\n): Pats[] {\n  return growPath(path).map((path) =>\n    whereCondAttrPats(makeVar, attrsStore, etype, level, path, {\n      $isNull: true,\n    }),\n  );\n}\n\nfunction parseWhere(\n  makeVar: MakeVar,\n  attrsStore: s.AttrsStore,\n  etype: string,\n  level: number,\n  where: Record<string, any>,\n): FullPats {\n  return Object.entries(where).flatMap(([k, v]) => {\n    if (isOrClauses([k, v])) {\n      return parseWhereClauses(makeVar, 'or', attrsStore, etype, level, v);\n    }\n    if (isAndClauses([k, v])) {\n      return parseWhereClauses(makeVar, 'and', attrsStore, etype, level, v);\n    }\n\n    // Temporary hack until we have support for a uuid index on `id`\n    if (k === '$entityIdStartsWith') {\n      return [];\n    }\n\n    const path = k.split('.');\n\n    // Normalize $ne to $not\n    if (v?.hasOwnProperty('$ne')) {\n      v = { ...v, $not: v.$ne };\n      delete v.$ne;\n    }\n\n    if (v?.hasOwnProperty('$not')) {\n      // `$not` won't pick up entities that are missing the attr, so we\n      // add in a `$isNull` to catch those too.\n      const notPats = whereCondAttrPats(\n        makeVar,\n        attrsStore,\n        etype,\n        level,\n        path,\n        v,\n      );\n      const nilPats = whereCondAttrPatsForNullIsTrue(\n        makeVar,\n        attrsStore,\n        etype,\n        level,\n        path,\n      );\n      return [\n        {\n          or: {\n            patterns: [notPats, ...nilPats],\n            joinSym: makeVar(etype, level),\n          },\n        },\n      ];\n    }\n\n    if (v?.hasOwnProperty('$isNull') && v.$isNull === true && path.length > 1) {\n      // Make sure we're capturing all of the intermediate paths that might be null\n      // by checking for null at each step along the path\n      return [\n        {\n          or: {\n            patterns: whereCondAttrPatsForNullIsTrue(\n              makeVar,\n              attrsStore,\n              etype,\n              level,\n              path,\n            ),\n            joinSym: makeVar(etype, level),\n          },\n        },\n      ];\n    }\n\n    return whereCondAttrPats(makeVar, attrsStore, etype, level, path, v);\n  });\n}\n\nfunction makeWhere(\n  attrsStore: s.AttrsStore,\n  etype: string,\n  level: number,\n  where: Record<string, any> | null,\n): FullPats {\n  const makeVar = makeVarImpl;\n  if (!where) {\n    return defaultWhere(makeVar, attrsStore, etype, level);\n  }\n  const parsedWhere = parseWhere(makeVar, attrsStore, etype, level, where);\n  return parsedWhere.concat(defaultWhere(makeVar, attrsStore, etype, level));\n}\n\n// Find\n// -----------------\n\nfunction makeFind(makeVar: MakeVar, etype: string, level: number) {\n  return [makeVar(etype, level), makeVar('time', level)];\n}\n\n// extendObjects\n// -----------------\n\nfunction makeJoin(\n  makeVar: MakeVar,\n  attrsStore: s.AttrsStore,\n  etype: string,\n  level: number,\n  label: string,\n  eid: string,\n) {\n  const [nextEtype, nextLevel, pat, attr, isForward] = refAttrPat(\n    makeVar,\n    attrsStore,\n    etype,\n    level,\n    label,\n  );\n  const actualized = replaceInAttrPat(pat, makeVar(etype, level), eid);\n  return [nextEtype, nextLevel, actualized, attr, isForward];\n}\n\nfunction extendObjects(\n  makeVar: MakeVar,\n  store: s.Store,\n  attrsStore: s.AttrsStore,\n  { etype, level, form },\n  objects,\n) {\n  const childQueries = Object.keys(form).filter((c) => c !== '$');\n  if (!childQueries.length) {\n    return Object.values(objects);\n  }\n  return Object.entries(objects).map(function extendChildren([eid, parent]) {\n    const childResults = childQueries.map(function getChildResult(label) {\n      const isSingular = Boolean(\n        store.cardinalityInference &&\n          attrsStore.linkIndex?.[etype]?.[label]?.isSingular,\n      );\n\n      try {\n        const [nextEtype, nextLevel, join] = makeJoin(\n          makeVar,\n          attrsStore,\n          etype,\n          level,\n          label,\n          eid,\n        );\n\n        const childrenArray = queryOne(store, attrsStore, {\n          etype: nextEtype,\n          level: nextLevel,\n          form: form[label],\n          join,\n        });\n\n        const childOrChildren = isSingular ? childrenArray[0] : childrenArray;\n\n        return { [label]: childOrChildren };\n      } catch (e) {\n        if (e instanceof AttrNotFoundError) {\n          return { [label]: isSingular ? undefined : [] };\n        }\n        throw e;\n      }\n    });\n\n    return childResults.reduce(function reduceChildren(parent, child) {\n      return { ...parent, ...child };\n    }, parent);\n  });\n}\n\n// resolveObjects\n// -----------------\n\nfunction shouldIgnoreAttr(attrs, id) {\n  const attr = attrs[id];\n  return attr['value-type'] === 'ref' && attr['forward-identity'][2] !== 'id';\n}\n\n// Compares values where we already know that the two values are distinct\n// and not null.\n// Takes into account the data type.\nfunction compareDisparateValues(a, b, dataType) {\n  if (dataType === 'string') {\n    return stringCompare(a, b);\n  }\n  if (a > b) {\n    return 1;\n  }\n  return -1;\n}\n\nexport function compareOrder(id_a: string, v_a, id_b: string, v_b, dataType) {\n  if (v_a === v_b || (v_a == null && v_b == null)) {\n    return uuidCompare(id_a, id_b);\n  }\n\n  if (v_b == null) {\n    return 1;\n  }\n  if (v_a == null) {\n    return -1;\n  }\n\n  return compareDisparateValues(v_a, v_b, dataType);\n}\n\nfunction compareOrderTriples(\n  [id_a, v_a]: [string, any],\n  [id_b, v_b]: [string, any],\n  dataType,\n) {\n  return compareOrder(id_a, v_a, id_b, v_b, dataType);\n}\n\nfunction comparableDate(x) {\n  if (x == null) {\n    return x;\n  }\n  return new Date(x).getTime();\n}\n\nfunction isBefore(startCursor, orderAttr, direction, idVec) {\n  const [c_e, _c_a, c_v, c_t] = startCursor;\n  const compareVal = direction === 'desc' ? 1 : -1;\n  if (orderAttr['forward-identity']?.[2] === 'id') {\n    return compareOrderTriples(idVec, [c_e, c_t], null) === compareVal;\n  }\n  const [e, v] = idVec;\n  const dataType = orderAttr['checked-data-type'];\n  const v_new = dataType === 'date' ? comparableDate(v) : v;\n  const c_v_new = dataType === 'date' ? comparableDate(c_v) : c_v;\n\n  return (\n    compareOrderTriples([e, v_new], [c_e, c_v_new], dataType) === compareVal\n  );\n}\n\nfunction orderAttrFromCursor(attrsStore: s.AttrsStore, cursor) {\n  const cursorAttrId = cursor[1];\n  return attrsStore.getAttr(cursorAttrId);\n}\n\nfunction orderAttrFromOrder(attrsStore: s.AttrsStore, etype, order) {\n  const label = Object.keys(order)[0];\n  return s.getAttrByFwdIdentName(attrsStore, etype, label);\n}\n\nfunction getOrderAttr(attrsStore: s.AttrsStore, etype, cursor, order) {\n  if (cursor) {\n    return orderAttrFromCursor(attrsStore, cursor);\n  }\n  if (order) {\n    return orderAttrFromOrder(attrsStore, etype, order);\n  }\n}\n\nfunction objectAttrs(\n  attrsStore: s.AttrsStore,\n  etype,\n  dq,\n): Map<string, InstantDBAttr> | undefined {\n  if (!Array.isArray(dq.fields)) {\n    return s.getBlobAttrs(attrsStore, etype);\n  }\n\n  const attrs = new Map();\n\n  for (const field of dq.fields) {\n    const attr = s.getAttrByFwdIdentName(attrsStore, etype, field);\n    const label = attr?.['forward-identity']?.[2];\n    if (label && s.isBlob(attr)) {\n      attrs.set(label, attr);\n    }\n  }\n  // Ensure we add the id field to avoid empty objects\n  if (!attrs.has('id')) {\n    const attr = s.getAttrByFwdIdentName(attrsStore, etype, 'id');\n    const label = attr?.['forward-identity']?.[2];\n    if (label) {\n      attrs.set(label, attr);\n    }\n  }\n\n  return attrs;\n}\n\nfunction runDataloadAndReturnObjects(\n  store: s.Store,\n  attrsStore: s.AttrsStore,\n  { etype, pageInfo, dq, form },\n) {\n  const order = form?.$?.order;\n  const isLeadingQuery = isLeading(form);\n  const direction = determineDirection(form);\n\n  let idVecs = datalogQuery(store, dq);\n\n  const startCursor = pageInfo?.['start-cursor'];\n  const orderAttr = getOrderAttr(attrsStore, etype, startCursor, order);\n\n  if (orderAttr && orderAttr?.['forward-identity']?.[2] !== 'id') {\n    const isDate = orderAttr['checked-data-type'] === 'date';\n    const a = orderAttr.id;\n    idVecs = idVecs.map(([id]) => {\n      // order attr is required to be cardinality one, so there will\n      // be at most one value here\n      let v = store.eav.get(id)?.get(a)?.values()?.next()?.value?.[2];\n      if (isDate) {\n        v = comparableDate(v);\n      }\n      return [id, v];\n    });\n  }\n\n  idVecs.sort(\n    direction === 'asc'\n      ? function compareIdVecs(a, b) {\n          return compareOrderTriples(a, b, orderAttr?.['checked-data-type']);\n        }\n      : function compareIdVecs(a, b) {\n          return compareOrderTriples(b, a, orderAttr?.['checked-data-type']);\n        },\n  );\n\n  let objects = {};\n  const attrs = objectAttrs(attrsStore, etype, dq);\n\n  for (const idVec of idVecs) {\n    const [id] = idVec;\n    if (objects[id]) {\n      continue;\n    }\n    if (\n      !isLeadingQuery &&\n      startCursor &&\n      orderAttr &&\n      isBefore(startCursor, orderAttr, direction, idVec)\n    ) {\n      continue;\n    }\n\n    const obj = s.getAsObject(store, attrs, id);\n    if (obj) {\n      objects[id] = obj;\n    }\n  }\n  return objects;\n}\n\nfunction determineDirection(form) {\n  const orderOpts = form.$?.order;\n  if (!orderOpts) {\n    return 'asc';\n  }\n\n  return orderOpts[Object.keys(orderOpts)[0]] || 'asc';\n}\n\n/**\n * A \"leading\" query has no `offset`, `before`, or `after`\n *\n * It is at the 'beginning' of the order\n */\nfunction isLeading(form) {\n  const offset = form.$?.offset;\n  const before = form.$?.before;\n  const after = form.$?.after;\n  return !offset && !before && !after;\n}\n\n/**\n * Given a query like:\n *\n * {\n *   users: {\n *     $: { where: { name: \"Joe\" } },\n *   },\n * };\n *\n * `resolveObjects`, turns where clause: `{ name: \"Joe\" }`\n * into a datalog query. We then run the datalog query,\n * and reduce all the triples into objects.\n */\nfunction resolveObjects(\n  store: s.Store,\n  attrsStore: s.AttrsStore,\n  { etype, level, form, join, pageInfo },\n) {\n  // Wait for server to tell us where we start if we don't start from the beginning\n  if (!isLeading(form) && (!pageInfo || !pageInfo['start-cursor'])) {\n    return [];\n  }\n\n  const where = withJoin(\n    makeWhere(attrsStore, etype, level, form.$?.where),\n    join,\n  );\n  const find = makeFind(makeVarImpl, etype, level);\n  const fields = form.$?.fields;\n\n  const objs = runDataloadAndReturnObjects(store, attrsStore, {\n    etype,\n    pageInfo,\n    form,\n    dq: { where, find, fields },\n  });\n\n  const limit = form.$?.limit || form.$?.first || form.$?.last;\n  if (limit != null) {\n    if (level > 0) {\n      console.warn(\n        'WARNING: Limits in child queries are only run client-side. Data returned from the server will not have a limit.',\n      );\n    }\n\n    const entries = Object.entries(objs);\n    if (entries.length <= limit) {\n      return objs;\n    }\n    return Object.fromEntries(entries.slice(0, limit));\n  }\n\n  return objs;\n}\n\n/**\n * It's possible that we query\n * for an attribute that doesn't exist yet.\n *\n * { users: { $: { where: { nonExistentProperty: \"foo\" } } } }\n *\n * This swallows the missing attr error and returns\n * an empty result instead\n */\nfunction guardedResolveObjects(store: s.Store, attrsStore: s.AttrsStore, opts) {\n  try {\n    return resolveObjects(store, attrsStore, opts);\n  } catch (e) {\n    if (e instanceof AttrNotFoundError) {\n      return {};\n    }\n    throw e;\n  }\n}\n/**\n * Given a query like:\n *\n * {\n *   users: {\n *     $: { where: { name: \"Joe\" } },\n *     posts: {},\n *   },\n * };\n *\n * `guardResolveObjects` will return the relevant `users` objects\n * `extendObjects` will then extend each `user` object with relevant `posts`.\n */\nfunction queryOne(store: s.Store, attrsStore: s.AttrsStore, opts) {\n  const objects = guardedResolveObjects(store, attrsStore, opts);\n  return extendObjects(makeVarImpl, store, attrsStore, opts, objects);\n}\n\nfunction formatPageInfo(\n  pageInfo: Record<\n    string,\n    {\n      'start-cursor'?: Cursor | null;\n      'end-cursor'?: Cursor | null;\n      'has-next-page?'?: boolean | null;\n      'has-previous-page?'?: boolean | null;\n    }\n  >,\n) {\n  const res = {};\n  for (const [k, v] of Object.entries(pageInfo)) {\n    res[k] = {\n      startCursor: v['start-cursor'],\n      endCursor: v['end-cursor'],\n      hasNextPage: v['has-next-page?'],\n      hasPreviousPage: v['has-previous-page?'],\n    };\n  }\n  return res;\n}\n\nexport default function query(\n  {\n    store,\n    attrsStore,\n    pageInfo,\n    aggregate,\n  }: {\n    store: s.Store;\n    attrsStore: s.AttrsStore;\n    pageInfo?: any;\n    aggregate?: any;\n  },\n  q,\n) {\n  const data = Object.keys(q).reduce(function reduceResult(res, k) {\n    if (aggregate?.[k] || '$$ruleParams' === k) {\n      // Aggregate doesn't return any join rows and has no children,\n      // so don't bother querying further\n      return res;\n    }\n    res[k] = queryOne(store, attrsStore, {\n      etype: k,\n      form: q[k],\n      level: 0,\n      pageInfo: pageInfo?.[k],\n    });\n    return res;\n  }, {});\n\n  const result: { data: any; pageInfo?: any; aggregate?: any } = { data };\n  if (pageInfo) {\n    result.pageInfo = formatPageInfo(pageInfo);\n  }\n\n  if (aggregate) {\n    result.aggregate = aggregate;\n  }\n\n  return result;\n}\n"]}