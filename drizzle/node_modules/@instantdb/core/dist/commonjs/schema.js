"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.i = void 0;
const schemaTypes_ts_1 = require("./schemaTypes.js");
// ==========
// API
/**
 * @deprecated
 * `i.graph` is deprecated. Use `i.schema` instead.
 *
 * @example
 * // Before
 * i.graph(entities, links).withRoomSchema<RoomType>();
 *
 * // After
 * i.schema({ entities, links, rooms })
 *
 * @see
 * https://instantdb.com/docs/modeling-data
 */
function graph(entities, links) {
    return new schemaTypes_ts_1.InstantSchemaDef(enrichEntitiesWithLinks(entities, links), 
    // (XXX): LinksDef<any> stems from TypeScriptâ€™s inability to reconcile the
    // type EntitiesWithLinks<EntitiesWithoutLinks, Links> with
    // EntitiesWithoutLinks. TypeScript is strict about ensuring that types are
    // correctly aligned and does not allow for substituting a type that might
    // be broader or have additional properties.
    links, undefined);
}
/**
 * Creates an entity definition, to be used in conjunction with `i.graph`.
 *
 * @see https://instantdb.com/docs/modeling-data
 * @example
 *   {
 *     posts: i.entity({
 *       title: i.string(),
 *       body: i.string(),
 *     }),
 *     comments: i.entity({
 *       body: i.string(),
 *     })
 *   }
 */
function entity(attrs) {
    return new schemaTypes_ts_1.EntityDef(attrs, {});
}
function string() {
    return new schemaTypes_ts_1.DataAttrDef('string', true, false);
}
function number() {
    return new schemaTypes_ts_1.DataAttrDef('number', true, false);
}
function boolean() {
    return new schemaTypes_ts_1.DataAttrDef('boolean', true, false);
}
function date() {
    return new schemaTypes_ts_1.DataAttrDef('date', true, false);
}
function json() {
    return new schemaTypes_ts_1.DataAttrDef('json', true, false);
}
function any() {
    return new schemaTypes_ts_1.DataAttrDef('json', true, false);
}
// ==========
// internal
function enrichEntitiesWithLinks(entities, links) {
    const linksIndex = { fwd: {}, rev: {} };
    for (const linkDef of Object.values(links)) {
        linksIndex.fwd[linkDef.forward.on] ||= {};
        linksIndex.rev[linkDef.reverse.on] ||= {};
        linksIndex.fwd[linkDef.forward.on][linkDef.forward.label] = {
            entityName: linkDef.reverse.on,
            cardinality: linkDef.forward.has,
        };
        linksIndex.rev[linkDef.reverse.on][linkDef.reverse.label] = {
            entityName: linkDef.forward.on,
            cardinality: linkDef.reverse.has,
        };
    }
    const enrichedEntities = Object.fromEntries(Object.entries(entities).map(([name, def]) => [
        name,
        new schemaTypes_ts_1.EntityDef(def.attrs, {
            ...linksIndex.fwd[name],
            ...linksIndex.rev[name],
        }),
    ]));
    return enrichedEntities;
}
/**
 * Lets you define a schema for your database.
 *
 * You can define entities, links between entities, and if you use
 * presence, you can define rooms.
 *
 * You can push this schema to your database with the CLI,
 * or use it inside `init`, to get typesafety and autocompletion.
 *
 * @see https://instantdb.com/docs/modeling-data
 * @example
 *   i.schema({
 *     entities: { },
 *     links: { },
 *     rooms: { }
 *   });
 */
function schema({ entities, links, rooms, }) {
    const linksDef = (links ?? {});
    const roomsDef = (rooms ?? {});
    return new schemaTypes_ts_1.InstantSchemaDef(enrichEntitiesWithLinks(entities, linksDef), 
    // (XXX): LinksDef<any> stems from TypeScript's inability to reconcile the
    // type EntitiesWithLinks<EntitiesWithoutLinks, Links> with
    // EntitiesWithoutLinks. TypeScript is strict about ensuring that types are
    // correctly aligned and does not allow for substituting a type that might
    // be broader or have additional properties.
    linksDef, roomsDef);
}
exports.i = {
    // constructs
    graph,
    schema,
    entity,
    // value types
    string,
    number,
    boolean,
    date,
    json,
    any,
};
//# sourceMappingURL=schema.js.map