var _i = Object.defineProperty;
var wi = (t, e, n) => e in t ? _i(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var p = (t, e, n) => wi(t, typeof e != "symbol" ? e + "" : e, n);
import ts, { useRef as it, useCallback as _e, useSyncExternalStore as tn, useEffect as Oe, useMemo as nn, useState as ns, createElement as Ti } from "react";
function q(t) {
  if (typeof t == "number")
    return (Math.abs(t * 2654435761) >>> 0).toString(16);
  if (typeof t == "boolean")
    return t ? "1" : "0";
  if (t === null)
    return "null";
  if (t === void 0)
    return "undefined";
  if (typeof t == "string") {
    let e = 2166136261;
    for (let n = 0; n < t.length; n++)
      e ^= t.charCodeAt(n), e += (e << 1) + (e << 4) + (e << 7) + (e << 8) + (e << 24), e = e >>> 0;
    return e.toString(16);
  }
  if (Array.isArray(t)) {
    let e = 2166136261;
    for (let n = 0; n < t.length; n++) {
      e ^= (n + 1) * 2654435761;
      const r = q(t[n]);
      for (let s = 0; s < r.length; s++)
        e ^= r.charCodeAt(s), e *= 16777619, e = e >>> 0;
    }
    return e.toString(16);
  }
  if (typeof t == "object") {
    let e = 2166136261;
    const n = Object.keys(t).sort();
    for (let r = 0; r < n.length; r++) {
      const s = n[r], i = q(s);
      e ^= parseInt(i, 16), e *= 16777619, e = e >>> 0;
      const o = q(t[s]);
      e ^= parseInt(o, 16), e *= 16777619, e = e >>> 0;
    }
    return e.toString(16);
  }
  return q(String(t));
}
const U = {
  Remove: "remove",
  Replace: "replace",
  Add: "add"
}, rs = Symbol.for("__MUTATIVE_PROXY_DRAFT__"), mi = Symbol("__MUTATIVE_RAW_RETURN_SYMBOL__"), wt = Symbol.iterator, ne = {
  mutable: "mutable",
  immutable: "immutable"
}, In = {};
function et(t, e) {
  return t instanceof Map ? t.has(e) : Object.prototype.hasOwnProperty.call(t, e);
}
function pr(t, e) {
  if (e in t) {
    let n = Reflect.getPrototypeOf(t);
    for (; n; ) {
      const r = Reflect.getOwnPropertyDescriptor(n, e);
      if (r)
        return r;
      n = Reflect.getPrototypeOf(n);
    }
  }
}
function Mn(t) {
  return Object.getPrototypeOf(t) === Set.prototype;
}
function jn(t) {
  return Object.getPrototypeOf(t) === Map.prototype;
}
function te(t) {
  var e;
  return (e = t.copy) !== null && e !== void 0 ? e : t.original;
}
function Ae(t) {
  return !!P(t);
}
function P(t) {
  return typeof t != "object" ? null : t == null ? void 0 : t[rs];
}
function Rn(t) {
  var e;
  const n = P(t);
  return n ? (e = n.copy) !== null && e !== void 0 ? e : n.original : t;
}
function ce(t, e) {
  if (!t || typeof t != "object")
    return !1;
  let n;
  return Object.getPrototypeOf(t) === Object.prototype || Array.isArray(t) || t instanceof Map || t instanceof Set || !!(e != null && e.mark) && ((n = e.mark(t, ne)) === ne.immutable || typeof n == "function");
}
function ss(t, e = []) {
  if (Object.hasOwnProperty.call(t, "key")) {
    const n = t.parent.copy, r = P(ye(n, t.key));
    if (r !== null && (r == null ? void 0 : r.original) !== t.original)
      return null;
    const s = t.parent.type === 3, i = s ? Array.from(t.parent.setMap.keys()).indexOf(t.key) : t.key;
    if (!(s && n.size > i || et(n, i)))
      return null;
    e.push(i);
  }
  if (t.parent)
    return ss(t.parent, e);
  e.reverse();
  try {
    Si(t.copy, e);
  } catch {
    return null;
  }
  return e;
}
function ke(t) {
  return Array.isArray(t) ? 1 : t instanceof Map ? 2 : t instanceof Set ? 3 : 0;
}
function ye(t, e) {
  return ke(t) === 2 ? t.get(e) : t[e];
}
function at(t, e, n) {
  ke(t) === 2 ? t.set(e, n) : t[e] = n;
}
function Gt(t, e) {
  const n = P(t);
  return (n ? te(n) : t)[e];
}
function pe(t, e) {
  return t === e ? t !== 0 || 1 / t === 1 / e : t !== t && e !== e;
}
function rn(t) {
  if (t)
    for (; t.finalities.revoke.length > 0; )
      t.finalities.revoke.pop()();
}
function ve(t, e) {
  return e ? t : [""].concat(t).map((n) => {
    const r = `${n}`;
    return r.indexOf("/") === -1 && r.indexOf("~") === -1 ? r : r.replace(/~/g, "~0").replace(/\//g, "~1");
  }).join("/");
}
function Si(t, e) {
  for (let n = 0; n < e.length - 1; n += 1) {
    const r = e[n];
    if (t = ye(ke(t) === 3 ? Array.from(t) : t, r), typeof t != "object")
      throw new Error(`Cannot resolve patch at '${e.join("/")}'.`);
  }
  return t;
}
function vi(t) {
  const e = Object.create(Object.getPrototypeOf(t));
  return Reflect.ownKeys(t).forEach((n) => {
    let r = Reflect.getOwnPropertyDescriptor(t, n);
    if (r.enumerable && r.configurable && r.writable) {
      e[n] = t[n];
      return;
    }
    r.writable || (r.writable = !0, r.configurable = !0), (r.get || r.set) && (r = {
      configurable: !0,
      writable: !0,
      enumerable: r.enumerable,
      value: t[n]
    }), Reflect.defineProperty(e, n, r);
  }), e;
}
const Ei = Object.prototype.propertyIsEnumerable;
function is(t, e) {
  let n;
  if (Array.isArray(t))
    return Array.prototype.concat.call(t);
  if (t instanceof Set) {
    if (!Mn(t)) {
      const r = Object.getPrototypeOf(t).constructor;
      return new r(t.values());
    }
    return Set.prototype.difference ? Set.prototype.difference.call(t, /* @__PURE__ */ new Set()) : new Set(t.values());
  } else if (t instanceof Map) {
    if (!jn(t)) {
      const r = Object.getPrototypeOf(t).constructor;
      return new r(t);
    }
    return new Map(t);
  } else if (e != null && e.mark && (n = e.mark(t, ne), n !== void 0) && n !== ne.mutable) {
    if (n === ne.immutable)
      return vi(t);
    if (typeof n == "function") {
      if (e.enablePatches || e.enableAutoFreeze)
        throw new Error("You can't use mark and patches or auto freeze together.");
      return n();
    }
    throw new Error(`Unsupported mark result: ${n}`);
  } else if (typeof t == "object" && Object.getPrototypeOf(t) === Object.prototype) {
    const r = {};
    return Object.keys(t).forEach((s) => {
      r[s] = t[s];
    }), Object.getOwnPropertySymbols(t).forEach((s) => {
      Ei.call(t, s) && (r[s] = t[s]);
    }), r;
  } else
    throw new Error("Please check mark() to ensure that it is a stable marker draftable function.");
}
function Q(t) {
  t.copy || (t.copy = is(t.original, t.options));
}
function Qe(t) {
  if (!ce(t))
    return Rn(t);
  if (Array.isArray(t))
    return t.map(Qe);
  if (t instanceof Map) {
    const n = Array.from(t.entries()).map(([r, s]) => [
      r,
      Qe(s)
    ]);
    if (!jn(t)) {
      const r = Object.getPrototypeOf(t).constructor;
      return new r(n);
    }
    return new Map(n);
  }
  if (t instanceof Set) {
    const n = Array.from(t).map(Qe);
    if (!Mn(t)) {
      const r = Object.getPrototypeOf(t).constructor;
      return new r(n);
    }
    return new Set(n);
  }
  const e = Object.create(Object.getPrototypeOf(t));
  for (const n in t)
    e[n] = Qe(t[n]);
  return e;
}
function Tt(t) {
  return Ae(t) ? Qe(t) : t;
}
function fe(t) {
  var e;
  t.assignedMap = (e = t.assignedMap) !== null && e !== void 0 ? e : /* @__PURE__ */ new Map(), t.operated || (t.operated = !0, t.parent && fe(t.parent));
}
function yr() {
  throw new Error("Cannot modify frozen object");
}
function Me(t, e, n, r, s) {
  {
    n = n ?? /* @__PURE__ */ new WeakMap(), r = r ?? [], s = s ?? [];
    const o = n.has(t) ? n.get(t) : t;
    if (r.length > 0) {
      const a = r.indexOf(o);
      if (o && typeof o == "object" && a !== -1)
        throw r[0] === o ? new Error("Forbids circular reference") : new Error(`Forbids circular reference: ~/${s.slice(0, a).map((c, u) => {
          if (typeof c == "symbol")
            return `[${c.toString()}]`;
          const l = r[u];
          return typeof c == "object" && (l instanceof Map || l instanceof Set) ? Array.from(l.keys()).indexOf(c) : c;
        }).join("/")}`);
      r.push(o), s.push(e);
    } else
      r.push(o);
  }
  if (Object.isFrozen(t) || Ae(t)) {
    r.pop(), s.pop();
    return;
  }
  switch (ke(t)) {
    case 2:
      for (const [a, c] of t)
        Me(a, a, n, r, s), Me(c, a, n, r, s);
      t.set = t.clear = t.delete = yr;
      break;
    case 3:
      for (const a of t)
        Me(a, a, n, r, s);
      t.add = t.clear = t.delete = yr;
      break;
    case 1:
      Object.freeze(t);
      let o = 0;
      for (const a of t)
        Me(a, o, n, r, s), o += 1;
      break;
    default:
      Object.freeze(t), Object.keys(t).forEach((a) => {
        const c = t[a];
        Me(c, a, n, r, s);
      });
  }
  r.pop(), s.pop();
}
function xn(t, e) {
  const n = ke(t);
  if (n === 0)
    Reflect.ownKeys(t).forEach((r) => {
      e(r, t[r], t);
    });
  else if (n === 1) {
    let r = 0;
    for (const s of t)
      e(r, s, t), r += 1;
  } else
    t.forEach((r, s) => e(s, r, t));
}
function os(t, e, n) {
  if (Ae(t) || !ce(t, n) || e.has(t) || Object.isFrozen(t))
    return;
  const r = t instanceof Set, s = r ? /* @__PURE__ */ new Map() : void 0;
  if (e.add(t), xn(t, (i, o) => {
    var a;
    if (Ae(o)) {
      const c = P(o);
      Q(c);
      const u = !((a = c.assignedMap) === null || a === void 0) && a.size || c.operated ? c.copy : c.original;
      at(r ? s : t, i, u);
    } else
      os(o, e, n);
  }), s) {
    const i = t, o = Array.from(i);
    i.clear(), o.forEach((a) => {
      i.add(s.has(a) ? s.get(a) : a);
    });
  }
}
function Oi(t, e) {
  const n = t.type === 3 ? t.setMap : t.copy;
  t.finalities.revoke.length > 1 && t.assignedMap.get(e) && n && os(ye(n, e), t.finalities.handledSet, t.options);
}
function sn(t) {
  t.type === 3 && t.copy && (t.copy.clear(), t.setMap.forEach((e) => {
    t.copy.add(Rn(e));
  }));
}
function on(t, e, n, r) {
  if (t.operated && t.assignedMap && t.assignedMap.size > 0 && !t.finalized) {
    if (n && r) {
      const i = ss(t);
      i && e(t, i, n, r);
    }
    t.finalized = !0;
  }
}
function $n(t, e, n, r) {
  const s = P(n);
  s && (s.callbacks || (s.callbacks = []), s.callbacks.push((i, o) => {
    var a;
    const c = t.type === 3 ? t.setMap : t.copy;
    if (pe(ye(c, e), n)) {
      let u = s.original;
      s.copy && (u = s.copy), sn(t), on(t, r, i, o), t.options.enableAutoFreeze && (t.options.updatedValues = (a = t.options.updatedValues) !== null && a !== void 0 ? a : /* @__PURE__ */ new WeakMap(), t.options.updatedValues.set(u, s.original)), at(c, e, u);
    }
  }), t.options.enableAutoFreeze && s.finalities !== t.finalities && (t.options.enableAutoFreeze = !1)), ce(n, t.options) && t.finalities.draft.push(() => {
    const i = t.type === 3 ? t.setMap : t.copy;
    pe(ye(i, e), n) && Oi(t, e);
  });
}
function Ai(t, e, n, r, s) {
  let { original: i, assignedMap: o, options: a } = t, c = t.copy;
  c.length < i.length && ([i, c] = [c, i], [n, r] = [r, n]);
  for (let u = 0; u < i.length; u += 1)
    if (o.get(u.toString()) && c[u] !== i[u]) {
      const l = e.concat([u]), f = ve(l, s);
      n.push({
        op: U.Replace,
        path: f,
        // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
        value: Tt(c[u])
      }), r.push({
        op: U.Replace,
        path: f,
        // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
        value: Tt(i[u])
      });
    }
  for (let u = i.length; u < c.length; u += 1) {
    const l = e.concat([u]), f = ve(l, s);
    n.push({
      op: U.Add,
      path: f,
      // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
      value: Tt(c[u])
    });
  }
  if (i.length < c.length) {
    const { arrayLengthAssignment: u = !0 } = a.enablePatches;
    if (u) {
      const l = e.concat(["length"]), f = ve(l, s);
      r.push({
        op: U.Replace,
        path: f,
        value: i.length
      });
    } else
      for (let l = c.length; i.length < l; l -= 1) {
        const f = e.concat([l - 1]), h = ve(f, s);
        r.push({
          op: U.Remove,
          path: h
        });
      }
  }
}
function ki({ original: t, copy: e, assignedMap: n }, r, s, i, o) {
  n.forEach((a, c) => {
    const u = ye(t, c), l = Tt(ye(e, c)), f = a ? et(t, c) ? U.Replace : U.Add : U.Remove;
    if (pe(u, l) && f === U.Replace)
      return;
    const h = r.concat(c), y = ve(h, o);
    s.push(f === U.Remove ? { op: f, path: y } : { op: f, path: y, value: l }), i.push(f === U.Add ? { op: U.Remove, path: y } : f === U.Remove ? { op: U.Add, path: y, value: u } : { op: U.Replace, path: y, value: u });
  });
}
function Ci({ original: t, copy: e }, n, r, s, i) {
  let o = 0;
  t.forEach((a) => {
    if (!e.has(a)) {
      const c = n.concat([o]), u = ve(c, i);
      r.push({
        op: U.Remove,
        path: u,
        value: a
      }), s.unshift({
        op: U.Add,
        path: u,
        value: a
      });
    }
    o += 1;
  }), o = 0, e.forEach((a) => {
    if (!t.has(a)) {
      const c = n.concat([o]), u = ve(c, i);
      r.push({
        op: U.Add,
        path: u,
        value: a
      }), s.unshift({
        op: U.Remove,
        path: u,
        value: a
      });
    }
    o += 1;
  });
}
function ot(t, e, n, r) {
  const { pathAsArray: s = !0 } = t.options.enablePatches;
  switch (t.type) {
    case 0:
    case 2:
      return ki(t, e, n, r, s);
    case 1:
      return Ai(t, e, n, r, s);
    case 3:
      return Ci(t, e, n, r, s);
  }
}
const At = (t, e, n = !1) => {
  if (typeof t == "object" && t !== null && (!ce(t, e) || n))
    throw new Error("Strict mode: Mutable data cannot be accessed directly, please use 'unsafe(callback)' wrap.");
}, an = {
  get size() {
    return te(P(this)).size;
  },
  has(t) {
    return te(P(this)).has(t);
  },
  set(t, e) {
    const n = P(this), r = te(n);
    return (!r.has(t) || !pe(r.get(t), e)) && (Q(n), fe(n), n.assignedMap.set(t, !0), n.copy.set(t, e), $n(n, t, e, ot)), this;
  },
  delete(t) {
    if (!this.has(t))
      return !1;
    const e = P(this);
    return Q(e), fe(e), e.original.has(t) ? e.assignedMap.set(t, !1) : e.assignedMap.delete(t), e.copy.delete(t), !0;
  },
  clear() {
    const t = P(this);
    if (this.size) {
      Q(t), fe(t), t.assignedMap = /* @__PURE__ */ new Map();
      for (const [e] of t.original)
        t.assignedMap.set(e, !1);
      t.copy.clear();
    }
  },
  forEach(t, e) {
    const n = P(this);
    te(n).forEach((r, s) => {
      t.call(e, this.get(s), s, this);
    });
  },
  get(t) {
    var e, n;
    const r = P(this), s = te(r).get(t), i = ((n = (e = r.options).mark) === null || n === void 0 ? void 0 : n.call(e, s, ne)) === ne.mutable;
    if (r.options.strict && At(s, r.options, i), i || r.finalized || !ce(s, r.options) || s !== r.original.get(t))
      return s;
    const o = In.createDraft({
      original: s,
      parentDraft: r,
      key: t,
      finalities: r.finalities,
      options: r.options
    });
    return Q(r), r.copy.set(t, o), o;
  },
  keys() {
    return te(P(this)).keys();
  },
  values() {
    const t = this.keys();
    return {
      [wt]: () => this.values(),
      next: () => {
        const e = t.next();
        return e.done ? e : {
          done: !1,
          value: this.get(e.value)
        };
      }
    };
  },
  entries() {
    const t = this.keys();
    return {
      [wt]: () => this.entries(),
      next: () => {
        const e = t.next();
        if (e.done)
          return e;
        const n = this.get(e.value);
        return {
          done: !1,
          value: [e.value, n]
        };
      }
    };
  },
  [wt]() {
    return this.entries();
  }
}, Pi = Reflect.ownKeys(an), br = (t, e, { isValuesIterator: n }) => () => {
  var r, s;
  const i = e.next();
  if (i.done)
    return i;
  const o = i.value;
  let a = t.setMap.get(o);
  const c = P(a), u = ((s = (r = t.options).mark) === null || s === void 0 ? void 0 : s.call(r, a, ne)) === ne.mutable;
  if (t.options.strict && At(o, t.options, u), !u && !c && ce(o, t.options) && !t.finalized && t.original.has(o)) {
    const l = In.createDraft({
      original: o,
      parentDraft: t,
      key: o,
      finalities: t.finalities,
      options: t.options
    });
    t.setMap.set(o, l), a = l;
  } else c && (a = c.proxy);
  return {
    done: !1,
    value: n ? a : [a, a]
  };
}, kt = {
  get size() {
    return P(this).setMap.size;
  },
  has(t) {
    const e = P(this);
    if (e.setMap.has(t))
      return !0;
    Q(e);
    const n = P(t);
    return !!(n && e.setMap.has(n.original));
  },
  add(t) {
    const e = P(this);
    return this.has(t) || (Q(e), fe(e), e.assignedMap.set(t, !0), e.setMap.set(t, t), $n(e, t, t, ot)), this;
  },
  delete(t) {
    if (!this.has(t))
      return !1;
    const e = P(this);
    Q(e), fe(e);
    const n = P(t);
    return n && e.setMap.has(n.original) ? (e.assignedMap.set(n.original, !1), e.setMap.delete(n.original)) : (!n && e.setMap.has(t) ? e.assignedMap.set(t, !1) : e.assignedMap.delete(t), e.setMap.delete(t));
  },
  clear() {
    if (!this.size)
      return;
    const t = P(this);
    Q(t), fe(t);
    for (const e of t.original)
      t.assignedMap.set(e, !1);
    t.setMap.clear();
  },
  values() {
    const t = P(this);
    Q(t);
    const e = t.setMap.keys();
    return {
      [Symbol.iterator]: () => this.values(),
      next: br(t, e, { isValuesIterator: !0 })
    };
  },
  entries() {
    const t = P(this);
    Q(t);
    const e = t.setMap.keys();
    return {
      [Symbol.iterator]: () => this.entries(),
      next: br(t, e, {
        isValuesIterator: !1
      })
    };
  },
  keys() {
    return this.values();
  },
  [wt]() {
    return this.values();
  },
  forEach(t, e) {
    const n = this.values();
    let r = n.next();
    for (; !r.done; )
      t.call(e, r.value, r.value, this), r = n.next();
  }
};
Set.prototype.difference && Object.assign(kt, {
  intersection(t) {
    return Set.prototype.intersection.call(new Set(this.values()), t);
  },
  union(t) {
    return Set.prototype.union.call(new Set(this.values()), t);
  },
  difference(t) {
    return Set.prototype.difference.call(new Set(this.values()), t);
  },
  symmetricDifference(t) {
    return Set.prototype.symmetricDifference.call(new Set(this.values()), t);
  },
  isSubsetOf(t) {
    return Set.prototype.isSubsetOf.call(new Set(this.values()), t);
  },
  isSupersetOf(t) {
    return Set.prototype.isSupersetOf.call(new Set(this.values()), t);
  },
  isDisjointFrom(t) {
    return Set.prototype.isDisjointFrom.call(new Set(this.values()), t);
  }
});
const Ii = Reflect.ownKeys(kt), as = /* @__PURE__ */ new WeakSet(), cs = {
  get(t, e, n) {
    var r, s;
    const i = (r = t.copy) === null || r === void 0 ? void 0 : r[e];
    if (i && as.has(i))
      return i;
    if (e === rs)
      return t;
    let o;
    if (t.options.mark) {
      const u = e === "size" && (t.original instanceof Map || t.original instanceof Set) ? Reflect.get(t.original, e) : Reflect.get(t.original, e, n);
      if (o = t.options.mark(u, ne), o === ne.mutable)
        return t.options.strict && At(u, t.options, !0), u;
    }
    const a = te(t);
    if (a instanceof Map && Pi.includes(e)) {
      if (e === "size")
        return Object.getOwnPropertyDescriptor(an, "size").get.call(t.proxy);
      const u = an[e];
      if (u)
        return u.bind(t.proxy);
    }
    if (a instanceof Set && Ii.includes(e)) {
      if (e === "size")
        return Object.getOwnPropertyDescriptor(kt, "size").get.call(t.proxy);
      const u = kt[e];
      if (u)
        return u.bind(t.proxy);
    }
    if (!et(a, e)) {
      const u = pr(a, e);
      return u ? "value" in u ? u.value : (
        // !case: support for getter
        (s = u.get) === null || s === void 0 ? void 0 : s.call(t.proxy)
      ) : void 0;
    }
    const c = a[e];
    if (t.options.strict && At(c, t.options), t.finalized || !ce(c, t.options))
      return c;
    if (c === Gt(t.original, e)) {
      if (Q(t), t.copy[e] = Dn({
        original: t.original[e],
        parentDraft: t,
        key: t.type === 1 ? Number(e) : e,
        finalities: t.finalities,
        options: t.options
      }), typeof o == "function") {
        const u = P(t.copy[e]);
        return Q(u), fe(u), u.copy;
      }
      return t.copy[e];
    }
    return c;
  },
  set(t, e, n) {
    var r;
    if (t.type === 3 || t.type === 2)
      throw new Error("Map/Set draft does not support any property assignment.");
    let s;
    if (t.type === 1 && e !== "length" && !(Number.isInteger(s = Number(e)) && s >= 0 && (e === 0 || s === 0 || String(s) === String(e))))
      throw new Error("Only supports setting array indices and the 'length' property.");
    const i = pr(te(t), e);
    if (i != null && i.set)
      return i.set.call(t.proxy, n), !0;
    const o = Gt(te(t), e), a = P(o);
    return a && pe(a.original, n) ? (t.copy[e] = n, t.assignedMap = (r = t.assignedMap) !== null && r !== void 0 ? r : /* @__PURE__ */ new Map(), t.assignedMap.set(e, !1), !0) : (pe(n, o) && (n !== void 0 || et(t.original, e)) || (Q(t), fe(t), et(t.original, e) && pe(n, t.original[e]) ? t.assignedMap.delete(e) : t.assignedMap.set(e, !0), t.copy[e] = n, $n(t, e, n, ot)), !0);
  },
  has(t, e) {
    return e in te(t);
  },
  ownKeys(t) {
    return Reflect.ownKeys(te(t));
  },
  getOwnPropertyDescriptor(t, e) {
    const n = te(t), r = Reflect.getOwnPropertyDescriptor(n, e);
    return r && {
      writable: !0,
      configurable: t.type !== 1 || e !== "length",
      enumerable: r.enumerable,
      value: n[e]
    };
  },
  getPrototypeOf(t) {
    return Reflect.getPrototypeOf(t.original);
  },
  setPrototypeOf() {
    throw new Error("Cannot call 'setPrototypeOf()' on drafts");
  },
  defineProperty() {
    throw new Error("Cannot call 'defineProperty()' on drafts");
  },
  deleteProperty(t, e) {
    var n;
    return t.type === 1 ? cs.set.call(this, t, e, void 0, t.proxy) : (Gt(t.original, e) !== void 0 || e in t.original ? (Q(t), fe(t), t.assignedMap.set(e, !1)) : (t.assignedMap = (n = t.assignedMap) !== null && n !== void 0 ? n : /* @__PURE__ */ new Map(), t.assignedMap.delete(e)), t.copy && delete t.copy[e], !0);
  }
};
function Dn(t) {
  const { original: e, parentDraft: n, key: r, finalities: s, options: i } = t, o = ke(e), a = {
    type: o,
    finalized: !1,
    parent: n,
    original: e,
    copy: null,
    proxy: null,
    finalities: s,
    options: i,
    // Mapping of draft Set items to their corresponding draft values.
    setMap: o === 3 ? new Map(e.entries()) : void 0
  };
  (r || "key" in t) && (a.key = r);
  const { proxy: c, revoke: u } = Proxy.revocable(o === 1 ? Object.assign([], a) : a, cs);
  if (s.revoke.push(u), as.add(c), a.proxy = c, n) {
    const l = n;
    l.finalities.draft.push((f, h) => {
      var y, b;
      const g = P(c);
      let w = l.type === 3 ? l.setMap : l.copy;
      const m = ye(w, r), _ = P(m);
      if (_) {
        let S = _.original;
        _.operated && (S = Rn(m)), sn(_), on(_, ot, f, h), l.options.enableAutoFreeze && (l.options.updatedValues = (y = l.options.updatedValues) !== null && y !== void 0 ? y : /* @__PURE__ */ new WeakMap(), l.options.updatedValues.set(S, _.original)), at(w, r, S);
      }
      (b = g.callbacks) === null || b === void 0 || b.forEach((S) => {
        S(f, h);
      });
    });
  } else {
    const l = P(c);
    l.finalities.draft.push((f, h) => {
      sn(l), on(l, ot, f, h);
    });
  }
  return c;
}
In.createDraft = Dn;
function Mi(t, e, n, r, s) {
  var i;
  const o = P(t), a = (i = o == null ? void 0 : o.original) !== null && i !== void 0 ? i : t, c = !!e.length;
  if (o != null && o.operated)
    for (; o.finalities.draft.length > 0; )
      o.finalities.draft.pop()(n, r);
  const u = c ? e[0] : o ? o.operated ? o.copy : o.original : t;
  return o && rn(o), s && Me(u, u, o == null ? void 0 : o.options.updatedValues), [
    u,
    n && c ? [{ op: U.Replace, path: [], value: e[0] }] : n,
    r && c ? [{ op: U.Replace, path: [], value: a }] : r
  ];
}
function ji(t, e) {
  var n;
  const r = {
    draft: [],
    revoke: [],
    handledSet: /* @__PURE__ */ new WeakSet()
  };
  let s, i;
  e.enablePatches && (s = [], i = []);
  const a = ((n = e.mark) === null || n === void 0 ? void 0 : n.call(e, t, ne)) === ne.mutable || !ce(t, e) ? t : Dn({
    original: t,
    parentDraft: null,
    finalities: r,
    options: e
  });
  return [
    a,
    (c = []) => {
      const [u, l, f] = Mi(a, c, s, i, e.enableAutoFreeze);
      return e.enablePatches ? [u, l, f] : u;
    }
  ];
}
function cn(t) {
  const { rootDraft: e, value: n, useRawReturn: r = !1, isRoot: s = !0 } = t;
  xn(n, (i, o, a) => {
    const c = P(o);
    if (c && e && c.finalities === e.finalities) {
      t.isContainDraft = !0;
      const u = c.original;
      if (a instanceof Set) {
        const l = Array.from(a);
        a.clear(), l.forEach((f) => a.add(i === f ? u : f));
      } else
        at(a, i, u);
    } else typeof o == "object" && o !== null && (t.value = o, t.isRoot = !1, cn(t));
  }), s && (t.isContainDraft || console.warn("The return value does not contain any draft, please use 'rawReturn()' to wrap the return value to improve performance."), r && console.warn("The return value contains drafts, please don't use 'rawReturn()' to wrap the return value."));
}
function us(t) {
  var e;
  const n = P(t);
  if (!ce(t, n == null ? void 0 : n.options))
    return t;
  const r = ke(t);
  if (n && !n.operated)
    return n.original;
  let s;
  function i() {
    s = r === 2 ? jn(t) ? new Map(t) : new (Object.getPrototypeOf(t)).constructor(t) : r === 3 ? Array.from(n.setMap.values()) : is(t, n == null ? void 0 : n.options);
  }
  if (n) {
    n.finalized = !0;
    try {
      i();
    } finally {
      n.finalized = !1;
    }
  } else
    s = t;
  if (xn(s, (o, a) => {
    if (n && pe(ye(n.original, o), a))
      return;
    const c = us(a);
    c !== a && (s === t && i(), at(s, o, c));
  }), r === 3) {
    const o = (e = n == null ? void 0 : n.original) !== null && e !== void 0 ? e : s;
    return Mn(o) ? new Set(s) : new (Object.getPrototypeOf(o)).constructor(s);
  }
  return s;
}
function gr(t) {
  if (!Ae(t))
    throw new Error(`current() is only used for Draft, parameter: ${t}`);
  return us(t);
}
const Ri = (t) => function e(n, r, s) {
  var i, o, a;
  if (typeof n == "function" && typeof r != "function")
    return function(E, ...j) {
      return e(E, (L) => n.call(this, L, ...j), r);
    };
  const c = n, u = r;
  let l = s;
  if (typeof r != "function" && (l = r), l !== void 0 && Object.prototype.toString.call(l) !== "[object Object]")
    throw new Error(`Invalid options: ${l}, 'options' should be an object.`);
  l = Object.assign(Object.assign({}, t), l);
  const f = Ae(c) ? gr(c) : c, h = Array.isArray(l.mark) ? (E, j) => {
    for (const L of l.mark) {
      if (typeof L != "function")
        throw new Error(`Invalid mark: ${L}, 'mark' should be a function.`);
      const B = L(E, j);
      if (B)
        return B;
    }
  } : l.mark, y = (i = l.enablePatches) !== null && i !== void 0 ? i : !1, b = (o = l.strict) !== null && o !== void 0 ? o : !1, w = {
    enableAutoFreeze: (a = l.enableAutoFreeze) !== null && a !== void 0 ? a : !1,
    mark: h,
    strict: b,
    enablePatches: y
  };
  if (!ce(f, w) && typeof f == "object" && f !== null)
    throw new Error("Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.");
  const [m, _] = ji(f, w);
  if (typeof r != "function") {
    if (!ce(f, w))
      throw new Error("Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.");
    return [m, _];
  }
  let S;
  try {
    S = u(m);
  } catch (E) {
    throw rn(P(m)), E;
  }
  const O = (E) => {
    const j = P(m);
    if (!Ae(E)) {
      if (E !== void 0 && !pe(E, m) && (j != null && j.operated))
        throw new Error("Either the value is returned as a new non-draft value, or only the draft is modified without returning any value.");
      const B = E == null ? void 0 : E[mi];
      if (B) {
        const qe = B[0];
        return w.strict && typeof E == "object" && E !== null && cn({
          rootDraft: j,
          value: E,
          useRawReturn: !0
        }), _([qe]);
      }
      if (E !== void 0)
        return typeof E == "object" && E !== null && cn({ rootDraft: j, value: E }), _([E]);
    }
    if (E === m || E === void 0)
      return _([]);
    const L = P(E);
    if (w === L.options) {
      if (L.operated)
        throw new Error("Cannot return a modified child draft.");
      return _([gr(E)]);
    }
    return _([E]);
  };
  return S instanceof Promise ? S.then(O, (E) => {
    throw rn(P(m)), E;
  }) : O(S);
}, Ct = Ri();
Object.prototype.constructor.toString();
function ls(t, e) {
  const n = Object.keys(t), r = Object.keys(e);
  return n.length === r.length && Object.keys(t).every((s) => e.hasOwnProperty(s));
}
function _r(t, e) {
  return Object.keys(t).length === Object.keys(e).length && Object.keys(t).every((n) => e.hasOwnProperty(n) && t[n] === e[n]);
}
function mt(t, e) {
  return typeof t != "object" || typeof e != "object" || t === null || e === null ? t === e : ls(t, e) ? Object.keys(t).every((n) => mt(t[n], e[n])) : !1;
}
function Un(t) {
  if (!He(t))
    return t;
  const e = {};
  for (const [n, r] of Object.entries(t))
    r !== void 0 && (e[n] = r);
  return e;
}
function fs(t, e) {
  if (!He(t) || !He(e))
    return e;
  const n = { ...t };
  for (const r of Object.keys(e)) {
    if (e[r] === void 0)
      continue;
    if (e[r] === null) {
      delete n[r];
      continue;
    }
    const s = He(t[r]) && He(e[r]);
    n[r] = s ? fs(t[r], e[r]) : e[r];
  }
  return n;
}
function He(t) {
  return typeof t == "object" && t !== null && !Array.isArray(t);
}
function xi(t, e, n) {
  if (!t || e.length === 0)
    return;
  let r = t || {};
  for (let i = 0; i < e.length - 1; i++) {
    const o = e[i];
    (!(o in r) || typeof r[o] != "object") && (r[o] = typeof e[i + 1] == "number" ? [] : {}), r = r[o];
  }
  const s = e[e.length - 1];
  Array.isArray(r) && typeof s == "number" ? r.splice(s, 0, n) : r[s] = n;
}
function wr(t, e, n) {
  if (!t || e.length === 0)
    return;
  let r = t || {};
  for (let s = 0; s < e.length - 1; s++) {
    const i = e[s];
    (!(i in r) || typeof r[i] != "object") && (r[i] = typeof e[s + 1] == "number" ? [] : {}), r = r[i];
  }
  r[e[e.length - 1]] = n;
}
function ds(t, e) {
  if (!t || e.length === 0)
    return;
  const [n, ...r] = e;
  if (n in t) {
    if (r.length === 0) {
      Array.isArray(t) ? t.splice(n, 1) : delete t[n];
      return;
    }
    ds(t[n], r), $i(t[n]) && delete t[n];
  }
}
function $i(t) {
  return t && Object.keys(t).length === 0;
}
const Tr = /ZULU|YEKT|YEKST|YAPT|YAKT|YAKST|XJT|WGT|WGST|WFT|WETDST|WET|WDT|WAT|WAST|WAKT|WADT|VUT|VOLT|VLAT|VLAST|VET|UZT|UZST|UYT|UYST|UTC|UT|ULAT|ULAST|UCT|TVT|TRUT|TOT|TMT|TKT|TJT|TFT|TAHT|SGT|SCT|SAST|SADT|RET|PYT|PYST|PWT|PST|PONT|PMST|PMDT|PKT|PKST|PHT|PGT|PETT|PETST|PET|PDT|OMST|OMSST|NZT|NZST|NZDT|NUT|NST|NPT|NOVT|NOVST|NFT|NDT|MYT|MVT|MUT|MUST|MST|MSK|MSD|MPT|MMT|MHT|MEZ|METDST|MET|MESZ|MEST|MDT|MAWT|MART|MAGT|MAGST|LKT|LINT|LIGT|LHST|LHDT|KST|KRAT|KRAST|KOST|KGT|KGST|KDT|JST|JAYT|IST|IRT|IRKT|IRKST|IOT|IDT|ICT|HST|HKT|GYT|GMT|GILT|GFT|GET|GEST|GAMT|GALT|FNT|FNST|FKT|FKST|FJT|FJST|FET|EST|EGT|EGST|EETDST|EET|EEST|EDT|EAT|EAST|EASST|DDUT|DAVT|CXT|CST|COT|CLT|CLST|CKT|CHUT|CHAST|CHADT|CETDST|CET|CEST|CDT|CCT|CAST|CADT|BTT|BST|BRT|BRST|BRA|BOT|BORT|BNT|BDT|BDST|AZT|AZST|AZOT|AZOST|AWST|AWSST|AST|ART|ARST|ANAT|ANAST|AMT|AMST|ALMT|ALMST|AKST|AKDT|AFT|AEST|AESST|AEDT|ADT|ACWST|ACT|ACST|ACSST|ACDT$/, Di = {
  ZULU: 0,
  YEKT: 18e3,
  YEKST: 21600,
  YAPT: 36e3,
  YAKT: 32400,
  YAKST: 32400,
  XJT: 21600,
  WGT: -10800,
  WGST: -7200,
  WFT: 43200,
  WETDST: 3600,
  WET: 0,
  WDT: 32400,
  WAT: 3600,
  WAST: 25200,
  WAKT: 43200,
  WADT: 28800,
  VUT: 39600,
  VOLT: 10800,
  VLAT: 36e3,
  VLAST: 36e3,
  VET: -14400,
  UZT: 18e3,
  UZST: 21600,
  UYT: -10800,
  UYST: -7200,
  UTC: 0,
  UT: 0,
  ULAT: 28800,
  ULAST: 32400,
  UCT: 0,
  TVT: 43200,
  TRUT: 36e3,
  TOT: 46800,
  TMT: 18e3,
  TKT: 46800,
  TJT: 18e3,
  TFT: 18e3,
  TAHT: -36e3,
  SGT: 28800,
  SCT: 14400,
  SAST: 7200,
  SADT: 37800,
  RET: 14400,
  PYT: -14400,
  PYST: -10800,
  PWT: 32400,
  PST: -28800,
  PONT: 39600,
  PMST: -10800,
  PMDT: -7200,
  PKT: 18e3,
  PKST: 21600,
  PHT: 28800,
  PGT: 36e3,
  PETT: 43200,
  PETST: 43200,
  PET: -18e3,
  PDT: -25200,
  OMST: 21600,
  OMSST: 21600,
  NZT: 43200,
  NZST: 43200,
  NZDT: 46800,
  NUT: -39600,
  NST: -12600,
  NPT: 20700,
  NOVT: 25200,
  NOVST: 25200,
  NFT: -12600,
  NDT: -9e3,
  MYT: 28800,
  MVT: 18e3,
  MUT: 14400,
  MUST: 18e3,
  MST: -25200,
  MSK: 10800,
  MSD: 14400,
  MPT: 36e3,
  MMT: 23400,
  MHT: 43200,
  MEZ: 3600,
  METDST: 7200,
  MET: 3600,
  MESZ: 7200,
  MEST: 7200,
  MDT: -21600,
  MAWT: 18e3,
  MART: -34200,
  MAGT: 39600,
  MAGST: 39600,
  LKT: 19800,
  LINT: 50400,
  LIGT: 36e3,
  LHST: 37800,
  LHDT: 37800,
  KST: 32400,
  KRAT: 25200,
  KRAST: 25200,
  KOST: 39600,
  KGT: 21600,
  KGST: 21600,
  KDT: 36e3,
  JST: 32400,
  JAYT: 32400,
  IST: 7200,
  IRT: 12600,
  IRKT: 28800,
  IRKST: 28800,
  IOT: 21600,
  IDT: 10800,
  ICT: 25200,
  HST: -36e3,
  HKT: 28800,
  GYT: -14400,
  GMT: 0,
  GILT: 43200,
  GFT: -10800,
  GET: 14400,
  GEST: 14400,
  GAMT: -32400,
  GALT: -21600,
  FNT: -7200,
  FNST: -3600,
  FKT: -10800,
  FKST: -10800,
  FJT: 43200,
  FJST: 46800,
  FET: 10800,
  EST: -18e3,
  EGT: -3600,
  EGST: 0,
  EETDST: 10800,
  EET: 7200,
  EEST: 10800,
  EDT: -14400,
  EAT: 10800,
  EAST: -21600,
  EASST: -21600,
  DDUT: 36e3,
  DAVT: 25200,
  CXT: 25200,
  CST: -21600,
  COT: -18e3,
  CLT: -14400,
  CLST: -10800,
  CKT: -36e3,
  CHUT: 36e3,
  CHAST: 45900,
  CHADT: 49500,
  CETDST: 7200,
  CET: 3600,
  CEST: 7200,
  CDT: -18e3,
  CCT: 28800,
  CAST: 34200,
  CADT: 37800,
  BTT: 21600,
  BST: 3600,
  BRT: -10800,
  BRST: -7200,
  BRA: -10800,
  BOT: -14400,
  BORT: 28800,
  BNT: 28800,
  BDT: 21600,
  BDST: 7200,
  AZT: 14400,
  AZST: 14400,
  AZOT: -3600,
  AZOST: 0,
  AWST: 28800,
  AWSST: 32400,
  AST: -14400,
  ART: -10800,
  ARST: -10800,
  ANAT: 43200,
  ANAST: 43200,
  AMT: -14400,
  AMST: 14400,
  ALMT: 21600,
  ALMST: 25200,
  AKST: -32400,
  AKDT: -28800,
  AFT: 16200,
  AEST: 36e3,
  AESST: 39600,
  AEDT: 39600,
  ADT: -10800,
  ACWST: 31500,
  ACT: -18e3,
  ACST: 34200,
  ACSST: 37800,
  ACDT: 37800
};
function Ui(t) {
  return new Date(t);
}
function Li(t) {
  return /* @__PURE__ */ new Date(t + "Z");
}
const Fi = /^(\d+)[\./-](\d+)[\./-](\d+)$/;
function Ni(t) {
  const e = t.match(Fi);
  if (!e)
    return null;
  const [n, r, s, i] = e;
  return r <= 0 || s <= 0 || i <= 0 ? null : r > 999 ? new Date(Date.UTC(r, s - 1, i, 0, 0, 0, 0)) : new Date(Date.UTC(i, r - 1, s, 0, 0, 0, 0));
}
function Ki(t) {
  const [e, n] = t.split(" ");
  return /* @__PURE__ */ new Date(e + "T" + n + "Z");
}
function qi(t) {
  const [e, n] = t.split(" ");
  return /* @__PURE__ */ new Date(e + "T" + n + "Z");
}
function Wi(t) {
  return new Date(t);
}
function zi(t) {
  const e = /^(\w{3}) (\w{3}) (\d{2}) (\d{4})$/;
  if (!t.match(e))
    throw new Error(`Unable to parse \`${t}\` as a date.`);
  const r = /* @__PURE__ */ new Date(t + " UTC");
  return new Date(Date.UTC(r.getUTCFullYear(), r.getUTCMonth(), r.getUTCDate(), 0, 0, 0, 0));
}
function Vi(t) {
  const e = /^(.+T.+)([+-])(\d{2})$/, n = t.match(e);
  if (n) {
    const [, r, s, i] = n, o = `${r}${s}${i}:00`;
    return new Date(o);
  }
  return null;
}
function Bi(t) {
  const e = /^(\d+)-(\d{1,2})-(\d{1,2})([ T])(.+)$/, n = t.match(e);
  if (n) {
    const [, r, s, i, o, a] = n, c = s.padStart(2, "0"), u = i.padStart(2, "0"), l = `${r}-${c}-${u}T${a}`;
    return new Date(l);
  }
  return null;
}
function Gi(t) {
  const [e, n] = t.split(", "), [r, s, i] = e.split("/").map(Number), o = n.match(/(\d{1,2}):(\d{2}):(\d{2}) (AM|PM)/);
  if (!o)
    throw new Error(`Unable to parse time from: ${t}`);
  let [, a, c, u, l] = o;
  return a = Number(a), c = Number(c), u = Number(u), l === "PM" && a !== 12 ? a += 12 : l === "AM" && a === 12 && (a = 0), new Date(Date.UTC(i, r - 1, s, a, c, u));
}
function Qi(t) {
  switch (t) {
    case "epoch":
      return /* @__PURE__ */ new Date(0);
    case "infinity":
    case "-infinity":
    case "today":
    case "tomorrow":
    case "yesterday":
      return null;
  }
}
function Hi(t) {
  const e = t.match(Tr);
  if (!e)
    return null;
  const [n] = e, r = Di[n], s = new Date(t.replace(Tr, "Z"));
  return new Date(s.getTime() - r * 1e3);
}
const Ji = [
  Ni,
  qi,
  zi,
  Gi,
  Wi,
  Li,
  Vi,
  Ki,
  Ui,
  Qi,
  Hi,
  Bi
];
function Yi(t, e) {
  try {
    const n = t(e);
    return n instanceof Date && !isNaN(n.getTime()) ? n : null;
  } catch {
    return null;
  }
}
function un(t) {
  for (const e of Ji) {
    const n = Yi(e, t);
    if (n)
      return n;
  }
  return null;
}
function Zi(t) {
  try {
    const e = JSON.parse(t);
    return typeof e == "string" ? un(e) : null;
  } catch {
    return null;
  }
}
function jt(t) {
  if (t !== void 0) {
    if (t === null)
      return null;
    if (t instanceof Date)
      return t;
    if (typeof t == "string") {
      const e = un(t) || Zi(t) || un(t.trim());
      if (!e)
        throw new Error(`Unable to parse \`${t}\` as a date.`);
      return e;
    } else if (typeof t == "number")
      return new Date(t);
    throw new Error(`Invalid date value \`${t}\`. Expected a date, number, or string, got type ${typeof t}.`);
  }
}
class Ee {
  constructor(e, n) {
    p(this, "attrs");
    p(this, "linkIndex");
    p(this, "_blobAttrs", null);
    p(this, "_primaryKeys", null);
    p(this, "_forwardIdents", null);
    p(this, "_revIdents", null);
    this.attrs = e, this.linkIndex = n;
  }
  resetAttrIndexes() {
    this._blobAttrs = null, this._primaryKeys = null, this._forwardIdents = null, this._revIdents = null;
  }
  addAttr(e) {
    this.attrs[e.id] = e, this.resetAttrIndexes();
  }
  deleteAttr(e) {
    delete this.attrs[e], this.resetAttrIndexes();
  }
  updateAttr(e) {
    const n = this.attrs[e.id];
    n && (this.attrs[e.id] = { ...n, ...e }, this.resetAttrIndexes());
  }
  getAttr(e) {
    return this.attrs[e];
  }
  get blobAttrs() {
    if (this._blobAttrs)
      return this._blobAttrs;
    this._blobAttrs = /* @__PURE__ */ new Map();
    for (const e of Object.values(this.attrs))
      if (Fn(e)) {
        const [n, r, s] = e["forward-identity"];
        Z(this.blobAttrs, [r, s], e);
      }
    return this._blobAttrs;
  }
  get primaryKeys() {
    if (this._primaryKeys)
      return this._primaryKeys;
    this._primaryKeys = /* @__PURE__ */ new Map();
    for (const e of Object.values(this.attrs))
      if (e["primary?"]) {
        const [n, r] = e["forward-identity"];
        Z(this._primaryKeys, [r], e);
      }
    return this._primaryKeys;
  }
  get forwardIdents() {
    if (this._forwardIdents)
      return this._forwardIdents;
    this._forwardIdents = /* @__PURE__ */ new Map();
    for (const e of Object.values(this.attrs)) {
      const n = e["forward-identity"], [r, s, i] = n;
      Z(this._forwardIdents, [s, i], e);
    }
    return this._forwardIdents;
  }
  get revIdents() {
    if (this._revIdents)
      return this._revIdents;
    this._revIdents = /* @__PURE__ */ new Map();
    for (const e of Object.values(this.attrs)) {
      const n = e["reverse-identity"];
      if (n) {
        const [r, s, i] = n;
        Z(this._revIdents, [s, i], e);
      }
    }
    return this._revIdents;
  }
  toJSON() {
    return { attrs: this.attrs, linkIndex: this.linkIndex };
  }
}
function Xi(t) {
  return t.cardinality === "one";
}
function Ln(t) {
  return t["value-type"] === "ref";
}
function Fn(t) {
  return t["value-type"] === "blob";
}
function Ke(t, e) {
  return e.reduce((n, r) => n && n.get(r), t);
}
function ae(t, e) {
  if (e.length === 0)
    throw new Error("path must have at least one element");
  if (e.length === 1) {
    t.delete(e[0]);
    return;
  }
  const [n, ...r] = e;
  t.has(n) && ae(t.get(n), r);
}
function Z(t, e, n) {
  let r = t;
  const s = e.length - 1;
  for (let i = 0; i < s; i++) {
    const o = e[i];
    let a = r.get(o);
    a === void 0 && (a = /* @__PURE__ */ new Map(), r.set(o, a)), r = a;
  }
  s > -1 && r.set(e[s], n);
}
function hs(t, e, n) {
  const r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
  for (const o of e) {
    let [a, c, u] = o;
    const l = t.getAttr(c);
    if (!l) {
      console.warn("no such attr", c, a);
      continue;
    }
    l["checked-data-type"] === "date" && n && (u = jt(u), o[2] = u), Ln(l) && Z(i, [u, c, a], o), Z(r, [a, c, u], o), Z(s, [c, a, u], o);
  }
  return { eav: r, aev: s, vae: i };
}
function ps(t) {
  return {
    triples: X(t.eav, 3),
    cardinalityInference: t.cardinalityInference,
    useDateObjects: t.useDateObjects,
    version: 1
  };
}
function ys(t, e) {
  return Je(t, e.triples, e.cardinalityInference, e.useDateObjects);
}
function bs(t, e) {
  if (t)
    return new Ee(t.attrs, t.linkIndex);
  if (e && "__type" in e)
    return new Ee(e.attrs, e.linkIndex);
}
function eo(t, e) {
  return Ke(t.eav, [e]) !== void 0;
}
function Je(t, e, n, r) {
  const s = hs(t, e, r);
  return s.cardinalityInference = n, s.useDateObjects = r, s;
}
function ct(t, e) {
  var s, i;
  let n;
  if (Array.isArray(e[0])) {
    const [o, a] = e[0], c = t.aev.get(o);
    if (!c)
      return null;
    n = (s = X(c, 2).find((l) => l[2] === a)) == null ? void 0 : s[0];
  } else
    n = e[0];
  if (!n)
    return null;
  const r = e[2];
  if (Array.isArray(r) && r.length === 2 && t.aev.get(r[0])) {
    const [o, a] = r, c = t.aev.get(o);
    if (!c)
      return null;
    const l = (i = X(c, 2).find((g) => g[2] === a)) == null ? void 0 : i[0];
    if (!l)
      return null;
    const [f, h, y, ...b] = e;
    return [n, h, l, ...b];
  } else {
    const [o, ...a] = e;
    return [n, ...a];
  }
}
function gs(t, e, n) {
  const r = ct(t, n);
  if (!r)
    return;
  const [s, i, o] = r, a = e.getAttr(i);
  a && (ae(t.eav, [s, i, o]), ae(t.aev, [i, s, o]), Ln(a) && ae(t.vae, [o, i, s]));
}
let to = 0;
function _s(t, e, n) {
  const [r, s, i] = n;
  let o;
  const a = Ke(t.eav, [r, s, i]);
  return a && (o = a[3]), o || Date.now() * 10 + to++;
}
function ws(t, e, n) {
  const r = ct(t, n);
  if (!r)
    return;
  let [s, i, o] = r;
  const a = e.getAttr(i);
  if (!a)
    return;
  a["checked-data-type"] === "date" && t.useDateObjects && (o = jt(o));
  const c = Ke(t.eav, [s, i, o]), u = (c == null ? void 0 : c[3]) ?? _s(t, a, r), l = [s, i, o, u];
  Xi(a) ? (Z(t.eav, [s, i], /* @__PURE__ */ new Map([[o, l]])), Z(t.aev, [i, s], /* @__PURE__ */ new Map([[o, l]]))) : (Z(t.eav, [s, i, o], l), Z(t.aev, [i, s, o], l)), Ln(a) && Z(t.vae, [o, i, s], l);
}
function no(t, e, n) {
  var y;
  const r = ct(t, n);
  if (!r)
    return;
  const [s, i, o] = r, a = e.getAttr(i);
  if (!a)
    return;
  if (!Fn(a))
    throw new Error("merge operation is not supported for links");
  const c = Ke(t.eav, [s, i]);
  if (!c)
    return;
  const u = (y = c.values().next()) == null ? void 0 : y.value;
  if (!u)
    return;
  const l = u[2], f = fs(l, o), h = [
    s,
    i,
    f,
    _s(t, a, u)
  ];
  Z(t.eav, [s, i], /* @__PURE__ */ new Map([[f, h]])), Z(t.aev, [i, s], /* @__PURE__ */ new Map([[f, h]]));
}
function ln(t, e, n) {
  var u, l;
  const [r, s] = n, i = ct(t, [r]);
  if (!i)
    return;
  const [o] = i, a = t.eav.get(o);
  if (a) {
    for (const f of a.keys()) {
      const h = e.getAttr(f);
      h && h["on-delete-reverse"] === "cascade" && X(a.get(f), 1).forEach(([y, b, g]) => {
        var w;
        return ln(t, e, [g, (w = h["reverse-identity"]) == null ? void 0 : w[1]]);
      }), // Fall back to deleting everything if we've rehydrated tx-steps from
      // the store that didn't set `etype` in deleteEntity
      (!s || // If we don't know about the attr, let's just get rid of it
      !h || // Make sure it matches the etype
      ((u = h["forward-identity"]) == null ? void 0 : u[1]) === s) && (ae(t.aev, [f, o]), ae(t.eav, [o, f]));
    }
    a.size === 0 && ae(t.eav, [o]);
  }
  const c = t.vae.get(o) && X(t.vae.get(o), 2);
  c && c.forEach((f) => {
    var w, m, _;
    const [h, y, b] = f, g = e.getAttr(y);
    (!s || !g || ((w = g["reverse-identity"]) == null ? void 0 : w[1]) === s) && (ae(t.eav, [h, y, b]), ae(t.aev, [y, h, b]), ae(t.vae, [b, y, h])), g && g["on-delete"] === "cascade" && ((m = g["reverse-identity"]) == null ? void 0 : m[1]) === s && ln(t, e, [h, (_ = g["forward-identity"]) == null ? void 0 : _[1]]);
  }), ((l = t.vae.get(o)) == null ? void 0 : l.size) === 0 && ae(t.vae, [o]);
}
function Ts(t, e, n) {
  const r = hs(e, n, t.useDateObjects);
  Object.keys(r).forEach((s) => {
    t[s] = r[s];
  });
}
function ro(t, [e]) {
  t.addAttr(e);
}
function ms(t) {
  return X(t.eav, 3);
}
function so(t, e, [n]) {
  if (!e.getAttr(n))
    return;
  const r = ms(t).filter(([s, i]) => i !== n);
  e.deleteAttr(n), Ts(t, e, r);
}
function io(t, e, [n]) {
  e.getAttr(n.id) && (e.updateAttr(n), Ts(t, e, ms(t)));
}
function oo(t, e, n) {
  const [r, ...s] = n;
  switch (r) {
    case "add-triple":
      ws(t, e, s);
      break;
    case "deep-merge-triple":
      no(t, e, s);
      break;
    case "retract-triple":
      gs(t, e, s);
      break;
    case "delete-entity":
      ln(t, e, s);
      break;
    case "add-attr":
      ro(e, s);
      break;
    case "delete-attr":
      so(t, e, s);
      break;
    case "update-attr":
      io(t, e, s);
      break;
    case "restore-attr":
      break;
    case "rule-params":
      break;
    default:
      throw new Error(`unhandled transaction action: ${r}`);
  }
}
function X(t, e, n = []) {
  if (!t || e === 0)
    return n;
  if (e === 1) {
    for (const r of t.values())
      n.push(r);
    return n;
  }
  for (const r of t.values())
    X(r, e - 1, n);
  return n;
}
function pt(t, e, n) {
  var i;
  const r = [];
  if (n != null && n.hasOwnProperty("$not")) {
    for (const o of e.keys())
      n.$not !== o && r.push(e.get(o));
    return r;
  }
  if (n != null && n.hasOwnProperty("$isNull")) {
    const { attrId: o, isNull: a, reverse: c } = n.$isNull;
    if (c)
      for (const u of e.keys()) {
        const l = t.vae.get(u), f = !l || !l.get(o);
        (a ? f : !f) && r.push(e.get(u));
      }
    else {
      const u = t.aev.get(o);
      for (const l of e.keys()) {
        const f = !u || ((i = u.get(l)) == null ? void 0 : i.get(null)) || !u.get(l);
        (a ? f : !f) && r.push(e.get(l));
      }
    }
    return r;
  }
  if (n != null && n.$comparator)
    return X(e, 1).filter(n.$op);
  const s = n.in || n.$in || [n];
  for (const o of s) {
    const a = e.get(o);
    a && r.push(a);
  }
  return r;
}
function ao(t, e, n) {
  let r = "";
  return t !== void 0 && (r += "e"), e !== void 0 && (r += "a"), n !== void 0 && (r += "v"), r;
}
function co(t, [e, n, r]) {
  var i, o;
  switch (ao(e, n, r)) {
    case "e": {
      const a = t.eav.get(e);
      return X(a, 2);
    }
    case "ea": {
      const a = (i = t.eav.get(e)) == null ? void 0 : i.get(n);
      return X(a, 1);
    }
    case "eav": {
      const a = (o = t.eav.get(e)) == null ? void 0 : o.get(n);
      return a ? pt(t, a, r) : [];
    }
    case "ev": {
      const a = t.eav.get(e);
      if (!a)
        return [];
      const c = [];
      for (const u of a.values())
        c.push(...pt(t, u, r));
      return c;
    }
    case "a": {
      const a = t.aev.get(n);
      return X(a, 2);
    }
    case "av": {
      const a = t.aev.get(n);
      if (!a)
        return [];
      const c = [];
      for (const u of a.values())
        c.push(...pt(t, u, r));
      return c;
    }
    case "v": {
      const a = [];
      for (const c of t.eav.values())
        for (const u of c.values())
          a.push(...pt(t, u, r));
      return a;
    }
    default:
      return X(t.eav, 3);
  }
}
function uo(t, e, n) {
  var s;
  const r = {};
  if (!e)
    return r;
  for (const [i, o] of e.entries()) {
    const a = (s = t.eav.get(n)) == null ? void 0 : s.get(o.id), c = X(a, 1);
    for (const u of c)
      r[i] = u[2];
  }
  return r;
}
function N(t, e, n) {
  var r;
  return (r = t.forwardIdents.get(e)) == null ? void 0 : r.get(n);
}
function Ce(t, e, n) {
  var r;
  return (r = t.revIdents.get(e)) == null ? void 0 : r.get(n);
}
function lo(t, e) {
  return t.blobAttrs.get(e);
}
function Ss(t, e) {
  var r;
  const n = t.primaryKeys.get(e);
  return n || ((r = t.forwardIdents.get(e)) == null ? void 0 : r.get("id"));
}
function fo(t, e, n) {
  const r = ct(t, n);
  if (!r)
    return;
  const [s, i, o] = r;
  if (e.getAttr(i))
    return Ke(t.eav, [s, i]);
}
function ho(t, e, n) {
  const r = n.filter(([s, i, o, a, c]) => {
    if (s !== "add-triple" && s !== "deep-merge-triple")
      return !0;
    const u = c == null ? void 0 : c.mode;
    if (u !== "create" && u !== "update")
      return !0;
    let l = !1;
    const f = e.getAttr(o);
    if (f) {
      const h = Ss(e, f["forward-identity"][1]);
      l = !!fo(t, e, [
        i,
        h == null ? void 0 : h.id,
        i
      ]);
    }
    return !(u === "create" && l || u === "update" && !l);
  });
  return Ct({ store: t, attrsStore: e }, (s) => {
    r.forEach((i) => {
      oo(s.store, s.attrsStore, i);
    });
  }, {
    mark: (s) => {
      if (s instanceof Ee)
        return "immutable";
    }
  });
}
function po(t) {
  return typeof t == "string" && t.startsWith("?");
}
function yo(t, e, n) {
  if (n.hasOwnProperty(t)) {
    const r = n[t];
    return vs(r, e, n);
  }
  return { ...n, [t]: e };
}
function mr(t, e, n) {
  return t === e ? n : null;
}
function bo(t) {
  switch (typeof t) {
    case "string":
      return t.startsWith("?") ? yo : mr;
    default:
      return mr;
  }
}
const go = [
  "in",
  "$in",
  "$not",
  "$isNull",
  "$comparator"
  // covers all of $gt, $lt, etc.
];
function _o(t) {
  for (const e of go)
    if (t.hasOwnProperty(e))
      return !0;
  return !1;
}
function vs(t, e, n) {
  return n ? typeof t == "object" ? _o(t) ? n : null : bo(t)(t, e, n) : null;
}
function wo(t, e, n) {
  return t.reduce((r, s, i) => {
    const o = e[i];
    return vs(s, o, r);
  }, n);
}
function To(t, e, n) {
  return vo(t, e, n).map((r) => wo(e, r, n)).filter((r) => r);
}
function mo(t, e, n) {
  return e.or ? e.or.patterns.flatMap((r) => fn(t, r, n)) : e.and ? e.and.patterns.reduce((r, s) => fn(t, s, r), n) : n.flatMap((r) => To(t, e, r));
}
function fn(t, e, n = [{}]) {
  return e.reduce((r, s) => mo(t, s, r), n);
}
function Nn(t, e) {
  return Array.isArray(e) ? e.map((n) => Nn(t, n)) : po(e) ? t[e] : e;
}
function So(t, { find: e, where: n }) {
  return fn(t, n).map((s) => Nn(s, e));
}
function vo(t, e, n) {
  return co(t, Nn(n, e));
}
const Eo = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
function Le(t) {
  return typeof t == "string" && Eo.test(t);
}
const z = [];
for (let t = 0; t < 256; ++t)
  z.push((t + 256).toString(16).slice(1));
function Oo(t, e = 0) {
  return (z[t[e + 0]] + z[t[e + 1]] + z[t[e + 2]] + z[t[e + 3]] + "-" + z[t[e + 4]] + z[t[e + 5]] + "-" + z[t[e + 6]] + z[t[e + 7]] + "-" + z[t[e + 8]] + z[t[e + 9]] + "-" + z[t[e + 10]] + z[t[e + 11]] + z[t[e + 12]] + z[t[e + 13]] + z[t[e + 14]] + z[t[e + 15]]).toLowerCase();
}
let Qt;
const Ao = new Uint8Array(16);
function ko() {
  if (!Qt) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    Qt = crypto.getRandomValues.bind(crypto);
  }
  return Qt(Ao);
}
const Co = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Sr = { randomUUID: Co };
function Po(t, e, n) {
  var s;
  if (Sr.randomUUID && !t)
    return Sr.randomUUID();
  t = t || {};
  const r = t.random ?? ((s = t.rng) == null ? void 0 : s.call(t)) ?? ko();
  if (r.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, Oo(r);
}
function vr(t) {
  const e = t.replace(/-/g, ""), n = [];
  for (let r = 0; r < e.length; r += 2)
    n.push(parseInt(e.substring(r, r + 2), 16));
  return n;
}
function Io(t, e) {
  for (let n = 0; n < t.length; n++) {
    if (t[n] < e[n])
      return -1;
    if (t[n] > e[n])
      return 1;
  }
  return 0;
}
function Mo(t, e) {
  return Io(vr(t), vr(e));
}
function W() {
  return Po();
}
function jo(t, e) {
  return t.localeCompare(e);
}
function Ro() {
  let t = jo;
  if (typeof Intl == "object" && Intl.hasOwnProperty("Collator"))
    try {
      t = Intl.Collator("en-US").compare;
    } catch {
    }
  return t;
}
const xo = Ro();
let $o = 0;
function tt(t) {
  return Rt(`_${t}`, $o++);
}
function Rt(t, e) {
  return `?${t}-${e}`;
}
class Fe extends Error {
  constructor(e) {
    super(e), this.name = "AttrNotFoundError";
  }
}
function Do(t, e) {
  const n = Ss(t, e);
  if (!n)
    throw new Fe(`Could not find id attr for ${e}`);
  return n;
}
function Er(t, e, n, r) {
  return [Uo(t, e, n, r)];
}
function Uo(t, e, n, r) {
  return [
    t(n, r),
    Do(e, n).id,
    t(n, r),
    t("time", r)
  ];
}
function Lo(t, e, n) {
  return t.map((r) => r === e ? n : r);
}
function Es(t, e, n, r, s) {
  const i = N(e, n, s), o = Ce(e, n, s), a = i || o;
  if (!a)
    throw new Fe(`Could not find attr for ${[n, s]}`);
  if (a["value-type"] !== "ref")
    throw new Error(`Attr ${a.id} is not a ref`);
  const [c, u] = a["forward-identity"], [l, f] = a["reverse-identity"], h = r + 1, y = i ? [
    t(u, r),
    a.id,
    t(f, h),
    tt("time")
  ] : [
    t(u, h),
    a.id,
    t(f, r),
    tt("time")
  ];
  return [i ? f : u, h, y, a, !!i];
}
function Or(t, e) {
  if (typeof e != "string")
    return function(o) {
      return !1;
    };
  const r = e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/%/g, ".*").replace(/_/g, "."), s = new RegExp(`^${r}$`, t ? void 0 : "i");
  return function(o) {
    return typeof o != "string" ? !1 : s.test(o);
  };
}
function Fo(t, e) {
  if (typeof e != "object" || e.hasOwnProperty("$in") || e.hasOwnProperty("in"))
    return e;
  const n = t["checked-data-type"] === "date";
  if (e.hasOwnProperty("$gt"))
    return {
      $comparator: !0,
      $op: n ? function(s) {
        return new Date(s[2]) > new Date(e.$gt);
      } : function(s) {
        return s[2] > e.$gt;
      }
    };
  if (e.hasOwnProperty("$gte"))
    return {
      $comparator: !0,
      $op: n ? function(s) {
        return new Date(s[2]) >= new Date(e.$gte);
      } : function(s) {
        return s[2] >= e.$gte;
      }
    };
  if (e.hasOwnProperty("$lt"))
    return {
      $comparator: !0,
      $op: n ? function(s) {
        return new Date(s[2]) < new Date(e.$lt);
      } : function(s) {
        return s[2] < e.$lt;
      }
    };
  if (e.hasOwnProperty("$lte"))
    return {
      $comparator: !0,
      $op: n ? function(s) {
        return new Date(s[2]) <= new Date(e.$lte);
      } : function(s) {
        return s[2] <= e.$lte;
      }
    };
  if (e.hasOwnProperty("$like")) {
    const r = Or(!0, e.$like);
    return {
      $comparator: !0,
      $op: function(i) {
        return r(i[2]);
      }
    };
  }
  if (e.hasOwnProperty("$ilike")) {
    const r = Or(!1, e.$ilike);
    return {
      $comparator: !0,
      $op: function(i) {
        return r(i[2]);
      }
    };
  }
  return e;
}
function No(t, e, n, r, s, i) {
  const o = N(e, n, s), a = Ce(e, n, s), c = o || a;
  if (!c)
    throw new Fe(`No attr for etype = ${n} label = ${s}`);
  if (i != null && i.hasOwnProperty("$isNull")) {
    const u = N(e, n, "id");
    if (!u)
      throw new Fe(`No attr for etype = ${n} label = id`);
    return [
      t(n, r),
      u.id,
      { $isNull: { attrId: c.id, isNull: i.$isNull, reverse: !o } },
      tt("time")
    ];
  }
  return o ? [
    t(n, r),
    c.id,
    Fo(c, i),
    tt("time")
  ] : [i, c.id, t(n, r), tt("time")];
}
function Ko(t, e, n, r, s) {
  const [i, o, a] = s.reduce((c, u) => {
    const [l, f, h] = c, [y, b, g] = Es(t, e, l, f, u);
    return [y, b, [...h, g]];
  }, [n, r, []]);
  return [i, o, a];
}
function dn(t, e, n, r, s, i) {
  const o = s.slice(0, s.length - 1), a = s[s.length - 1], [c, u, l] = Ko(t, e, n, r, o), f = No(t, e, c, u, a, i);
  return l.concat([f]);
}
function qo(t, e) {
  return e ? [e].concat(t) : t;
}
function Wo([t, e]) {
  return t === "or" && Array.isArray(e);
}
function zo([t, e]) {
  return t === "and" && Array.isArray(e);
}
function Vo(t, e, n) {
  return (r, s) => {
    const i = t(r, s);
    return e == i ? i : `${i}-${n}`;
  };
}
function Ar(t, e, n, r, s, i) {
  const o = t(r, s), a = i.map((c, u) => {
    const l = Vo(t, o, u);
    return Os(l, n, r, s, c);
  });
  return { [e]: { patterns: a, joinSym: o } };
}
function Bo(t) {
  const e = [];
  for (let n = 1; n <= t.length; n++)
    e.push(t.slice(0, n));
  return e;
}
function kr(t, e, n, r, s) {
  return Bo(s).map((i) => dn(t, e, n, r, i, {
    $isNull: !0
  }));
}
function Os(t, e, n, r, s) {
  return Object.entries(s).flatMap(([i, o]) => {
    if (Wo([i, o]))
      return Ar(t, "or", e, n, r, o);
    if (zo([i, o]))
      return Ar(t, "and", e, n, r, o);
    if (i === "$entityIdStartsWith")
      return [];
    const a = i.split(".");
    if (o != null && o.hasOwnProperty("$ne") && (o = { ...o, $not: o.$ne }, delete o.$ne), o != null && o.hasOwnProperty("$not")) {
      const c = dn(t, e, n, r, a, o), u = kr(t, e, n, r, a);
      return [
        {
          or: {
            patterns: [c, ...u],
            joinSym: t(n, r)
          }
        }
      ];
    }
    return o != null && o.hasOwnProperty("$isNull") && o.$isNull === !0 && a.length > 1 ? [
      {
        or: {
          patterns: kr(t, e, n, r, a),
          joinSym: t(n, r)
        }
      }
    ] : dn(t, e, n, r, a, o);
  });
}
function Go(t, e, n, r) {
  const s = Rt;
  return r ? Os(s, t, e, n, r).concat(Er(s, t, e, n)) : Er(s, t, e, n);
}
function Qo(t, e, n) {
  return [t(e, n), t("time", n)];
}
function Ho(t, e, n, r, s, i) {
  const [o, a, c, u, l] = Es(t, e, n, r, s), f = Lo(c, t(n, r), i);
  return [o, a, f, u, l];
}
function Jo(t, e, n, { etype: r, level: s, form: i }, o) {
  const a = Object.keys(i).filter((c) => c !== "$");
  return a.length ? Object.entries(o).map(function([u, l]) {
    return a.map(function(y) {
      var g, w, m;
      const b = !!(e.cardinalityInference && ((m = (w = (g = n.linkIndex) == null ? void 0 : g[r]) == null ? void 0 : w[y]) != null && m.isSingular));
      try {
        const [_, S, O] = Ho(t, n, r, s, y, u), E = ks(e, n, {
          etype: _,
          level: S,
          form: i[y],
          join: O
        }), j = b ? E[0] : E;
        return { [y]: j };
      } catch (_) {
        if (_ instanceof Fe)
          return { [y]: b ? void 0 : [] };
        throw _;
      }
    }).reduce(function(y, b) {
      return { ...y, ...b };
    }, l);
  }) : Object.values(o);
}
function Yo(t, e, n) {
  return n === "string" ? xo(t, e) : t > e ? 1 : -1;
}
function Ye(t, e, n, r, s) {
  return e === r || e == null && r == null ? Mo(t, n) : r == null ? 1 : e == null ? -1 : Yo(e, r, s);
}
function Pt([t, e], [n, r], s) {
  return Ye(t, e, n, r, s);
}
function hn(t) {
  return t == null ? t : new Date(t).getTime();
}
function Zo(t, e, n, r) {
  var b;
  const [s, i, o, a] = t, c = n === "desc" ? 1 : -1;
  if (((b = e["forward-identity"]) == null ? void 0 : b[2]) === "id")
    return Pt(r, [s, a], null) === c;
  const [u, l] = r, f = e["checked-data-type"], h = f === "date" ? hn(l) : l, y = f === "date" ? hn(o) : o;
  return Pt([u, h], [s, y], f) === c;
}
function Xo(t, e) {
  const n = e[1];
  return t.getAttr(n);
}
function ea(t, e, n) {
  const r = Object.keys(n)[0];
  return N(t, e, r);
}
function ta(t, e, n, r) {
  if (n)
    return Xo(t, n);
  if (r)
    return ea(t, e, r);
}
function na(t, e, n) {
  var s, i;
  if (!Array.isArray(n.fields))
    return lo(t, e);
  const r = /* @__PURE__ */ new Map();
  for (const o of n.fields) {
    const a = N(t, e, o), c = (s = a == null ? void 0 : a["forward-identity"]) == null ? void 0 : s[2];
    c && Fn(a) && r.set(c, a);
  }
  if (!r.has("id")) {
    const o = N(t, e, "id"), a = (i = o == null ? void 0 : o["forward-identity"]) == null ? void 0 : i[2];
    a && r.set(a, o);
  }
  return r;
}
function ra(t, e, { etype: n, pageInfo: r, dq: s, form: i }) {
  var b, g;
  const o = (b = i == null ? void 0 : i.$) == null ? void 0 : b.order, a = As(i), c = sa(i);
  let u = So(t, s);
  const l = r == null ? void 0 : r["start-cursor"], f = ta(e, n, l, o);
  if (f && ((g = f == null ? void 0 : f["forward-identity"]) == null ? void 0 : g[2]) !== "id") {
    const w = f["checked-data-type"] === "date", m = f.id;
    u = u.map(([_]) => {
      var O, E, j, L, B;
      let S = (B = (L = (j = (E = (O = t.eav.get(_)) == null ? void 0 : O.get(m)) == null ? void 0 : E.values()) == null ? void 0 : j.next()) == null ? void 0 : L.value) == null ? void 0 : B[2];
      return w && (S = hn(S)), [_, S];
    });
  }
  u.sort(c === "asc" ? function(m, _) {
    return Pt(m, _, f == null ? void 0 : f["checked-data-type"]);
  } : function(m, _) {
    return Pt(_, m, f == null ? void 0 : f["checked-data-type"]);
  });
  let h = {};
  const y = na(e, n, s);
  for (const w of u) {
    const [m] = w;
    if (h[m] || !a && l && f && Zo(l, f, c, w))
      continue;
    const _ = uo(t, y, m);
    _ && (h[m] = _);
  }
  return h;
}
function sa(t) {
  var n;
  const e = (n = t.$) == null ? void 0 : n.order;
  return e && e[Object.keys(e)[0]] || "asc";
}
function As(t) {
  var s, i, o;
  const e = (s = t.$) == null ? void 0 : s.offset, n = (i = t.$) == null ? void 0 : i.before, r = (o = t.$) == null ? void 0 : o.after;
  return !e && !n && !r;
}
function ia(t, e, { etype: n, level: r, form: s, join: i, pageInfo: o }) {
  var h, y, b, g, w;
  if (!As(s) && (!o || !o["start-cursor"]))
    return [];
  const a = qo(Go(e, n, r, (h = s.$) == null ? void 0 : h.where), i), c = Qo(Rt, n, r), u = (y = s.$) == null ? void 0 : y.fields, l = ra(t, e, {
    etype: n,
    pageInfo: o,
    form: s,
    dq: { where: a, find: c, fields: u }
  }), f = ((b = s.$) == null ? void 0 : b.limit) || ((g = s.$) == null ? void 0 : g.first) || ((w = s.$) == null ? void 0 : w.last);
  if (f != null) {
    r > 0 && console.warn("WARNING: Limits in child queries are only run client-side. Data returned from the server will not have a limit.");
    const m = Object.entries(l);
    return m.length <= f ? l : Object.fromEntries(m.slice(0, f));
  }
  return l;
}
function oa(t, e, n) {
  try {
    return ia(t, e, n);
  } catch (r) {
    if (r instanceof Fe)
      return {};
    throw r;
  }
}
function ks(t, e, n) {
  const r = oa(t, e, n);
  return Jo(Rt, t, e, n, r);
}
function aa(t) {
  const e = {};
  for (const [n, r] of Object.entries(t))
    e[n] = {
      startCursor: r["start-cursor"],
      endCursor: r["end-cursor"],
      hasNextPage: r["has-next-page?"],
      hasPreviousPage: r["has-previous-page?"]
    };
  return e;
}
function Cs({ store: t, attrsStore: e, pageInfo: n, aggregate: r }, s) {
  const o = { data: Object.keys(s).reduce(function(c, u) {
    return r != null && r[u] || u === "$$ruleParams" || (c[u] = ks(t, e, {
      etype: u,
      form: s[u],
      level: 0,
      pageInfo: n == null ? void 0 : n[u]
    })), c;
  }, {}) };
  return n && (o.pageInfo = aa(n)), r && (o.aggregate = r), o;
}
function ca() {
  const e = {
    __etype: 1,
    __ops: 1,
    create: 1,
    update: 1,
    link: 1,
    unlink: 1,
    delete: 1,
    merge: 1,
    ruleParams: 1
  };
  return new Set(Object.keys(e));
}
const ua = ca();
function St(t, e, n) {
  const r = {
    __etype: t,
    __ops: n
  };
  return new Proxy(r, {
    get: (s, i) => {
      if (i === "__ops")
        return n;
      if (i === "__etype")
        return t;
      if (ua.has(i))
        return (o, a) => St(t, e, [
          ...n,
          a ? [i, t, e, o, a] : [i, t, e, o]
        ]);
    }
  });
}
function la(t, e) {
  return `lookup__${t}__${JSON.stringify(e)}`;
}
function It(t) {
  return t.startsWith("lookup__");
}
function pn(t) {
  const [e, n, ...r] = t.split("__");
  return [n, JSON.parse(r.join("__"))];
}
function fa(t) {
  return new Proxy({
    __etype: t
  }, {
    get(e, n) {
      if (n === "lookup")
        return (s, i) => St(t, pn(la(s, i)), []);
      if (n === "__etype")
        return t;
      const r = n;
      return It(r) ? St(t, pn(r), []) : St(t, r, []);
    }
  });
}
function Kn() {
  return new Proxy({}, {
    get(t, e) {
      return fa(e);
    }
  });
}
const Ru = Kn();
function da(t) {
  return t.__ops;
}
function ha(t, e) {
  const { attrIdMap: n, refSwapAttrIds: r } = t, s = [];
  for (const o of e) {
    const a = n[o];
    if (a)
      s.push(a);
    else if (Array.isArray(o) && o.length == 2 && n[o[0]]) {
      const [c, u] = o;
      s.push([n[c], u]);
    } else
      s.push(o);
  }
  const [i] = e;
  if ((i === "add-triple" || i === "retract-triple") && r.has(e[2])) {
    const o = s[1];
    s[1] = s[3], s[3] = o;
  }
  return s;
}
function pa(t) {
  if (Array.isArray(t))
    return t;
  const e = Object.entries(t);
  if (e.length !== 1)
    throw new Error("lookup must be an object with a single unique attr and value.");
  return e[0];
}
function ya(t, e, n) {
  return n.indexOf(".") !== -1 && // attr names can have `.` in them, so use the attr we find with a `.`
  // before assuming it's a ref lookup.
  !N(t, e, n);
}
function yn(t) {
  const [e, n, ...r] = t.split(".");
  if (r.length > 0 || n !== "id")
    throw new Error(`${t} is not a valid lookup attribute.`);
  return e;
}
function ba(t, e, n) {
  if (!ya(t, e, n))
    return N(t, e, n);
  const r = yn(n), s = N(t, e, r) || Ce(t, e, r);
  if (s && s["value-type"] !== "ref")
    throw new Error(`${n} does not reference a valid link attribute.`);
  return s;
}
function bn(t) {
  return typeof t == "string" && !It(t) ? null : typeof t == "string" && It(t) ? pn(t) : pa(t);
}
function ee(t, e, n) {
  const r = bn(n);
  if (r === null)
    return n;
  const [s, i] = r, o = ba(t, e, s);
  if (!o || !o["unique?"])
    throw new Error(`${s} is not a unique attribute.`);
  return [o.id, i];
}
function Ps(t, e, n, r) {
  var o;
  const s = ee(t, e, n);
  return Array.isArray(s) ? [[
    "add-triple",
    s,
    (o = N(t, e, "id")) == null ? void 0 : o.id,
    s
  ]].concat(r) : r;
}
function ga({ attrsStore: t }, [e, n, r]) {
  const s = Object.entries(r).flatMap(([i, o]) => {
    const a = Array.isArray(o) ? o : [o], c = N(t, e, i), u = Ce(t, e, i);
    return a.map((l) => c ? [
      "add-triple",
      ee(t, e, n),
      c.id,
      // Uses `!` because if we get here, we should have created the attr if it doesn't
      // already exist
      ee(t, c["reverse-identity"][1], l)
    ] : [
      "add-triple",
      // Uses `!` because if we get here, we should have created the attr if it doesn't
      // already exist
      ee(t, u["forward-identity"][1], l),
      u == null ? void 0 : u.id,
      ee(t, e, n)
    ]);
  });
  return Ps(t, e, n, s);
}
function _a({ attrsStore: t }, [e, n, r]) {
  const s = Object.entries(r).flatMap(([i, o]) => {
    const a = Array.isArray(o) ? o : [o], c = N(t, e, i), u = Ce(t, e, i);
    return a.map((l) => c ? [
      "retract-triple",
      ee(t, e, n),
      c.id,
      // Uses `!` because if we get here, we should have created the attr if it doesn't
      // already exist
      ee(t, c["reverse-identity"][1], l)
    ] : [
      "retract-triple",
      // Uses `!` because if we get here, we should have created the attr if it doesn't
      // already exist
      ee(t, u["forward-identity"][1], l),
      u.id,
      ee(t, e, n)
    ]);
  });
  return Ps(t, e, n, s);
}
function wa(t, e, n, r) {
  var s;
  if (Array.isArray(r)) {
    const [i, o] = r;
    for (const a of t || []) {
      const c = a == null ? void 0 : a.aev.get(i);
      if (c) {
        for (const [u, l, f] of X(c, 2))
          if (f === o)
            return !0;
      }
    }
  } else
    for (const i of t || []) {
      const o = i == null ? void 0 : i.eav.get(r);
      if (o) {
        for (const a of o.keys())
          if (((s = e.getAttr(a)) == null ? void 0 : s["forward-identity"][1]) == n)
            return !0;
      }
    }
  return !1;
}
function Is({ stores: t, attrsStore: e }, [n, r, s, i]) {
  return (i == null ? void 0 : i.upsert) === !1 ? { mode: "update" } : (i == null ? void 0 : i.upsert) === !0 ? null : wa(t, e, n, r) ? { mode: "update" } : null;
}
function Ta(t, e) {
  const { attrsStore: n } = t, [r, s, i, o] = e, a = Un(i), c = ee(n, r, s);
  return [["id", c]].concat(Object.entries(a)).map(([l, f]) => {
    const h = N(n, r, l);
    return h["checked-data-type"] === "date" && t.useDateObjects && (f = jt(f)), ["add-triple", c, h.id, f, { mode: "create" }];
  });
}
function ma(t, e) {
  const { attrsStore: n } = t, [r, s, i, o] = e, a = Un(i), c = ee(n, r, s), u = Is(t, [r, c, i, o]);
  return [["id", c]].concat(Object.entries(a)).map(([f, h]) => {
    const y = N(n, r, f);
    return y["checked-data-type"] === "date" && t.useDateObjects && (h = jt(h)), [
      "add-triple",
      c,
      y.id,
      h,
      ...u ? [u] : []
    ];
  });
}
function Sa({ attrsStore: t }, [e, n]) {
  return [["delete-entity", ee(t, e, n), e]];
}
function va(t, e) {
  const { attrsStore: n } = t, [r, s, i, o] = e, a = Un(i), c = ee(n, r, s), u = Is(t, [r, c, i, o]), l = Object.entries(a).map(([h, y]) => {
    const b = N(n, r, h);
    return [
      "deep-merge-triple",
      c,
      b.id,
      y,
      ...u ? [u] : []
    ];
  });
  return [[
    "add-triple",
    c,
    N(n, r, "id").id,
    c,
    ...u ? [u] : []
  ]].concat(l);
}
function Ea({ attrsStore: t }, [e, n, r]) {
  return [["rule-params", ee(t, e, n), e, r]];
}
function Oa(t) {
  const [e, n, r, s, i] = t;
  if (!s)
    return t;
  const o = { ...s };
  return delete o.id, [e, n, r, o, ...i ? [i] : []];
}
function Aa(t, e) {
  const [n, ...r] = Oa(e);
  switch (n) {
    case "merge":
      return va(t, r);
    case "create":
      return Ta(t, r);
    case "update":
      return ma(t, r);
    case "link":
      return ga(t, r);
    case "unlink":
      return _a(t, r);
    case "delete":
      return Sa(t, r);
    case "ruleParams":
      return Ea(t, r);
    default:
      throw new Error(`unsupported action ${n}`);
  }
}
function ka(t) {
  switch (t) {
    case "string":
    case "date":
    case "boolean":
    case "number":
      return t;
    default:
      return;
  }
}
function Ca(t, e, n) {
  var a, c;
  const r = (c = (a = t.entities[e]) == null ? void 0 : a.attrs) == null ? void 0 : c[n];
  if (n === "id")
    return null;
  if (!r)
    throw new Error(`${e}.${n} does not exist in your schema`);
  const { unique: s, indexed: i } = r == null ? void 0 : r.config, o = ka(r == null ? void 0 : r.valueType);
  return {
    "index?": i,
    "unique?": s,
    "checked-data-type": o
  };
}
function yt(t, e, n, r) {
  const s = t ? Ca(t, e, n) : null, i = W(), a = [W(), e, n];
  return {
    id: i,
    "forward-identity": a,
    "value-type": "blob",
    cardinality: "one",
    "unique?": !1,
    "index?": !1,
    isUnsynced: !0,
    ...s || {},
    ...r || {}
  };
}
function Pa(t, e, n) {
  return Object.values(t.links).find((i) => i.forward.on === e && i.forward.label === n || i.reverse.on === e && i.reverse.label === n);
}
function Ia(t, e, n) {
  const r = Pa(t, e, n);
  if (!r)
    throw new Error(`Couldn't find the link ${e}.${n} in your schema`);
  const { forward: s, reverse: i } = r;
  return {
    "forward-identity": [W(), s.on, s.label],
    "reverse-identity": [W(), i.on, i.label],
    cardinality: s.has === "one" ? "one" : "many",
    "unique?": i.has === "one",
    "on-delete": s.onDelete,
    "on-delete-reverse": i.onDelete
  };
}
function Cr(t, e, n, r) {
  const s = t ? Ia(t, e, n) : null, i = W(), o = [W(), e, n], a = [W(), n, e];
  return {
    id: i,
    // @ts-ignore: ts thinks it's any[]
    "forward-identity": o,
    // @ts-ignore: ts thinks it's any[]
    "reverse-identity": a,
    "value-type": "ref",
    // @ts-ignore: ts thinks it's type string
    cardinality: "many",
    "unique?": !1,
    "index?": !1,
    isUnsynced: !0,
    ...s || {},
    ...r || {}
  };
}
const Ma = /* @__PURE__ */ new Set(["create", "update", "merge", "link", "unlink"]), ja = /* @__PURE__ */ new Set(["link", "unlink"]), Ra = /* @__PURE__ */ new Set(["create", "update", "merge"]), xa = /* @__PURE__ */ new Set([
  "link",
  "unlink",
  "create",
  "update",
  "merge",
  "delete",
  "ruleParams"
]), gn = { "unique?": !0, "index?": !0 }, $a = {
  ...gn,
  cardinality: "one"
};
function Da(t) {
  const e = [], [n, r, s, i] = t;
  if (!xa.has(n))
    return e;
  const o = bn(s);
  if (o && e.push({ etype: r, lookupPair: o }), n === "link")
    for (const [a, c] of Object.entries(i)) {
      const u = Array.isArray(c) ? c : [c];
      for (const l of u) {
        const f = bn(l);
        f && e.push({
          etype: r,
          lookupPair: f,
          linkLabel: a
        });
      }
    }
  return e;
}
function Ua({ attrsStore: t, schema: e }, n) {
  var h, y;
  const r = /* @__PURE__ */ new Set(), s = [], i = [];
  function o(b, g) {
    return N(t, b, g) || s.find((w) => w["forward-identity"][1] === b && w["forward-identity"][2] === g);
  }
  function a(b, g) {
    return Ce(t, b, g) || s.find((w) => {
      var m, _;
      return ((m = w["reverse-identity"]) == null ? void 0 : m[1]) === b && ((_ = w["reverse-identity"]) == null ? void 0 : _[2]) === g;
    });
  }
  function c(b) {
    s.push(b), i.push(["add-attr", b]), r.add(b.id);
  }
  function u(b) {
    b && "isUnsynced" in b && b.isUnsynced && !r.has(b.id) && (s.push(b), i.push(["add-attr", b]), r.add(b.id));
  }
  function l(b, g) {
    return g.indexOf(".") !== -1 && // attr names can have `.` in them, so use the attr we find with a `.`
    // before assuming it's a ref lookup.
    !o(b, g);
  }
  function f(b, g) {
    const w = o(b, g), m = a(b, g);
    u(w), u(m), !w && !m && c(Cr(e, b, g, $a));
  }
  for (const b of n)
    for (const { etype: g, lookupPair: w, linkLabel: m } of Da(b)) {
      const _ = w[0];
      if (m) {
        f(g, m);
        const S = o(g, m), O = a(g, m);
        u(S), u(O);
        const E = ((h = S == null ? void 0 : S["reverse-identity"]) == null ? void 0 : h[1]) || ((y = O == null ? void 0 : O["forward-identity"]) == null ? void 0 : y[1]) || m;
        if (l(E, _))
          f(E, yn(_));
        else {
          const j = o(E, _);
          j || c(yt(e, E, _, gn)), u(j);
        }
      } else if (l(g, _))
        f(g, yn(_));
      else {
        const S = o(g, _);
        S || c(yt(e, g, _, gn)), u(S);
      }
    }
  for (const b of n) {
    const [g, w, m, _] = b;
    if (Ma.has(g)) {
      const S = o(w, "id");
      u(S), S || c(yt(e, w, "id", { "unique?": !0 }));
      for (const O of Object.keys(_)) {
        const E = o(w, O);
        if (u(E), Ra.has(g) && (E || c(yt(e, w, O, O === "id" ? { "unique?": !0 } : null))), ja.has(g)) {
          const j = a(w, O);
          !E && !j && c(Cr(e, w, O)), u(j);
        }
      }
    }
  }
  if (s.length) {
    const b = { ...t.attrs };
    for (const g of s)
      b[g.id] = g;
    return [new Ee(b, t.linkIndex), i];
  }
  return [t, i];
}
function La(t, e) {
  const r = (Array.isArray(e) ? e : [e]).flatMap((c) => da(c)), [s, i] = Ua(t, r), o = { ...t, attrsStore: s }, a = r.flatMap((c) => Aa(o, c));
  return [...i, ...a];
}
function Pr(t, e) {
  typeof requestIdleCallback > "u" ? t() : requestIdleCallback(t, { timeout: e });
}
const nt = "__meta";
class Fa {
  constructor(e, n) {
  }
}
class _n {
  constructor(e) {
    p(this, "currentValue");
    p(this, "_subs", []);
    p(this, "_persister");
    p(this, "_merge");
    p(this, "serialize");
    p(this, "parse");
    p(this, "_saveThrottleMs");
    p(this, "_idleCallbackMaxWaitMs");
    p(this, "_nextSave", null);
    p(this, "_nextGc", null);
    p(this, "_pendingSaveKeys", /* @__PURE__ */ new Set());
    p(this, "_loadedKeys", /* @__PURE__ */ new Set());
    p(this, "_loadingKeys");
    p(this, "_objectSize");
    p(this, "_log");
    p(this, "onKeyLoaded");
    p(this, "_version", 0);
    p(this, "_meta", {
      isLoading: !0,
      onLoadCbs: [],
      value: null,
      error: null,
      attempts: 0
    });
    p(this, "_gcOpts");
    this._persister = e.persister, this._merge = e.merge, this.serialize = e.serialize, this.parse = e.parse, this._objectSize = e.objectSize, this._log = e.logger, this._saveThrottleMs = e.saveThrottleMs ?? 100, this._idleCallbackMaxWaitMs = e.idleCallbackMaxWaitMs ?? 1e3, this._gcOpts = e.gc, this.currentValue = {}, this._loadedKeys = /* @__PURE__ */ new Set(), this._loadingKeys = {}, this._initMeta(), e.preloadEntryCount && this._preloadEntries(e.preloadEntryCount);
  }
  async _initMeta() {
    var e;
    this._meta.loadingPromise && await this._meta.loadingPromise;
    try {
      const n = this._persister.getItem(nt);
      this._meta.loadingPromise = n;
      const r = await n;
      this._meta.isLoading = !1, this._meta.error = null, this._meta.loadingPromise = null, this._meta.attempts = 0;
      const s = ((e = this._meta.value) == null ? void 0 : e.objects) ?? {}, i = r ?? {}, o = i.objects ?? {};
      this._meta.value = {
        ...i,
        objects: { ...s, ...o }
      };
    } catch (n) {
      this._meta.error = n, this._meta.attempts++, this._meta.loadingPromise = null;
    }
  }
  async _getMeta() {
    return this._meta.value ? this._meta.value : this._meta.loadingPromise ? (await this._meta.loadingPromise, this._meta.value) : (this._initMeta(), await this._meta.loadingPromise, this._meta.value);
  }
  async _refreshMeta() {
    return await this._initMeta(), this._meta.value;
  }
  async _preloadEntries(e) {
    const n = await this.waitForMetaToLoad();
    if (!n)
      return;
    const r = Object.entries(n.objects);
    r.sort(([s, i], [o, a]) => a.updatedAt - i.updatedAt);
    for (const [s] of r.slice(0, e))
      this._loadKey(s);
  }
  async _getFromStorage(e) {
    try {
      const n = await this._persister.getItem(e);
      return n && this.parse(e, n);
    } catch (n) {
      return console.error(`Unable to read from storage for key=${e}`, n), null;
    }
  }
  async waitForKeyToLoad(e) {
    return this._loadedKeys.has(e) ? this.currentValue[e] : (await (this._loadingKeys[e] || this._loadKey(e)), this.currentValue[e]);
  }
  // Used for tests
  async waitForMetaToLoad() {
    return this._getMeta();
  }
  // Unloads the key so that it can be garbage collected, but does not
  // delete it. Removes the key from currentValue.
  unloadKey(e) {
    this._loadedKeys.delete(e), delete this._loadingKeys[e], delete this.currentValue[e];
  }
  async _loadKey(e) {
    if (this._loadedKeys.has(e) || e in this._loadingKeys)
      return;
    const n = this._getFromStorage(e);
    this._loadingKeys[e] = n;
    const r = await n;
    if (delete this._loadingKeys[e], this._loadedKeys.add(e), r) {
      const s = this._merge(e, r, this.currentValue[e]);
      s && (this.currentValue[e] = s);
    }
    this.onKeyLoaded && this.onKeyLoaded(e);
  }
  // Returns a promise with a number so that we can wait for flush
  // to finish in the tests. The number is the number of operations
  // it performed, but it's mostly there so that typescript will warn
  // us if we forget to retun the promise from the function.
  _writeToStorage(e) {
    const n = [], r = e == null ? void 0 : e.skipGc;
    if (this._meta.isLoading) {
      const f = new Promise((h, y) => {
        setTimeout(() => this._enqueuePersist(e ? { ...e, attempts: (e.attempts || 0) + 1 } : { attempts: 1 }).then(h).catch(y), 10 + ((e == null ? void 0 : e.attempts) ?? 0) * 1e3);
      });
      return n.push(f), Promise.all(n).then((h) => h.reduce((y, b) => y + b, 0));
    }
    const s = this._meta.value;
    if (!s)
      return Promise.resolve(0);
    const i = [], o = [];
    for (const f of this._pendingSaveKeys)
      f in this.currentValue ? o.push(f) : (i.push(f), delete s.objects[f]);
    for (const f of i) {
      const h = this._persister.removeItem(f);
      n.push(h.then(() => 1)), this._loadedKeys.delete(f), this._pendingSaveKeys.delete(f);
    }
    const a = [], c = [[nt, s]], u = s.objects ?? {};
    s.objects = u;
    for (const f of o)
      if (this._loadedKeys.has(f)) {
        const h = this.serialize(f, this.currentValue[f]);
        c.push([f, h]);
        const y = this._objectSize(h), b = u[f] ?? {
          createdAt: Date.now(),
          updatedAt: Date.now(),
          size: y
        };
        b.updatedAt = Date.now(), b.size = y, u[f] = b, this._pendingSaveKeys.delete(f);
      } else
        a.push(f);
    const l = this._persister.multiSet(c);
    n.push(l.then(() => 1));
    for (const f of a) {
      const h = this._loadKey(f).then(() => this._enqueuePersist(e));
      n.push(h);
    }
    return r || this.gc(), Promise.all(n).then((f) => f.reduce((h, y) => h + y, 0));
  }
  async flush() {
    return this._nextSave ? (clearTimeout(this._nextSave), this._nextSave = null, this._writeToStorage()) : void 0;
  }
  async _gc() {
    if (!this._gcOpts)
      return;
    const e = new Set(await this._persister.getAllKeys());
    e.delete(nt);
    const n = new Set(Object.keys(this.currentValue));
    for (const h of Object.keys(this._loadingKeys))
      n.add(h);
    for (const h of this._loadedKeys)
      n.add(h);
    const r = await this._refreshMeta();
    if (!r) {
      this._log.info("Could not gc because we were not able to load meta");
      return;
    }
    const s = [], i = {
      gcOpts: this._gcOpts,
      keys: e,
      sacredKeys: n,
      removed: [],
      metaRemoved: [],
      removedMissingCount: 0,
      removedOldCount: 0,
      removedThresholdCount: 0,
      removedSizeCount: 0
    };
    for (const h of e)
      n.has(h) || h in r.objects || (this._log.info("Lost track of key in meta", h), s.push(this._persister.removeItem(h)), i.removed.push(h), i.removedMissingCount++);
    const o = Date.now();
    for (const [h, y] of Object.entries(r.objects))
      !n.has(h) && y.updatedAt < o - this._gcOpts.maxAgeMs && (s.push(this._persister.removeItem(h)), delete r.objects[h], i.removed.push(h), i.removedOldCount++);
    const a = Object.entries(r.objects);
    a.sort(([h, y], [b, g]) => y.updatedAt - g.updatedAt);
    const c = a.filter(([h]) => !n.has(h));
    if (a.length > this._gcOpts.maxEntries)
      for (const [h] of c.slice(0, a.length - this._gcOpts.maxEntries))
        s.push(this._persister.removeItem(h)), delete r.objects[h], i.removed.push(h), i.removedThresholdCount++;
    const u = Object.entries(r.objects);
    u.sort(([h, y], [b, g]) => y.updatedAt - g.updatedAt);
    const l = u.filter(([h]) => !n.has(h));
    let f = u.reduce((h, [y, b]) => h + b.size, 0);
    for (; f > 0 && f > this._gcOpts.maxSize && l.length; ) {
      const [[h, y]] = l.splice(0, 1);
      f -= y.size, s.push(this._persister.removeItem(h)), delete r.objects[h], i.removed.push(h), i.removedSizeCount++;
    }
    for (const h of Object.keys(r.objects))
      !e.has(h) && !n.has(h) && delete r.objects[h];
    return (i.removed.length || i.metaRemoved.length) && s.push(this._enqueuePersist({ skipGc: !0 })), this._log.info("Completed GC", i), await Promise.all(s), i;
  }
  // Schedules a GC to run in one minute (unless it is already scheduled)
  gc() {
    this._nextGc || (this._nextGc = setTimeout(
      () => {
        Pr(() => {
          this._nextGc = null, this._gc();
        }, 30 * 1e3);
      },
      // 1 minute + some jitter to keep multiple tabs from running at same time
      1e3 * 60 + Math.random() * 500
    ));
  }
  _enqueuePersist(e) {
    return new Promise((n, r) => {
      if (this._nextSave) {
        n(0);
        return;
      }
      this._nextSave = setTimeout(() => {
        Pr(() => {
          this._nextSave = null, this._writeToStorage(e).then(n).catch(r);
        }, this._idleCallbackMaxWaitMs);
      }, this._saveThrottleMs);
    });
  }
  version() {
    return this._version;
  }
  // Takes a function that updates the store in place.
  // Uses `mutative` to get a list of keys that were changed
  // so that we know which entries we need to persist to the store.
  updateInPlace(e) {
    this._version++;
    const [n, r] = Ct(this.currentValue, e, {
      enablePatches: !0
    });
    for (const s of r) {
      const i = s.path[0];
      i && typeof i == "string" && (this._pendingSaveKeys.add(i), this._loadedKeys.has(i) || this._loadKey(i));
    }
    this.currentValue = n, this._enqueuePersist();
    for (const s of this._subs)
      s(this.currentValue);
    return n;
  }
  subscribe(e) {
    return this._subs.push(e), e(this.currentValue), () => {
      this._subs = this._subs.filter((n) => n !== e);
    };
  }
}
const Na = 6, Ka = ["kv", "querySubs", "syncSubs"];
function qa(t) {
  return function(n) {
    console.error("Error in IndexedDB event", { source: t, event: n });
  };
}
async function Wa(t) {
  return new Promise((e) => {
    const n = indexedDB.open(t);
    n.onerror = (r) => {
      e(null);
    }, n.onsuccess = (r) => {
      const i = r.target.result;
      e(i);
    }, n.onupgradeneeded = (r) => {
      var i;
      (i = r.target.transaction) == null || i.abort(), e(null);
    };
  });
}
async function za(t, e, n) {
  const r = (
    // Backwards compatibility for older versions where we JSON.stringified before storing
    typeof e == "string" ? JSON.parse(e) : e
  );
  if (!r)
    return;
  const s = /* @__PURE__ */ new Set();
  return new Promise((i, o) => {
    var l, f, h;
    const a = {};
    for (const [y, b] of Object.entries(r)) {
      const g = typeof b == "string" ? JSON.parse(b) : b;
      if (g.lastAccessed) {
        const m = {
          createdAt: g.lastAccessed,
          updatedAt: g.lastAccessed,
          size: ((h = (f = (l = g.result) == null ? void 0 : l.store) == null ? void 0 : f.triples) == null ? void 0 : h.length) ?? 0
        };
        a[y] = m;
      }
      const w = n.put(g, y);
      s.add(w);
    }
    const c = { objects: a }, u = n.put(c, nt);
    s.add(u);
    for (const y of s)
      y.onsuccess = () => {
        s.delete(y), s.size === 0 && i();
      }, y.onerror = (b) => {
        o(b);
      };
  });
}
async function Ir(t, e, n) {
  const r = n.put(e, t);
  return new Promise((s, i) => {
    r.onsuccess = () => s(), r.onerror = (o) => i(o);
  });
}
async function Va(t, e) {
  const n = await Wa(`instant_${t}_5`);
  if (!n)
    return;
  const r = await new Promise((l, f) => {
    const b = n.transaction(["kv"], "readonly").objectStore("kv").openCursor();
    b.onerror = (w) => {
      f(w);
    };
    const g = [];
    b.onsuccess = () => {
      const w = b.result;
      if (w) {
        const m = w.key, _ = w.value;
        g.push([m, _]), w.continue();
      } else
        l(g);
    }, b.onerror = (w) => {
      f(w);
    };
  }), s = e.transaction(["kv", "querySubs"], "readwrite"), i = s.objectStore("kv"), o = s.objectStore("querySubs"), a = [], c = { objects: {} };
  for (const [l, f] of r)
    switch (l) {
      case "querySubs": {
        const h = za(l, f, o);
        a.push(h);
        break;
      }
      default: {
        const h = Ir(l, f, i);
        a.push(h);
        const y = {
          createdAt: Date.now(),
          updatedAt: Date.now(),
          size: 0
        };
        c.objects[l] = y;
        break;
      }
    }
  const u = Ir(nt, c, i);
  a.push(u), await Promise.all(a), await new Promise((l, f) => {
    s.oncomplete = (h) => l(h), s.onerror = (h) => f(h), s.onabort = (h) => f(h);
  });
}
const Mr = /* @__PURE__ */ new Map();
class Ms extends Fa {
  constructor(n, r) {
    super(n, r);
    p(this, "dbName");
    p(this, "_storeName");
    p(this, "_appId");
    p(this, "_prefix");
    p(this, "_dbPromise");
    this.dbName = `instant_${n}_${Na}`, this._storeName = r, this._appId = n, this._dbPromise = this._init();
  }
  _init() {
    return new Promise((n, r) => {
      let s = !1;
      const i = indexedDB.open(this.dbName, 1);
      i.onerror = (o) => {
        r(o);
      }, i.onsuccess = (o) => {
        const c = o.target.result;
        if (s) {
          const u = Va(this._appId, c).catch((l) => {
            qa("Error upgrading store from version 5 to 6.")(l);
          });
          Mr.set(this.dbName, u), u.then(() => n(c)).catch(() => n(c));
        } else {
          const u = Mr.get(this.dbName);
          u ? u.then(() => n(c)).catch(() => n(c)) : n(c);
        }
      }, i.onupgradeneeded = (o) => {
        s = !0, this._upgradeStore(o);
      };
    });
  }
  _upgradeStore(n) {
    const s = n.target.result;
    for (const i of Ka)
      s.objectStoreNames.contains(i) || s.createObjectStore(i);
  }
  async getItem(n) {
    const r = await this._dbPromise;
    return new Promise((s, i) => {
      const c = r.transaction([this._storeName], "readonly").objectStore(this._storeName).get(n);
      c.onerror = (u) => {
        i(u);
      }, c.onsuccess = (u) => {
        c.result ? s(c.result) : s(null);
      };
    });
  }
  async setItem(n, r) {
    const s = await this._dbPromise;
    return new Promise((i, o) => {
      const u = s.transaction([this._storeName], "readwrite").objectStore(this._storeName).put(r, n);
      u.onerror = (l) => {
        o(l);
      }, u.onsuccess = (l) => {
        i();
      };
    });
  }
  // Performs all writes in a transaction so that all succeed or none succeed.
  async multiSet(n) {
    const r = await this._dbPromise;
    return new Promise((s, i) => {
      const o = r.transaction([this._storeName], "readwrite"), a = o.objectStore(this._storeName), c = /* @__PURE__ */ new Set();
      for (const [u, l] of n) {
        const f = a.put(l, u);
        c.add(f);
      }
      for (const u of c)
        u.onerror = (l) => {
          o.abort(), i(l);
        }, u.onsuccess = (l) => {
          c.delete(u), c.size === 0 && s();
        };
    });
  }
  async removeItem(n) {
    const r = await this._dbPromise;
    return new Promise((s, i) => {
      const c = r.transaction([this._storeName], "readwrite").objectStore(this._storeName).delete(n);
      c.onerror = (u) => {
        i(u);
      }, c.onsuccess = (u) => {
        s();
      };
    });
  }
  async getAllKeys() {
    const n = await this._dbPromise;
    return new Promise((r, s) => {
      const a = n.transaction([this._storeName], "readonly").objectStore(this._storeName).getAllKeys();
      a.onerror = (c) => {
        s(c);
      }, a.onsuccess = (c) => {
        r(a.result.filter((u) => typeof u == "string"));
      };
    });
  }
}
class js {
  static async getIsOnline() {
    return navigator.onLine;
  }
  static listen(e) {
    const n = () => {
      e(!0);
    }, r = () => {
      e(!1);
    };
    return addEventListener("online", n), addEventListener("offline", r), () => {
      removeEventListener("online", n), removeEventListener("offline", r);
    };
  }
}
class Ne extends Error {
  constructor(n, r) {
    super(n);
    p(this, "hint");
    this.hint = r;
    const s = new.target.prototype;
    Object.setPrototypeOf && Object.setPrototypeOf(this, s), Error.captureStackTrace && Error.captureStackTrace(this, Ne), this.name = "InstantError";
  }
  get [Symbol.toStringTag]() {
    return "InstantError";
  }
}
class xt extends Ne {
  constructor(n) {
    var i;
    const r = ((i = n.body) == null ? void 0 : i.message) || `API Error (${n.status})`;
    super(r, n.body.hint);
    p(this, "body");
    p(this, "status");
    const s = new.target.prototype;
    Object.setPrototypeOf && Object.setPrototypeOf(this, s), Error.captureStackTrace && Error.captureStackTrace(this, xt), this.name = "InstantAPIError", this.status = n.status, this.body = n.body;
  }
  get [Symbol.toStringTag]() {
    return "InstantAPIError";
  }
}
async function ue(t, e) {
  const n = await fetch(t, e), r = await n.json();
  return n.status === 200 ? Promise.resolve(r) : Promise.reject(new xt({ status: n.status, body: r }));
}
function Ba({ apiURI: t, appId: e, email: n }) {
  return ue(`${t}/runtime/auth/send_magic_code`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ "app-id": e, email: n })
  });
}
async function Ga({ apiURI: t, appId: e, email: n, code: r, refreshToken: s }) {
  return await ue(`${t}/runtime/auth/verify_magic_code`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({
      "app-id": e,
      email: n,
      code: r,
      ...s ? { "refresh-token": s } : {}
    })
  });
}
async function Qa({ apiURI: t, appId: e, refreshToken: n }) {
  return await ue(`${t}/runtime/auth/verify_refresh_token`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({
      "app-id": e,
      "refresh-token": n
    })
  });
}
async function Ha({ apiURI: t, appId: e }) {
  return await ue(`${t}/runtime/auth/sign_in_guest`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({
      "app-id": e
    })
  });
}
async function jr({ apiURI: t, appId: e, code: n, codeVerifier: r, refreshToken: s }) {
  return await ue(`${t}/runtime/oauth/token`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({
      app_id: e,
      code: n,
      code_verifier: r,
      refresh_token: s
    })
  });
}
async function Ja({ apiURI: t, appId: e, nonce: n, idToken: r, clientName: s, refreshToken: i }) {
  return await ue(`${t}/runtime/oauth/id_token`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({
      app_id: e,
      nonce: n,
      id_token: r,
      client_name: s,
      refresh_token: i
    })
  });
}
async function Ya({ apiURI: t, appId: e, refreshToken: n }) {
  return await ue(`${t}/runtime/signout`, {
    method: "POST",
    headers: {
      "content-type": "application/json"
    },
    body: JSON.stringify({
      app_id: e,
      refresh_token: n
    })
  });
}
async function Za({ apiURI: t, appId: e, path: n, file: r, refreshToken: s, contentType: i, contentDisposition: o }) {
  const a = {
    app_id: e,
    path: n,
    authorization: `Bearer ${s}`,
    "content-type": i || r.type
  };
  return o && (a["content-disposition"] = o), await ue(`${t}/storage/upload`, {
    method: "PUT",
    headers: a,
    body: r
  });
}
async function Xa({ apiURI: t, appId: e, path: n, refreshToken: r }) {
  const { data: s } = await ue(`${t}/storage/files?app_id=${e}&filename=${encodeURIComponent(n)}`, {
    method: "DELETE",
    headers: {
      "content-type": "application/json",
      authorization: `Bearer ${r}`
    }
  });
  return s;
}
async function ec({ apiURI: t, appId: e, fileName: n, refreshToken: r, metadata: s = {} }) {
  const { data: i } = await ue(`${t}/storage/signed-upload-url`, {
    method: "POST",
    headers: {
      "content-type": "application/json",
      authorization: `Bearer ${r}`
    },
    body: JSON.stringify({
      app_id: e,
      filename: n
    })
  });
  return i;
}
async function tc(t, e) {
  return (await fetch(t, {
    method: "PUT",
    body: e,
    headers: {
      "Content-Type": e.type
    }
  })).ok;
}
async function nc({ apiURI: t, appId: e, path: n, refreshToken: r }) {
  const { data: s } = await ue(`${t}/storage/signed-download-url?app_id=${e}&filename=${encodeURIComponent(n)}`, {
    method: "GET",
    headers: {
      "content-type": "application/json",
      authorization: `Bearer ${r}`
    }
  });
  return s;
}
let qn = !1, Rs = !1, xs = !1;
typeof window < "u" && typeof window.localStorage < "u" && (qn = !!window.localStorage.getItem("devBackend"), Rs = !!window.localStorage.getItem("__instantLogging"), xs = !!window.localStorage.getItem("__devtoolLocalDash"));
function Rr(t, e) {
  if (!e)
    return t;
  const n = {};
  return e.forEach((r) => {
    n[r] = t[r];
  }), n;
}
function rc(t, e, n) {
  const r = {
    peers: {}
  };
  if (e && "user" in e ? e.user : !0) {
    const i = Rr(t.user ?? {}, e == null ? void 0 : e.keys);
    r.user = { ...i, peerId: n };
  }
  for (const i of Object.keys(t.peers ?? {})) {
    const o = (e == null ? void 0 : e.peers) === void 0, a = Array.isArray(e == null ? void 0 : e.peers) && (e == null ? void 0 : e.peers.includes(i));
    if (o || a) {
      const c = Rr(t.peers[i], e == null ? void 0 : e.keys);
      r.peers[i] = { ...c, peerId: i };
    }
  }
  return r;
}
function sc(t, e) {
  if (t.isLoading !== e.isLoading || t.error !== e.error || (t.user || e.user) && (!t.user || !e.user || !_r(t.user, e.user)) || !ls(t.peers, e.peers))
    return !0;
  for (const r of Object.keys(t.peers))
    if (!_r(t.peers[r], e.peers[r]))
      return !0;
  return !1;
}
class xr {
  constructor() {
    p(this, "promise");
    p(this, "_resolve");
    p(this, "_reject");
    this.promise = new Promise((e, n) => {
      this._resolve = e, this._reject = n;
    });
  }
  resolve(e) {
    this._resolve(e);
  }
  reject(e) {
    this._reject(e);
  }
}
function $s(t, e = []) {
  t.forEach((n) => {
    const { data: r } = n, { "datalog-result": s } = r, { "join-rows": i } = s;
    for (const o of i)
      for (const a of o)
        e.push(a);
    $s(n["child-nodes"], e);
  });
}
function $r(t) {
  const e = [];
  return $s(t, e), e;
}
function Dr(t) {
  return Object.values(t.links).reduce((e, n) => {
    var r, s;
    return e[r = n.forward.on] ?? (e[r] = {}), e[n.forward.on][n.forward.label] = {
      isForward: !0,
      isSingular: n.forward.has === "one",
      link: n
    }, e[s = n.reverse.on] ?? (e[s] = {}), e[n.reverse.on][n.reverse.label] = {
      isForward: !1,
      isSingular: n.reverse.has === "one",
      link: n
    }, e;
  }, {});
}
const Wn = "v0.22.121";
function ic(t, e) {
  return {
    info: t ? (...n) => console.info(...n, e()) : () => {
    },
    debug: t ? (...n) => console.debug(...n, e()) : () => {
    },
    error: t ? (...n) => console.error(...n, e()) : () => {
    }
  };
}
class H {
  constructor(e, n, r, s = { indexed: !1, unique: !1 }) {
    p(this, "valueType");
    p(this, "required");
    p(this, "isIndexed");
    p(this, "config");
    p(this, "metadata", {});
    this.valueType = e, this.required = n, this.isIndexed = r, this.config = s;
  }
  /**
   * @deprecated Only use this temporarily for attributes that you want
   * to treat as required in frontend code but cant yet mark as required
   * and enforced for backend
   */
  clientRequired() {
    return new H(this.valueType, !1, this.isIndexed, this.config);
  }
  optional() {
    return new H(this.valueType, !1, this.isIndexed, this.config);
  }
  unique() {
    return new H(this.valueType, this.required, this.isIndexed, {
      ...this.config,
      unique: !0
    });
  }
  indexed() {
    return new H(this.valueType, this.required, !0, {
      ...this.config,
      indexed: !0
    });
  }
}
class $t {
  constructor(e, n) {
    p(this, "attrs");
    p(this, "links");
    this.attrs = e, this.links = n;
  }
  asType() {
    return new $t(this.attrs, this.links);
  }
}
class Dt {
  constructor(e, n, r) {
    p(this, "entities");
    p(this, "links");
    p(this, "rooms");
    this.entities = e, this.links = n, this.rooms = r;
  }
  /**
   * @deprecated
   * `withRoomSchema` is deprecated. Define your schema in `rooms` directly:
   *
   * @example
   * // Before:
   * const schema = i.schema({
   *   // ...
   * }).withRoomSchema<RoomSchema>()
   *
   * // After
   * const schema = i.schema({
   *  rooms: {
   *    // ...
   *  }
   * })
   *
   * @see https://instantdb.com/docs/presence-and-topics#typesafety
   */
  withRoomSchema() {
    return new Dt(this.entities, this.links, {});
  }
}
class x extends Error {
  constructor(e, n) {
    const r = n ? `At path '${n}': ${e}` : e;
    super(r), this.name = "QueryValidationError";
  }
}
const Ur = [
  "where",
  "order",
  "limit",
  "last",
  "first",
  "offset",
  "after",
  "before",
  "fields",
  "aggregate"
], oc = (t) => t.valueType || "unknown", Ds = (t, e, n = !1) => {
  if (n || t == null)
    return !0;
  switch (e) {
    case "string":
      return typeof t == "string";
    case "number":
      return typeof t == "number" && !isNaN(t);
    case "boolean":
      return typeof t == "boolean";
    case "date":
      return t instanceof Date || typeof t == "string" || typeof t == "number";
    default:
      return !0;
  }
}, ac = (t, e, n, r, s, i, o) => {
  const a = i.valueType === "json", c = (u, l, f) => {
    if (!Ds(f, l, a))
      throw new x(`Invalid value for operator '${u}' on attribute '${r}' in entity '${s}'. Expected ${l}, but received: ${typeof f}`, o);
  };
  switch (t) {
    case "in":
    case "$in":
      if (!Array.isArray(e))
        throw new x(`Operator '${t}' for attribute '${r}' in entity '${s}' must be an array, but received: ${typeof e}`, o);
      for (const u of e)
        c(t, n, u);
      break;
    case "$not":
    case "$ne":
    case "$gt":
    case "$lt":
    case "$gte":
    case "$lte":
      c(t, n, e);
      break;
    case "$like":
    case "$ilike":
      if (c(t, "string", e), t === "$ilike" && !i.isIndexed)
        throw new x(`Operator '${t}' can only be used with indexed attributes, but '${r}' in entity '${s}' is not indexed`, o);
      break;
    case "$isNull":
      c(t, "boolean", e);
      break;
    default:
      throw new x(`Unknown operator '${t}' for attribute '${r}' in entity '${s}'`, o);
  }
}, De = (t, e, n, r, s) => {
  const i = oc(n), o = n.valueType === "json";
  if (typeof t == "object" && t !== null && !Array.isArray(t)) {
    if (o)
      return;
    const c = t;
    for (const [u, l] of Object.entries(c))
      ac(u, l, i, e, r, n, `${s}.${u}`);
  } else if (!Ds(t, i, o))
    throw new x(`Invalid value for attribute '${e}' in entity '${r}'. Expected ${i}, but received: ${typeof t}`, s);
}, cc = (t, e, n, r, s) => {
  const i = t.split(".");
  if (i.length < 2)
    throw new x(`Invalid dot notation path '${t}'. Must contain at least one dot.`, s);
  let o = n;
  for (let l = 0; l < i.length - 1; l++) {
    const f = i[l], h = r.entities[o];
    if (!h)
      throw new x(`Entity '${o}' does not exist in schema while traversing dot notation path '${t}'.`, s);
    const y = h.links[f];
    if (!y) {
      const b = Object.keys(h.links);
      throw new x(`Link '${f}' does not exist on entity '${o}' in dot notation path '${t}'. Available links: ${b.length > 0 ? b.join(", ") : "none"}`, s);
    }
    o = y.entityName;
  }
  const a = i[i.length - 1], c = r.entities[o];
  if (!c)
    throw new x(`Target entity '${o}' does not exist in schema for dot notation path '${t}'.`, s);
  if (a === "id") {
    if (typeof e == "string" && !Le(e))
      throw new x(`Invalid value for id field in entity '${o}'. Expected a UUID, but received: ${e}`, s);
    De(e, t, new H("string", !1, !0), n, s);
    return;
  }
  const u = c.attrs[a];
  if (Object.keys(c.links).includes(a)) {
    if (typeof e == "string" && !Le(e))
      throw new x(`Invalid value for link '${a}' in entity '${o}'. Expected a UUID, but received: ${e}`, s);
    De(e, t, new H("string", !1, !0), n, s);
    return;
  }
  if (!u) {
    const l = Object.keys(c.attrs);
    throw new x(`Attribute '${a}' does not exist on entity '${o}' in dot notation path '${t}'. Available attributes: ${l.length > 0 ? l.join(", ") + ", id" : "id"}`, s);
  }
  De(e, t, u, n, s);
}, Us = (t, e, n, r) => {
  for (const [s, i] of Object.entries(t)) {
    if (s === "or" || s === "and") {
      if (Array.isArray(i))
        for (const u of i)
          typeof u == "object" && u !== null && Us(u, e, n, `${r}.${s}[${u}]`);
      continue;
    }
    if (s === "id") {
      De(i, "id", new H("string", !1, !0), e, `${r}.id`);
      continue;
    }
    if (s.includes(".")) {
      cc(s, i, e, n, `${r}.${s}`);
      continue;
    }
    const o = n.entities[e];
    if (!o)
      continue;
    const a = o.attrs[s], c = o.links[s];
    if (!a && !c) {
      const u = Object.keys(o.attrs), l = Object.keys(o.links);
      throw new x(`Attribute or link '${s}' does not exist on entity '${e}'. Available attributes: ${u.length > 0 ? u.join(", ") : "none"}. Available links: ${l.length > 0 ? l.join(", ") : "none"}`, `${r}.${s}`);
    }
    if (a)
      De(i, s, a, e, `${r}.${s}`);
    else if (c) {
      if (typeof i == "string" && !Le(i))
        throw new x(`Invalid value for link '${s}' in entity '${e}'. Expected a UUID, but received: ${i}`, `${r}.${s}`);
      const u = new H("string", !1, !0);
      De(i, s, u, e, `${r}.${s}`);
    }
  }
}, uc = (t, e, n, r, s = 0) => {
  for (const o of Object.keys(t))
    if (!Ur.includes(o))
      throw new x(`Invalid query parameter '${o}' in $ object. Valid parameters are: ${Ur.join(", ")}. Found: ${o}`, r);
  const i = [
    // 'limit', // only supported client side
    "offset",
    "before",
    "after",
    "first",
    "last"
  ];
  for (const o of i)
    if (t[o] !== void 0 && s > 0)
      throw new x(`'${o}' can only be used on top-level namespaces. It cannot be used in nested queries.`, r);
  if (t.where && n) {
    if (typeof t.where != "object" || t.where === null)
      throw new x(`'where' clause must be an object in entity '${e}', but received: ${typeof t.where}`, r ? `${r}.where` : void 0);
    Us(t.where, e, n, r ? `${r}.where` : "where");
  }
}, Ls = (t, e, n, r, s = 0) => {
  var i;
  if (!t || typeof t != "object")
    throw new x(`Query part for entity '${e}' must be an object, but received: ${typeof t}`, r);
  for (const o of Object.keys(t))
    if (o !== "$") {
      if (n && !(o in n.entities[e].links)) {
        const c = Object.keys(n.entities[e].links);
        throw new x(`Link '${o}' does not exist on entity '${e}'. Available links: ${c.length > 0 ? c.join(", ") : "none"}`, `${r}.${o}`);
      }
      const a = t[o];
      if (typeof a == "object" && a !== null) {
        const c = (i = n == null ? void 0 : n.entities[e].links[o]) == null ? void 0 : i.entityName;
        c && Ls(a, c, n, `${r}.${o}`, s + 1);
      }
    } else {
      const a = t[o];
      if (typeof a != "object" || a === null)
        throw new x(`Query parameter '$' must be an object in entity '${e}', but received: ${typeof a}`, `${r}.$`);
      uc(a, e, n, `${r}.$`, s);
    }
}, Lr = (t, e) => {
  if (typeof t != "object" || t === null)
    throw new x(`Query must be an object, but received: ${typeof t}${t === null ? " (null)" : ""}`);
  if (Array.isArray(t))
    throw new x(`Query must be an object, but received: ${typeof t}`);
  const n = t;
  for (const r of Object.keys(n)) {
    if (Array.isArray(t[r]))
      throw new x(`Query keys must be strings, but found key of type: ${typeof r}`, r);
    if (typeof r != "string")
      throw new x(`Query keys must be strings, but found key of type: ${typeof r}`, r);
    if (r !== "$$ruleParams") {
      if (e && !e.entities[r]) {
        const s = Object.keys(e.entities);
        throw new x(`Entity '${r}' does not exist in schema. Available entities: ${s.length > 0 ? s.join(", ") : "none"}`, r);
      }
      Ls(n[r], r, e, r, 0);
    }
  }
}, Fr = (t) => typeof t != "string" ? !1 : It(t) ? !0 : Le(t);
class se extends Error {
  constructor(e) {
    super(e), this.name = "TransactionValidationError";
  }
}
const Fs = (t) => t.length > 0 ? t.join(", ") : "none", lc = (t, e) => new se(`Entity '${t}' does not exist in schema. Available entities: ${Fs(e)}`), Ht = {
  string: (t) => typeof t == "string",
  number: (t) => typeof t == "number" && !isNaN(t),
  boolean: (t) => typeof t == "boolean",
  date: (t) => t instanceof Date || typeof t == "string" || typeof t == "number",
  json: () => !0
}, fc = (t, e) => {
  var n;
  return t == null ? !0 : ((n = Ht[e.valueType]) == null ? void 0 : n.call(Ht, t)) ?? !1;
}, Ns = (t, e) => {
  const n = e.entities[t];
  if (!n)
    throw lc(t, Object.keys(e.entities));
  return n;
}, Jt = (t, e, n) => {
  const r = Ns(t, n);
  if (typeof e != "object" || e === null)
    throw new se(`Arguments for data operation on entity '${t}' must be an object, but received: ${typeof e}`);
  for (const [s, i] of Object.entries(e)) {
    if (s === "id")
      continue;
    const o = r.attrs[s];
    if (o && !fc(i, o))
      throw new se(`Invalid value for attribute '${s}' in entity '${t}'. Expected ${o.valueType}, but received: ${typeof i}`);
  }
}, Nr = (t, e, n) => {
  const r = Ns(t, n);
  if (typeof e != "object" || e === null)
    throw new se(`Arguments for link operation on entity '${t}' must be an object, but received: ${typeof e}`);
  for (const [s, i] of Object.entries(e)) {
    if (!r.links[s]) {
      const a = Object.keys(r.links);
      throw new se(`Link '${s}' does not exist on entity '${t}'. Available links: ${Fs(a)}`);
    }
    if (i != null) {
      if (Array.isArray(i)) {
        for (const a of i)
          if (!Fr(a))
            throw new se(`Invalid entity ID in link '${s}' for entity '${t}'. Expected a UUID or a lookup, but received: ${a}`);
      } else if (!Fr(i))
        throw new se(`Invalid UUID in link '${s}' for entity '${t}'. Expected a UUID, but received: ${i}`);
    }
  }
}, dc = {
  create: Jt,
  update: Jt,
  merge: Jt,
  link: Nr,
  unlink: Nr,
  delete: () => {
  }
}, hc = (t, e) => {
  if (!e)
    return;
  const [n, r, s, i] = t;
  if (!Array.isArray(s) && !Le(s))
    throw new se(`Invalid id for entity '${r}'. Expected a UUID, but received: ${s}`);
  if (typeof r != "string")
    throw new se(`Entity name must be a string, but received: ${typeof r}`);
  const o = dc[n];
  o && i !== void 0 && o(r, i, e);
}, pc = (t, e) => {
  const n = Array.isArray(t) ? t : [t];
  for (const r of n) {
    if (!r || typeof r != "object")
      throw new se(`Transaction chunk must be an object, but received: ${typeof r}`);
    if (!Array.isArray(r.__ops))
      throw new se(`Transaction chunk must have __ops array, but received: ${typeof r.__ops}`);
    for (const s of r.__ops) {
      if (!Array.isArray(s))
        throw new se(`Transaction operation must be an array, but received: ${typeof s}`);
      hc(s, e);
    }
  }
};
let Ks = 0;
class Kr {
  constructor(e) {
    p(this, "type", "ws");
    p(this, "conn");
    p(this, "id");
    p(this, "onopen");
    p(this, "onmessage");
    p(this, "onclose");
    p(this, "onerror");
    this.id = `${this.type}_${Ks++}`, this.conn = new WebSocket(e), this.conn.onopen = (n) => {
      this.onopen && this.onopen({ target: this });
    }, this.conn.onmessage = (n) => {
      this.onmessage && this.onmessage({
        target: this,
        message: JSON.parse(n.data.toString())
      });
    }, this.conn.onclose = (n) => {
      this.onclose && this.onclose({ target: this });
    }, this.conn.onerror = (n) => {
      this.onerror && this.onerror({ target: this });
    };
  }
  close() {
    this.conn.close();
  }
  isOpen() {
    return this.conn.readyState === (WebSocket.OPEN ?? 1);
  }
  isConnecting() {
    return this.conn.readyState === (WebSocket.CONNECTING ?? 0);
  }
  send(e) {
    return this.conn.send(JSON.stringify(e));
  }
}
class yc {
  constructor(e, n) {
    p(this, "type", "sse");
    p(this, "initParams", null);
    p(this, "sendQueue", []);
    p(this, "sendPromise");
    p(this, "closeFired", !1);
    p(this, "sseInitTimeout");
    p(this, "ES");
    p(this, "conn");
    p(this, "url");
    p(this, "id");
    p(this, "onopen");
    p(this, "onmessage");
    p(this, "onclose");
    p(this, "onerror");
    this.id = `${this.type}_${Ks++}`, this.url = n, this.ES = e, this.conn = new e(n), this.sseInitTimeout = setTimeout(() => {
      this.initParams || this.handleError();
    }, 1e4), this.conn.onmessage = (r) => {
      const s = JSON.parse(r.data);
      if (Array.isArray(s))
        for (const i of s)
          this.handleMessage(i);
      else
        this.handleMessage(s);
    }, this.conn.onerror = (r) => {
      this.handleError();
    };
  }
  handleMessage(e) {
    if (e.op === "sse-init") {
      this.initParams = {
        machineId: e["machine-id"],
        sessionId: e["session-id"],
        sseToken: e["sse-token"]
      }, this.onopen && this.onopen({ target: this }), clearTimeout(this.sseInitTimeout);
      return;
    }
    this.onmessage && this.onmessage({
      target: this,
      message: e
    });
  }
  // Runs the onerror and closes the connection
  handleError() {
    try {
      this.onerror && this.onerror({ target: this });
    } finally {
      this.handleClose();
    }
  }
  handleClose() {
    this.conn.close(), this.onclose && !this.closeFired && (this.closeFired = !0, this.onclose({ target: this }));
  }
  async postMessages(e) {
    var n, r, s;
    try {
      (await fetch(this.url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          machine_id: (n = this.initParams) == null ? void 0 : n.machineId,
          session_id: (r = this.initParams) == null ? void 0 : r.sessionId,
          sse_token: (s = this.initParams) == null ? void 0 : s.sseToken,
          messages: e
        })
      })).ok || this.handleError();
    } catch {
      this.handleError();
    }
  }
  async flushQueue() {
    if (this.sendPromise || !this.sendQueue.length)
      return;
    const e = this.sendQueue;
    this.sendQueue = [];
    const n = this.postMessages(e);
    this.sendPromise = n, n.then(() => {
      this.sendPromise = null, this.flushQueue();
    });
  }
  send(e) {
    if (!this.isOpen() || !this.initParams)
      throw this.isConnecting() ? new Error("Failed to execute 'send' on 'EventSource': Still in CONNECTING state.") : this.conn.readyState === this.ES.CLOSED ? new Error("EventSource is already in CLOSING or CLOSED state.") : new Error("EventSource is in invalid state.");
    this.sendQueue.push(e), this.flushQueue();
  }
  isOpen() {
    return this.conn.readyState === this.ES.OPEN && this.initParams !== null;
  }
  isConnecting() {
    return this.conn.readyState === this.ES.CONNECTING || this.conn.readyState === this.ES.OPEN && this.initParams === null;
  }
  close() {
    this.handleClose();
  }
}
function bc(t, e) {
  const n = t.values;
  if (n) {
    const r = bs(n.attrsStore, null);
    if (r) {
      for (const s of n.entities || [])
        s.store.useDateObjects = e, s.store = ys(r, s.store);
      n.attrsStore = r;
    }
  }
  return t;
}
function gc(t, e) {
  var n;
  if (e.values) {
    const r = [];
    for (const s of (n = e.values) == null ? void 0 : n.entities) {
      const i = ps(s.store);
      r.push({ ...s, store: i });
    }
    return {
      ...e,
      values: { attrsStore: e.values.attrsStore.toJSON(), entities: r }
    };
  } else
    return e;
}
function _c(t, e, n) {
  var i, o;
  const r = (i = e == null ? void 0 : e.state) == null ? void 0 : i.txId, s = (o = n == null ? void 0 : n.state) == null ? void 0 : o.txId;
  return r && (!s || r > s) ? e : s && (!r || s > r) ? n : e || n;
}
function Yt(t, e, n) {
  return Cs({ store: e, attrsStore: n, pageInfo: null, aggregate: null }, t.query).data[t.table][0];
}
function qr(t, e, n, r) {
  var o;
  const s = (o = N(n, t.table, "id")) == null ? void 0 : o.id;
  if (!s)
    return -1;
  const i = Ke(e.eav, [r, s, r]);
  return i ? i[3] : -1;
}
function Wr(t, e, n) {
  for (const { action: r, triple: s } of n)
    switch (r) {
      case "added":
        ws(t, e, s);
        break;
      case "removed":
        gs(t, e, s);
        break;
    }
}
function wc(t, e, n) {
  var s, i;
  const r = {};
  for (const { action: o, triple: a } of n) {
    const [c, u, l] = a, f = (i = (s = e.getAttr(u)) == null ? void 0 : s["forward-identity"]) == null ? void 0 : i[2];
    if (!f)
      continue;
    const h = r[c] ?? {};
    r[c] = h;
    const y = h[f] ?? {};
    switch (o) {
      case "added":
        y.newValue = l;
        break;
      case "removed":
        y.oldValue === void 0 && (y.oldValue = l);
        break;
    }
    h[f] = y;
  }
  for (const [o, a] of Object.entries(r))
    for (const [c, { oldValue: u, newValue: l }] of Object.entries(a))
      u === l && delete a[c];
  return r;
}
function bt(t, e) {
  return { [t.table]: e.map((n) => n.entity) };
}
function Tc(t, e) {
  var r;
  if (t.orderFieldType)
    return t.orderFieldType;
  const n = t.orderField === "serverCreatedAt" ? "number" : (r = N(e(), t.table, t.orderField)) == null ? void 0 : r["checked-data-type"];
  return t.orderFieldType = n, n;
}
function mc(t, e, n) {
  const r = e;
  if (t.orderField === "serverCreatedAt") {
    n.sort(t.orderDirection === "asc" ? function(o, a) {
      return Ye(o.entity.id, o.serverCreatedAt, a.entity.id, a.serverCreatedAt, r);
    } : function(o, a) {
      return Ye(a.entity.id, a.serverCreatedAt, o.entity.id, o.serverCreatedAt, r);
    });
    return;
  }
  const s = t.orderField;
  n.sort(t.orderDirection === "asc" ? function(o, a) {
    return Ye(o.entity.id, o.entity[s], a.entity.id, a.entity[s], r);
  } : function(o, a) {
    return Ye(a.entity.id, a.entity[s], o.entity.id, o.entity[s], r);
  });
}
var Te;
(function(t) {
  t.InitialSyncBatch = "InitialSyncBatch", t.InitialSyncComplete = "InitialSyncComplete", t.LoadFromStorage = "LoadFromStorage", t.SyncTransaction = "SyncTransaction", t.Error = "Error";
})(Te || (Te = {}));
class Sc {
  constructor(e, n, r, s, i, o) {
    p(this, "trySend");
    p(this, "subs");
    // Using any for the SyncCallback because we'd need Reactor to be typed
    p(this, "callbacks", {});
    p(this, "config");
    p(this, "idToHash", {});
    p(this, "log");
    p(this, "createStore");
    p(this, "getAttrs");
    this.trySend = e, this.config = r, this.log = s, this.createStore = i, this.getAttrs = o, this.subs = new _n({
      persister: n,
      merge: _c,
      serialize: gc,
      parse: (a, c) => bc(c, this.config.useDateObjects),
      objectSize: (a) => {
        var c;
        return ((c = a.values) == null ? void 0 : c.entities.length) || 0;
      },
      logger: s,
      gc: {
        maxAgeMs: 1e3 * 60 * 60 * 24 * 7 * 52,
        // 1 year
        maxEntries: 1e3,
        // Size of each sub is the number of entity
        maxSize: 1e6
        // 1 million entities
      }
    });
  }
  beforeUnload() {
    this.subs.flush();
  }
  subscribe(e, n) {
    const r = q(e);
    return this.callbacks[r] = this.callbacks[r] || [], this.callbacks[r].push(n), this.initSubscription(e, r, n), (s) => {
      this.unsubscribe(r, n, s == null ? void 0 : s.keepSubscription);
    };
  }
  unsubscribe(e, n, r) {
    const s = (this.callbacks[e] || []).filter((i) => i !== n);
    if (this.callbacks[e] = s, !s.length) {
      delete this.callbacks[e];
      const i = this.subs.currentValue[e];
      i != null && i.state && this.clearSubscriptionData(i.state.subscriptionId, !!r), r || this.subs.updateInPlace((o) => {
        delete o[e];
      });
    }
  }
  sendStart(e) {
    this.trySend(W(), {
      op: "start-sync",
      q: e
    });
  }
  sendResync(e, n, r) {
    this.idToHash[n.subscriptionId] = e.hash, this.trySend(n.subscriptionId, {
      op: "resync-table",
      "subscription-id": n.subscriptionId,
      "tx-id": r,
      token: n.token
    });
  }
  sendRemove(e, n) {
    this.trySend(W(), {
      op: "remove-sync",
      "subscription-id": e.subscriptionId,
      "keep-subscription": n
    });
  }
  async initSubscription(e, n, r) {
    var u, l, f, h;
    await this.subs.waitForKeyToLoad(n);
    const s = this.subs.currentValue[n];
    if (s && s.state && s.state.txId) {
      this.sendResync(s, s.state, s.state.txId), (u = s.values) != null && u.entities && r && r({
        type: Te.LoadFromStorage,
        data: bt(s, (l = s.values) == null ? void 0 : l.entities)
      });
      return;
    }
    const i = Object.keys(e)[0], o = ((h = (f = e[i]) == null ? void 0 : f.$) == null ? void 0 : h.order) || { serverCreatedAt: "asc" }, [a, c] = Object.entries(o)[0];
    this.subs.updateInPlace((y) => {
      y[n] = {
        query: e,
        hash: n,
        table: i,
        orderDirection: c,
        orderField: a,
        createdAt: Date.now(),
        updatedAt: Date.now()
      };
    }), this.sendStart(e);
  }
  async flushPending() {
    for (const e of Object.keys(this.callbacks)) {
      await this.subs.waitForKeyToLoad(e);
      const n = this.subs.currentValue[e];
      n ? await this.initSubscription(n.query, n.hash) : this.log.error("Missing sub for hash in flushPending", e);
    }
  }
  onStartSyncOk(e) {
    const n = e["subscription-id"], r = e.q, s = q(r);
    this.idToHash[n] = s, this.subs.updateInPlace((i) => {
      const o = i[s];
      if (!o)
        return this.log.error("Missing sub for hash", s, "subscription-id", n, "query", r), i;
      o.state = {
        subscriptionId: n,
        token: e.token
      };
    });
  }
  notifyCbs(e, n) {
    for (const r of this.callbacks[e] || [])
      r(n);
  }
  onSyncLoadBatch(e) {
    const n = e["subscription-id"], r = e["join-rows"], s = this.idToHash[n];
    if (!s) {
      this.log.error("Missing hash for subscription", e);
      return;
    }
    const i = [], o = this.subs.currentValue[s];
    if (!o) {
      this.log.error("Missing sub for hash", s, e);
      return;
    }
    const a = o.values ?? {
      entities: [],
      attrsStore: this.getAttrs()
    };
    o.values = a;
    const c = a.entities;
    for (const u of r) {
      const l = this.createStore(u), f = Yt(o, l, a.attrsStore);
      c.push({
        store: l,
        entity: f,
        serverCreatedAt: qr(o, l, a.attrsStore, f.id)
      }), i.push(f);
    }
    this.subs.updateInPlace((u) => {
      u[s] = o, u[s].updatedAt = Date.now();
    }), o.values && this.notifyCbs(s, {
      type: Te.InitialSyncBatch,
      data: bt(o, o.values.entities),
      batch: i
    });
  }
  onSyncInitFinish(e) {
    var i;
    const n = e["subscription-id"], r = this.idToHash[n];
    if (!r) {
      this.log.error("Missing hash for subscription", e);
      return;
    }
    this.subs.updateInPlace((o) => {
      const a = o[r];
      if (!a) {
        this.log.error("Missing sub for hash", r, e);
        return;
      }
      const c = a.state;
      if (!c)
        return this.log.error("Sub never set init, missing result", a, e), o;
      c.txId = e["tx-id"], a.updatedAt = Date.now();
    });
    const s = this.subs.currentValue[r];
    s && this.notifyCbs(r, {
      type: Te.InitialSyncComplete,
      data: bt(s, ((i = s.values) == null ? void 0 : i.entities) || [])
    });
  }
  onSyncUpdateTriples(e) {
    var o;
    const n = e["subscription-id"], r = this.idToHash[n];
    if (!r) {
      this.log.error("Missing hash for subscription", e);
      return;
    }
    const s = this.subs.currentValue[r];
    if (!s) {
      this.log.error("Missing sub for hash", r, e);
      return;
    }
    const i = s.state;
    if (!i) {
      this.log.error("Missing state for sub", s, e);
      return;
    }
    for (const a of e.txes) {
      if (i.txId && i.txId >= a["tx-id"])
        continue;
      i.txId = a["tx-id"];
      const c = [], u = {};
      for (const w of a.changes) {
        const m = u[w.triple[0]] ?? [];
        u[w.triple[0]] = m, m.push(w);
      }
      const l = s.values ?? {
        entities: [],
        attrsStore: this.getAttrs()
      }, f = l.entities;
      s.values = l;
      const h = [];
      e: for (const [w, m] of Object.entries(u))
        for (let _ = 0; _ < f.length; _++) {
          const S = f[_];
          if (eo(S.store, w)) {
            Wr(S.store, l.attrsStore, m);
            const O = Yt(s, S.store, l.attrsStore), E = wc(S.store, l.attrsStore, m)[w];
            O ? (h.push({
              oldEntity: S.entity,
              newEntity: O,
              changedFields: E || {}
            }), S.entity = O) : c.push(_), delete u[w];
            continue e;
          }
        }
      const y = [];
      for (const [w, m] of Object.entries(u)) {
        const _ = this.createStore([]);
        Wr(_, l.attrsStore, m);
        const S = Yt(s, _, l.attrsStore);
        if (!S) {
          this.log.error("No entity found after applying change", {
            sub: s,
            changes: m,
            store: _
          });
          continue;
        }
        f.push({
          store: _,
          entity: S,
          serverCreatedAt: qr(s, _, l.attrsStore, S.id)
        }), y.push(S);
      }
      const b = [];
      for (const w of c.sort().reverse())
        b.push(f[w].entity), f.splice(w, 1);
      const g = Tc(s, this.getAttrs);
      mc(s, g, f), this.notifyCbs(r, {
        type: Te.SyncTransaction,
        data: bt(s, (o = s.values) == null ? void 0 : o.entities),
        added: y,
        removed: b,
        updated: h
      });
    }
    this.subs.updateInPlace((a) => {
      a[r] = s, a[r].updatedAt = Date.now();
    });
  }
  clearSubscriptionData(e, n) {
    const r = this.idToHash[e];
    if (r) {
      delete this.idToHash[e];
      const s = this.subs.currentValue[r];
      if (s.state && this.sendRemove(s.state, n), n ? this.subs.unloadKey(r) : this.subs.updateInPlace((i) => {
        delete i[r];
      }), s)
        return s;
    }
  }
  onStartSyncError(e) {
    const n = q(e["original-event"].q), r = {
      message: e.message || "Uh-oh, something went wrong. Ping Joe & Stopa.",
      status: e.status,
      type: e.type,
      hint: e.hint
    }, s = Object.keys(e["original-event"].q)[0];
    this.notifyCbs(n, {
      type: Te.Error,
      data: { [s]: [] },
      error: r
    });
  }
  onResyncError(e) {
    const n = e["original-event"]["subscription-id"], r = this.clearSubscriptionData(n, !1);
    r && this.initSubscription(r.query, r.hash);
  }
}
const de = {
  CONNECTING: "connecting",
  OPENED: "opened",
  AUTHENTICATED: "authenticated",
  CLOSED: "closed",
  ERRORED: "errored"
}, vc = 3e4, Ec = 3e4, Oc = 200, Ac = 1e3 * 60, kc = {
  apiURI: "https://api.instantdb.com",
  websocketURI: "wss://api.instantdb.com/runtime/session"
}, Zt = "_instant_oauth_redirect", Ve = "currentUser";
function Cc({ transportType: t, appId: e, apiURI: n, wsURI: r, EventSourceImpl: s }) {
  if (!s)
    return new Kr(`${r}?app_id=${e}`);
  switch (t) {
    case "ws":
      return new Kr(`${r}?app_id=${e}`);
    case "sse":
      return new yc(s, `${n}/runtime/sse?app_id=${e}`);
    default:
      throw new Error("Unknown transport type " + t);
  }
}
function Pc() {
  return typeof window < "u" || typeof chrome < "u";
}
const zr = {
  "set-presence": !0,
  "set-presence-ok": !0,
  "refresh-presence": !0,
  "patch-presence": !0
};
function Ic(t, e) {
  var r;
  const n = typeof t == "string" ? JSON.parse(t) : t;
  if ((r = n == null ? void 0 : n.result) != null && r.store) {
    const s = bs(n.result.attrsStore, n.result.store);
    if (s) {
      const i = n.result.store;
      n.result.store = ys(s, {
        ...i,
        useDateObjects: e
      }), n.result.attrsStore = s;
    }
  }
  return n;
}
function Mc(t, e) {
  const { result: n, ...r } = e, s = (
    /** @type {import('./reactorTypes.ts').QuerySubInStorage} */
    r
  );
  if (n) {
    const i = {
      ...n,
      store: ps(n.store),
      attrsStore: n.attrsStore.toJSON()
    };
    s.result = i;
  }
  return s;
}
function jc(t, e) {
  switch (t) {
    case "pendingMutations":
      return new Map(typeof e == "string" ? JSON.parse(e) : e);
    default:
      return e;
  }
}
function Rc(t, e) {
  switch (t) {
    case "pendingMutations":
      return [...e.entries()];
    default:
      return e;
  }
}
function xc(t, e, n) {
  const r = e == null ? void 0 : e.result, s = n == null ? void 0 : n.result;
  return r && !s && n && (n.result = r), n || e;
}
function Xt(t) {
  return [...t].sort((e, n) => {
    const [r, s] = e, [i, o] = n, a = s.order || 0, c = o.order || 0;
    return a == c ? r < i ? -1 : r > i ? 1 : 0 : a - c;
  });
}
class $c {
  constructor(e, n = Ms, r = js, s, i) {
    /** @type {s.AttrsStore | undefined} */
    p(this, "attrs");
    p(this, "_isOnline", !0);
    p(this, "_isShutdown", !1);
    p(this, "status", de.CONNECTING);
    /** @type {PersistedObject<string, QuerySub, QuerySubInStorage>} */
    p(this, "querySubs");
    /** @type {PersistedObject} */
    p(this, "kv");
    /** @type {SyncTable} */
    p(this, "_syncTable");
    /** @type {Record<string, Array<{ q: any, cb: (data: any) => any }>>} */
    p(this, "queryCbs", {});
    /** @type {Record<string, Array<{ q: any, eventId: string, dfd: Deferred }>>} */
    p(this, "queryOnceDfds", {});
    p(this, "authCbs", []);
    p(this, "attrsCbs", []);
    p(this, "mutationErrorCbs", []);
    p(this, "connectionStatusCbs", []);
    p(this, "config");
    p(this, "mutationDeferredStore", /* @__PURE__ */ new Map());
    p(this, "_reconnectTimeoutId", null);
    p(this, "_reconnectTimeoutMs", 0);
    /** @type {Connection} */
    p(this, "_transport");
    /** @type {TransportType} */
    p(this, "_transportType", "ws");
    /** @type {EventSourceConstructor} */
    p(this, "_EventSource");
    /** @type {boolean | null} */
    p(this, "_wsOk", null);
    p(this, "_localIdPromises", {});
    p(this, "_errorMessage", null);
    /** @type {Promise<null | {error: {message: string}}> | null}**/
    p(this, "_oauthCallbackResponse", null);
    /** @type {null | import('./utils/linkIndex.ts').LinkIndex}} */
    p(this, "_linkIndex", null);
    /** @type BroadcastChannel | undefined */
    p(this, "_broadcastChannel");
    /** @type {Record<string, {isConnected: boolean; error: any}>} */
    p(this, "_rooms", {});
    /** @type {Record<string, boolean>} */
    p(this, "_roomsPendingLeave", {});
    p(this, "_presence", {});
    p(this, "_broadcastQueue", []);
    p(this, "_broadcastSubs", {});
    /** @type {{isLoading: boolean; error: any | undefined, user: any | undefined}} */
    p(this, "_currentUserCached", { isLoading: !0, error: void 0, user: void 0 });
    p(this, "_beforeUnloadCbs", []);
    p(this, "_dataForQueryCache", {});
    /** @type {Logger} */
    p(this, "_log");
    p(this, "_pendingTxCleanupTimeout");
    p(this, "_pendingMutationCleanupThreshold");
    p(this, "_inFlightMutationEventIds", /* @__PURE__ */ new Set());
    p(this, "_onMergeKv", (e, n, r) => {
      switch (e) {
        case "pendingMutations": {
          const s = (n == null ? void 0 : n.entries()) ?? [], i = (r == null ? void 0 : r.entries()) ?? [], o = new Map([...s, ...i]);
          return (n ? this._rewriteMutationsSorted(this.attrs, n) : []).forEach(([c, u]) => {
            var l;
            !((l = r == null ? void 0 : r.pendingMutations) != null && l.has(c)) && !u["tx-id"] && this._sendMutation(c, u);
          }), o;
        }
        default:
          return r || n;
      }
    });
    // ---------------------------
    // Queries
    p(this, "getPreviousResult", (e) => {
      var r;
      const n = q(e);
      return (r = this.dataForQuery(n)) == null ? void 0 : r.data;
    });
    /** Re-run instaql and call all callbacks with new data */
    p(this, "notifyOne", (e) => {
      var i;
      const n = this.queryCbs[e] ?? [], r = (i = this._dataForQueryCache[e]) == null ? void 0 : i.data, s = this.dataForQuery(e);
      s != null && s.data && (this._dataForQueryCache[e] = s, !mt(s.data, r) && n.forEach((o) => o.cb(s.data)));
    });
    p(this, "notifyOneQueryOnce", (e) => {
      var s;
      const n = this.queryOnceDfds[e] ?? [], r = (s = this.dataForQuery(e)) == null ? void 0 : s.data;
      n.forEach((i) => {
        this._completeQueryOnce(i.q, e, i.dfd), i.dfd.resolve(r);
      });
    });
    p(this, "notifyQueryError", (e, n) => {
      (this.queryCbs[e] || []).forEach((s) => s.cb({ error: n }));
    });
    /** Applies transactions locally and sends transact message to server */
    p(this, "pushTx", (e) => {
      this.config.disableValidation || pc(e, this.config.schema);
      try {
        const n = La({
          attrsStore: this.optimisticAttrs(),
          schema: this.config.schema,
          stores: Object.values(this.querySubs.currentValue).map((r) => {
            var s;
            return (s = r == null ? void 0 : r.result) == null ? void 0 : s.store;
          }),
          useDateObjects: this.config.useDateObjects
        }, e);
        return this.pushOps(n);
      } catch (n) {
        return this.pushOps([], n);
      }
    });
    /**
     * @param {*} txSteps
     * @param {*} [error]
     * @returns
     */
    p(this, "pushOps", (e, n) => {
      const r = W(), s = [...this._pendingMutations().values()], i = Math.max(0, ...s.map((c) => c.order || 0)) + 1, o = {
        op: "transact",
        "tx-steps": e,
        created: Date.now(),
        error: n,
        order: i
      };
      this._updatePendingMutations((c) => {
        c.set(r, o);
      });
      const a = new xr();
      return this.mutationDeferredStore.set(r, a), this._sendMutation(r, o), this.notifyAll(), a.promise;
    });
    p(this, "_transportOnOpen", (e) => {
      const n = e.target;
      if (this._transport !== n) {
        this._log.info("[socket][open]", n.id, "skip; this is no longer the current transport");
        return;
      }
      this._log.info("[socket][open]", this._transport.id), this._setStatus(de.OPENED), this.getCurrentUser().then((r) => {
        var s;
        this._trySend(W(), {
          op: "init",
          "app-id": this.config.appId,
          "refresh-token": (s = r.user) == null ? void 0 : s.refresh_token,
          versions: this.versions,
          // If an admin token is provided for an app, we will
          // skip all permission checks. This is an advanced feature,
          // to let users write internal tools
          // This option is not exposed in `Config`, as it's
          // not ready for prime time
          "__admin-token": this.config.__adminToken
        });
      }).catch((r) => {
        this._log.error("[socket][error]", n.id, r);
      });
    });
    p(this, "_transportOnMessage", (e) => {
      const n = e.target, r = e.message;
      if (this._transport !== n) {
        this._log.info("[socket][message]", n.id, r, "skip; this is no longer the current transport");
        return;
      }
      if (!this._wsOk && n.type === "ws" && (this._wsOk = !0), this._transportType = "ws", Array.isArray(e.message))
        for (const s of e.message)
          this._handleReceive(n.id, s);
      else
        this._handleReceive(n.id, e.message);
    });
    p(this, "_transportOnError", (e) => {
      const n = e.target;
      if (this._transport !== n) {
        this._log.info("[socket][error]", n.id, "skip; this is no longer the current transport");
        return;
      }
      this._log.error("[socket][error]", n.id, e);
    });
    p(this, "_scheduleReconnect", () => {
      !this._wsOk && this._transportType !== "sse" && (this._transportType = "sse", this._reconnectTimeoutMs = 0), setTimeout(() => {
        if (this._reconnectTimeoutMs = Math.min(this._reconnectTimeoutMs + 1e3, 1e4), !this._isOnline) {
          this._log.info("[socket][close]", this._transport.id, "we are offline, no need to start socket");
          return;
        }
        this._startSocket();
      }, this._reconnectTimeoutMs);
    });
    p(this, "_transportOnClose", (e) => {
      const n = e.target;
      if (this._transport !== n) {
        this._log.info("[socket][close]", n.id, "skip; this is no longer the current transport");
        return;
      }
      this._setStatus(de.CLOSED);
      for (const r of Object.values(this._rooms))
        r.isConnected = !1;
      if (this._isShutdown) {
        this._log.info("[socket][close]", n.id, "Reactor has been shut down and will not reconnect");
        return;
      }
      this._log.info("[socket][close]", n.id, "schedule reconnect, ms =", this._reconnectTimeoutMs), this._scheduleReconnect();
    });
    if (this._EventSource = i, this.config = { ...kc, ...e }, this.queryCacheLimit = this.config.queryCacheLimit ?? 10, this._pendingTxCleanupTimeout = this.config.pendingTxCleanupTimeout ?? Ec, this._pendingMutationCleanupThreshold = this.config.pendingMutationCleanupThreshold ?? Oc, this._log = ic(e.verbose || qn || Rs, () => this._reactorStats()), this.versions = { ...s || {}, "@instantdb/core": Wn }, this.config.schema && (this._linkIndex = Dr(this.config.schema)), !!Pc()) {
      if (!e.appId)
        throw new Error("Instant must be initialized with an appId.");
      if (!Le(e.appId))
        throw new Error(`Instant must be initialized with a valid appId. \`${e.appId}\` is not a valid uuid.`);
      typeof BroadcastChannel == "function" && (this._broadcastChannel = new BroadcastChannel("@instantdb"), this._broadcastChannel.addEventListener("message", async (o) => {
        var a;
        try {
          if (((a = o.data) == null ? void 0 : a.type) === "auth") {
            const c = await this.getCurrentUser();
            this.updateUser(c.user);
          }
        } catch (c) {
          this._log.error("[error] handle broadcast channel", c);
        }
      })), this._initStorage(n), this._syncTable = new Sc(this._trySendAuthed.bind(this), new n(this.config.appId, "syncSubs"), {
        useDateObjects: this.config.useDateObjects
      }, this._log, (o) => Je(this.ensureAttrs(), o, this.config.enableCardinalityInference, this.config.useDateObjects), () => this.ensureAttrs()), this._oauthCallbackResponse = this._oauthLoginInit(), this.getCurrentUser().then((o) => {
        this.syncUserToEndpoint(o.user);
      }), setInterval(async () => {
        const o = await this.getCurrentUser();
        this.syncUserToEndpoint(o.user);
      }, Ac), r.getIsOnline().then((o) => {
        this._isOnline = o, this._startSocket(), r.listen((a) => {
          a !== this._isOnline && (this._log.info("[network] online =", a), this._isOnline = a, this._isOnline ? this._startSocket() : (this._log.info("Changing status from", this.status, "to", de.CLOSED), this._setStatus(de.CLOSED)));
        });
      }), typeof addEventListener < "u" && (this._beforeUnload = this._beforeUnload.bind(this), addEventListener("beforeunload", this._beforeUnload));
    }
  }
  ensureAttrs() {
    if (!this.attrs)
      throw new Error("attrs have not loaded.");
    return this.attrs;
  }
  updateSchema(e) {
    this.config = {
      ...this.config,
      schema: e,
      cardinalityInference: !!e
    }, this._linkIndex = e ? Dr(this.config.schema) : null;
  }
  _reactorStats() {
    return {
      inFlightMutationCount: this._inFlightMutationEventIds.size,
      storedMutationCount: this._pendingMutations().size,
      transportType: this._transportType
    };
  }
  _onQuerySubLoaded(e) {
    this.kv.waitForKeyToLoad("pendingMutations").then(() => this.notifyOne(e));
  }
  _initStorage(e) {
    this.querySubs = new _n({
      persister: new e(this.config.appId, "querySubs"),
      merge: xc,
      serialize: Mc,
      parse: (n, r) => Ic(r, this.config.useDateObjects),
      // objectSize
      objectSize: (n) => {
        var r, s, i;
        return ((i = (s = (r = n == null ? void 0 : n.result) == null ? void 0 : r.store) == null ? void 0 : s.triples) == null ? void 0 : i.length) ?? 0;
      },
      logger: this._log,
      preloadEntryCount: 10,
      gc: {
        maxAgeMs: 1e3 * 60 * 60 * 24 * 7 * 52,
        // 1 year
        maxEntries: 1e3,
        // Size of each query is the number of triples
        maxSize: 1e6
        // 1 million triples
      }
    }), this.querySubs.onKeyLoaded = (n) => this._onQuerySubLoaded(n), this.kv = new _n({
      persister: new e(this.config.appId, "kv"),
      merge: this._onMergeKv,
      serialize: Rc,
      parse: jc,
      objectSize: () => 0,
      logger: this._log,
      saveThrottleMs: 100,
      idleCallbackMaxWaitMs: 100,
      // Don't GC the kv store
      gc: null
    }), this.kv.onKeyLoaded = (n) => {
      n === "pendingMutations" && this.notifyAll();
    }, this.kv.waitForKeyToLoad("pendingMutations"), this.kv.waitForKeyToLoad(Ve), this._beforeUnloadCbs.push(() => {
      this.kv.flush(), this.querySubs.flush();
    });
  }
  _beforeUnload() {
    for (const e of this._beforeUnloadCbs)
      e();
    this._syncTable.beforeUnload();
  }
  /**
   * @param {'enqueued' | 'pending' | 'synced' | 'timeout' |  'error' } status
   * @param {string} eventId
   * @param {{message?: string, type?: string, status?: number, hint?: unknown}} [errorMsg]
   */
  _finishTransaction(e, n, r) {
    const s = this.mutationDeferredStore.get(n);
    this.mutationDeferredStore.delete(n);
    const i = e !== "error" && e !== "timeout";
    if (!s && !i && console.error("Mutation failed", { status: e, eventId: n, ...r }), !!s)
      if (i)
        s.resolve({ status: e, eventId: n });
      else if (r != null && r.type) {
        const { status: o, ...a } = r;
        s.reject(new xt({
          // @ts-expect-error body.type is not constant typed
          body: a,
          status: o ?? 0
        }));
      } else
        s.reject(new Ne((r == null ? void 0 : r.message) || "Unknown error", r == null ? void 0 : r.hint));
  }
  _setStatus(e, n) {
    this.status = e, this._errorMessage = n, this.notifyConnectionStatusSubs(e);
  }
  _flushEnqueuedRoomData(e) {
    var s, i;
    const n = (i = (s = this._presence[e]) == null ? void 0 : s.result) == null ? void 0 : i.user, r = this._broadcastQueue[e];
    if (this._broadcastQueue[e] = [], n && this._trySetPresence(e, n), r)
      for (const o of r) {
        const { topic: a, roomType: c, data: u } = o;
        this._tryBroadcast(e, c, a, u);
      }
  }
  /**
   * Does the same thing as add-query-ok
   * but called as a result of receiving query info from ssr
   * @param {any} q
   * @param {{ triples: any; pageInfo: any; }} result
   * @param {boolean} enableCardinalityInference
   */
  _addQueryData(e, n, r) {
    if (!this.attrs)
      throw new Error("Attrs in reactor have not been set");
    const s = q(e), i = this.ensureAttrs(), o = Je(this.attrs, n.triples, r, this.config.useDateObjects);
    this.querySubs.updateInPlace((a) => {
      a[s] = {
        result: {
          store: o,
          attrsStore: i,
          pageInfo: n.pageInfo,
          processedTxId: void 0,
          isExternal: !0
        },
        q: e
      };
    }), this._cleanupPendingMutationsQueries(), this.notifyOne(s), this.notifyOneQueryOnce(s), this._cleanupPendingMutationsTimeout();
  }
  _handleReceive(e, n) {
    var s, i, o, a, c, u;
    const r = !!this.config.schema && ("cardinalityInference" in this.config ? !!this.config.cardinalityInference : !0);
    switch (zr[n.op] || this._log.info("[receive]", e, n.op, n), n.op) {
      case "init-ok": {
        this._setStatus(de.AUTHENTICATED), this._reconnectTimeoutMs = 0, this._setAttrs(n.attrs), this._flushPendingMessages(), this._sessionId = n["session-id"];
        for (const h of Object.keys(this._rooms)) {
          const y = (i = (s = this._presence[h]) == null ? void 0 : s.result) == null ? void 0 : i.user;
          this._tryJoinRoom(h, y);
        }
        break;
      }
      case "add-query-exists": {
        this.notifyOneQueryOnce(q(n.q));
        break;
      }
      case "add-query-ok": {
        const { q: h, result: y } = n, b = q(h);
        if (!this._hasQueryListeners() && !this.querySubs.currentValue[b])
          break;
        const g = (a = (o = y == null ? void 0 : y[0]) == null ? void 0 : o.data) == null ? void 0 : a["page-info"], w = (u = (c = y == null ? void 0 : y[0]) == null ? void 0 : c.data) == null ? void 0 : u.aggregate, m = $r(y), _ = this.ensureAttrs(), S = Je(_, m, r, this.config.useDateObjects);
        this.querySubs.updateInPlace((O) => {
          if (!O[b]) {
            this._log.info("Missing value in querySubs", { hash: b, q: h });
            return;
          }
          O[b].result = {
            store: S,
            attrsStore: _,
            pageInfo: g,
            aggregate: w,
            processedTxId: n["processed-tx-id"]
          };
        }), this._cleanupPendingMutationsQueries(), this.notifyOne(b), this.notifyOneQueryOnce(b), this._cleanupPendingMutationsTimeout();
        break;
      }
      case "start-sync-ok": {
        this._syncTable.onStartSyncOk(n);
        break;
      }
      case "sync-load-batch": {
        this._syncTable.onSyncLoadBatch(n);
        break;
      }
      case "sync-init-finish": {
        this._syncTable.onSyncInitFinish(n);
        break;
      }
      case "sync-update-triples": {
        this._syncTable.onSyncUpdateTriples(n);
        break;
      }
      case "refresh-ok": {
        const { computations: h, attrs: y } = n, b = n["processed-tx-id"];
        y && this._setAttrs(y), this._cleanupPendingMutationsTimeout();
        const g = this._rewriteMutations(this.ensureAttrs(), this._pendingMutations(), b);
        g !== this._pendingMutations() && this.kv.updateInPlace((_) => {
          _.pendingMutations = g;
        });
        const w = Xt(g.entries()), m = h.map((_) => {
          var We, ie, le, be;
          const S = _["instaql-query"], O = _["instaql-result"], E = q(S), j = $r(O), L = this.ensureAttrs(), B = Je(L, j, r, this.config.useDateObjects), { store: qe, attrsStore: ut } = this._applyOptimisticUpdates(B, L, w, b), Ut = (ie = (We = O == null ? void 0 : O[0]) == null ? void 0 : We.data) == null ? void 0 : ie["page-info"], Lt = (be = (le = O == null ? void 0 : O[0]) == null ? void 0 : le.data) == null ? void 0 : be.aggregate;
          return {
            q: S,
            hash: E,
            store: qe,
            attrsStore: ut,
            pageInfo: Ut,
            aggregate: Lt
          };
        });
        m.forEach(({ hash: _, q: S, store: O, attrsStore: E, pageInfo: j, aggregate: L }) => {
          this.querySubs.updateInPlace((B) => {
            if (!B[_]) {
              this._log.error("Missing value in querySubs", { hash: _, q: S });
              return;
            }
            B[_].result = {
              store: O,
              attrsStore: E,
              pageInfo: j,
              aggregate: L,
              processedTxId: b
            };
          });
        }), this._cleanupPendingMutationsQueries(), m.forEach(({ hash: _ }) => {
          this.notifyOne(_);
        });
        break;
      }
      case "transact-ok": {
        const { "client-event-id": h, "tx-id": y } = n;
        this._inFlightMutationEventIds.delete(h);
        const g = this._rewriteMutations(this.ensureAttrs(), this._pendingMutations()).get(h);
        if (!g)
          break;
        this._updatePendingMutations((m) => {
          m.set(h, {
            ...m.get(h),
            "tx-id": y,
            confirmed: Date.now()
          });
        });
        const w = [];
        for (const m of g["tx-steps"])
          if (m[0] === "add-attr") {
            const _ = m[1];
            w.push(_);
          }
        if (w.length) {
          const m = Object.values(this.ensureAttrs().attrs);
          this._setAttrs([...m, ...w]);
        }
        this._finishTransaction("synced", h), this._cleanupPendingMutationsTimeout();
        break;
      }
      case "patch-presence": {
        const h = n["room-id"];
        this._trySetRoomConnected(h, !0), this._patchPresencePeers(h, n.edits), this._notifyPresenceSubs(h);
        break;
      }
      case "refresh-presence": {
        const h = n["room-id"];
        this._trySetRoomConnected(h, !0), this._setPresencePeers(h, n.data), this._notifyPresenceSubs(h);
        break;
      }
      case "server-broadcast": {
        const h = n["room-id"], y = n.topic;
        this._trySetRoomConnected(h, !0), this._notifyBroadcastSubs(h, y, n);
        break;
      }
      case "join-room-ok": {
        const h = n["room-id"];
        if (!this._rooms[h]) {
          this._roomsPendingLeave[h] && (this._tryLeaveRoom(h), delete this._roomsPendingLeave[h]);
          break;
        }
        this._trySetRoomConnected(h, !0), this._flushEnqueuedRoomData(h);
        break;
      }
      case "leave-room-ok": {
        const h = n["room-id"];
        this._trySetRoomConnected(h, !1);
        break;
      }
      case "join-room-error":
        const l = n["room-id"], f = this._rooms[l];
        f && (f.error = n.error), this._notifyPresenceSubs(l);
        break;
      case "error":
        this._handleReceiveError(n);
        break;
      default:
        this._log.info("Uknown op", n.op, n);
        break;
    }
  }
  _pendingMutations() {
    return this.kv.currentValue.pendingMutations ?? /* @__PURE__ */ new Map();
  }
  _updatePendingMutations(e) {
    this.kv.updateInPlace((n) => {
      const r = n.pendingMutations ?? /* @__PURE__ */ new Map();
      n.pendingMutations = r, e(r);
    });
  }
  /**
   * @param {'timeout' | 'error'} status
   * @param {string} eventId
   * @param {{message?: string, type?: string, status?: number, hint?: unknown}} errorMsg
   */
  _handleMutationError(e, n, r) {
    const s = this._pendingMutations().get(n);
    if (s && (e !== "timeout" || !s["tx-id"])) {
      this._updatePendingMutations((o) => (o.delete(n), o)), this._inFlightMutationEventIds.delete(n);
      const i = {
        message: r.message,
        hint: r.hint
      };
      this.notifyAll(), this.notifyAttrsSubs(), this.notifyMutationErrorSubs(i), this._finishTransaction(e, n, r);
    }
  }
  _handleReceiveError(e) {
    var a, c, u, l, f, h, y;
    console.log("error", e);
    const n = e["client-event-id"];
    this._inFlightMutationEventIds.delete(n);
    const r = this._pendingMutations().get(n), s = {
      message: e.message || "Uh-oh, something went wrong. Ping Joe & Stopa."
    };
    if (e.hint && (s.hint = e.hint), r) {
      this._handleMutationError("error", n, e);
      return;
    }
    if ((a = e["original-event"]) != null && a.hasOwnProperty("q") && ((c = e["original-event"]) == null ? void 0 : c.op) === "add-query") {
      const b = (u = e["original-event"]) == null ? void 0 : u.q, g = q(b);
      this.notifyQueryError(q(b), s), this.notifyQueryOnceError(b, g, n, s);
      return;
    }
    if (((l = e["original-event"]) == null ? void 0 : l.op) === "init") {
      if (e.type === "record-not-found" && ((f = e.hint) == null ? void 0 : f["record-type"]) === "app-user") {
        this.changeCurrentUser(null);
        return;
      }
      this._setStatus(de.ERRORED, s), this.notifyAll();
      return;
    }
    if (((h = e["original-event"]) == null ? void 0 : h.op) === "resync-table") {
      this._syncTable.onResyncError(e);
      return;
    }
    if (((y = e["original-event"]) == null ? void 0 : y.op) === "start-sync") {
      this._syncTable.onStartSyncError(e);
      return;
    }
    const o = { ...e };
    delete o.message, delete o.hint, console.error(e.message, o), e.hint && console.error(`This error comes with some debugging information. Here it is: 
`, e.hint);
  }
  notifyQueryOnceError(e, n, r, s) {
    var o;
    const i = (o = this.queryOnceDfds[n]) == null ? void 0 : o.find((a) => a.eventId === r);
    i && (i.dfd.reject(s), this._completeQueryOnce(e, n, i.dfd));
  }
  _setAttrs(e) {
    this.attrs = new Ee(e.reduce((n, r) => (n[r.id] = r, n), {}), this._linkIndex), this.notifyAttrsSubs();
  }
  _startQuerySub(e, n) {
    const r = W();
    return this.querySubs.updateInPlace((s) => {
      s[n] = s[n] || { q: e, result: null, eventId: r }, s[n].lastAccessed = Date.now();
    }), this._trySendAuthed(r, { op: "add-query", q: e }), r;
  }
  subscribeTable(e, n) {
    return this._syncTable.subscribe(e, n);
  }
  /**
   *  When a user subscribes to a query the following side effects occur:
   *
   *  - We update querySubs to include the new query
   *  - We update queryCbs to include the new cb
   *  - If we already have a result for the query we call cb immediately
   *  - We send the server an `add-query` message
   *
   *  Returns an unsubscribe function
   */
  subscribeQuery(e, n, r) {
    this.config.disableValidation || Lr(e, this.config.schema), r && "ruleParams" in r && (e = { $$ruleParams: r.ruleParams, ...e });
    const s = q(e), i = this.getPreviousResult(e);
    return i && n(i), this.queryCbs[s] = this.queryCbs[s] ?? [], this.queryCbs[s].push({ q: e, cb: n }), this._startQuerySub(e, s), () => {
      this._unsubQuery(e, s, n);
    };
  }
  queryOnce(e, n) {
    this.config.disableValidation || Lr(e, this.config.schema), n && "ruleParams" in n && (e = { $$ruleParams: n.ruleParams, ...e });
    const r = new xr();
    if (!this._isOnline)
      return r.reject(new Error("We can't run `queryOnce`, because the device is offline.")), r.promise;
    if (!this.querySubs)
      return r.reject(new Error("We can't run `queryOnce` on the backend. Use adminAPI.query instead: https://www.instantdb.com/docs/backend#query")), r.promise;
    const s = q(e), i = this._startQuerySub(e, s);
    return this.queryOnceDfds[s] = this.queryOnceDfds[s] ?? [], this.queryOnceDfds[s].push({ q: e, dfd: r, eventId: i }), setTimeout(() => r.reject(new Error("Query timed out")), vc), r.promise;
  }
  _completeQueryOnce(e, n, r) {
    this.queryOnceDfds[n] && (this.queryOnceDfds[n] = this.queryOnceDfds[n].filter((s) => s.dfd !== r), this._cleanupQuery(e, n));
  }
  _unsubQuery(e, n, r) {
    this.queryCbs[n] && (this.queryCbs[n] = this.queryCbs[n].filter((s) => s.cb !== r), this._cleanupQuery(e, n));
  }
  _hasQueryListeners(e) {
    var n, r;
    return !!((n = this.queryCbs[e]) != null && n.length || (r = this.queryOnceDfds[e]) != null && r.length);
  }
  _cleanupQuery(e, n) {
    this._hasQueryListeners(n) || (delete this.queryCbs[n], delete this.queryOnceDfds[n], delete this._dataForQueryCache[n], this.querySubs.unloadKey(n), this._trySendAuthed(W(), { op: "remove-query", q: e }));
  }
  // When we `pushTx`, it's possible that we don't yet have `this.attrs`
  // This means that `tx-steps` in `pendingMutations` will include `add-attr`
  // commands for attrs that already exist.
  //
  // This will also affect `add-triple` and `retract-triple` which
  // reference attr-ids that do not match the server.
  //
  // We fix this by rewriting `tx-steps` in each `pendingMutation`.
  // We remove `add-attr` commands for attrs that already exist.
  // We update `add-triple` and `retract-triple` commands to use the
  // server attr-ids.
  /**
   *
   * @param {s.AttrsStore} attrs
   * @param {any} muts
   * @param {number} [processedTxId]
   */
  _rewriteMutations(e, n, r) {
    if (!e)
      return n;
    if (!n)
      return /* @__PURE__ */ new Map();
    const s = (l) => {
      const [f, h, y] = l["forward-identity"];
      return N(e, h, y);
    }, i = (l) => {
      const [f, h, y] = l["forward-identity"];
      return Ce(e, h, y);
    }, o = { attrIdMap: {}, refSwapAttrIds: /* @__PURE__ */ new Set() };
    let a = !1;
    const c = (l, f) => {
      const h = [];
      for (const y of l) {
        const [b] = y;
        if (b === "add-attr") {
          const [w, m] = y, _ = s(m);
          if (_ && m.id !== _.id) {
            o.attrIdMap[m.id] = _.id, a = !0;
            continue;
          }
          if (m["value-type"] === "ref") {
            const S = i(m);
            if (S) {
              o.attrIdMap[m.id] = S.id, o.refSwapAttrIds.add(m.id), a = !0;
              continue;
            }
          }
        }
        if (r && f && r >= f && b === "add-attr" || b === "update-attr" || b === "delete-attr") {
          a = !0;
          continue;
        }
        const g = a ? ha(o, y) : y;
        h.push(g);
      }
      return a ? h : l;
    }, u = /* @__PURE__ */ new Map();
    for (const [l, f] of n.entries())
      u.set(l, {
        ...f,
        "tx-steps": c(f["tx-steps"], f["tx-id"])
      });
    return a ? u : n;
  }
  _rewriteMutationsSorted(e, n) {
    return Xt(this._rewriteMutations(e, n).entries());
  }
  // ---------------------------
  // Transact
  /**
   * @returns {s.AttrsStore}
   */
  optimisticAttrs() {
    var i, o;
    const e = [...this._pendingMutations().values()].flatMap((a) => a["tx-steps"]), n = new Set(e.filter(([a, c]) => a === "delete-attr").map(([a, c]) => c)), r = [];
    for (const [a, c] of e)
      if (a === "add-attr")
        r.push(c);
      else if (a === "update-attr" && c.id && ((i = this.attrs) != null && i.getAttr(c.id))) {
        const u = { ...this.attrs.getAttr(c.id), ...c };
        r.push(u);
      }
    if (!n.size && !r.length)
      return this.attrs || new Ee({}, this._linkIndex);
    const s = { ...((o = this.attrs) == null ? void 0 : o.attrs) || {} };
    for (const a of r)
      s[a.id] = a;
    for (const a of n)
      delete s[a];
    return new Ee(s, this._linkIndex);
  }
  /** Runs instaql on a query and a store */
  dataForQuery(e, n = !0) {
    const r = this._errorMessage;
    if (r)
      return { error: r };
    if (!this.querySubs || !this.kv.currentValue.pendingMutations)
      return;
    const s = this.querySubs.version(), i = this.querySubs.currentValue, o = this.kv.version(), a = this._pendingMutations(), { q: c, result: u } = i[e] || {};
    if (!u)
      return;
    const l = this._dataForQueryCache[e];
    if (l && s === l.querySubVersion && o === l.pendingMutationsVersion)
      return l;
    let f = u.store, h = u.attrsStore;
    const { pageInfo: y, aggregate: b, processedTxId: g } = u, w = this._rewriteMutationsSorted(h, a);
    if (n) {
      const _ = this._applyOptimisticUpdates(f, h, w, g);
      f = _.store, h = _.attrsStore;
    }
    return { data: Cs({ store: f, attrsStore: h, pageInfo: y, aggregate: b }, c), querySubVersion: s, pendingMutationsVersion: o };
  }
  _applyOptimisticUpdates(e, n, r, s) {
    for (const [i, o] of r)
      if (!o["tx-id"] || s && o["tx-id"] > s) {
        const a = ho(e, n, o["tx-steps"]);
        e = a.store, n = a.attrsStore;
      }
    return { store: e, attrsStore: n };
  }
  /** Re-compute all subscriptions */
  notifyAll() {
    Object.keys(this.queryCbs).forEach((e) => {
      this.querySubs.waitForKeyToLoad(e).then(() => this.notifyOne(e)).catch(() => this.notifyOne(e));
    });
  }
  loadedNotifyAll() {
    this.kv.waitForKeyToLoad("pendingMutations").then(() => this.notifyAll()).catch(() => this.notifyAll());
  }
  shutdown() {
    var e;
    this._log.info("[shutdown]", this.config.appId), this._isShutdown = !0, (e = this._transport) == null || e.close();
  }
  /**
   * Sends mutation to server and schedules a timeout to cancel it if
   * we don't hear back in time.
   * Note: If we're offline we don't schedule a timeout, we'll schedule it
   * later once we're back online and send the mutation again
   *
   */
  _sendMutation(e, n) {
    if (n.error) {
      this._handleMutationError("error", e, {
        message: n.error.message
      });
      return;
    }
    if (this.status !== de.AUTHENTICATED) {
      this._finishTransaction("enqueued", e);
      return;
    }
    const r = Math.max(6e3, Math.min(
      this._inFlightMutationEventIds.size + 1,
      // Defensive code in case we don't clean up in flight mutation event ids
      this._pendingMutations().size + 1
    ) * 6e3);
    this._isOnline ? (this._trySend(e, n), setTimeout(() => {
      this._isOnline && this._handleMutationError("timeout", e, {
        message: "transaction timed out"
      });
    }, r)) : this._finishTransaction("enqueued", e);
  }
  // ---------------------------
  // Websocket
  /** Send messages we accumulated while we were connecting */
  _flushPendingMessages() {
    Object.keys(this.queryCbs).map((i) => this.querySubs.currentValue[i]).filter((i) => i).forEach(({ eventId: i, q: o }) => {
      this._trySendAuthed(i, { op: "add-query", q: o });
    }), Object.values(this.queryOnceDfds).flat().forEach(({ eventId: i, q: o }) => {
      this._trySendAuthed(i, { op: "add-query", q: o });
    });
    const r = this._rewriteMutations(this.ensureAttrs(), this._pendingMutations());
    r !== this._pendingMutations() && this.kv.updateInPlace((i) => {
      i.pendingMutations = r;
    }), Xt(r.entries()).forEach(([i, o]) => {
      o["tx-id"] || this._sendMutation(i, o);
    }), this._syncTable.flushPending();
  }
  /**
   * Clean up pendingMutations that all queries have seen
   */
  _cleanupPendingMutationsQueries() {
    let e = Number.MAX_SAFE_INTEGER;
    for (const { result: n } of Object.values(this.querySubs.currentValue))
      n != null && n.processedTxId && (e = Math.min(e, n == null ? void 0 : n.processedTxId));
    this._updatePendingMutations((n) => {
      for (const [r, s] of Array.from(n.entries()))
        s["tx-id"] && s["tx-id"] <= e && n.delete(r);
    });
  }
  /**
   * After mutations is confirmed by server, we give each query 30 sec
   * to update its results. If that doesn't happen, we assume query is
   * unaffected by this mutation and its safe to delete it from local queue
   */
  _cleanupPendingMutationsTimeout() {
    if (this._pendingMutations().size < this._pendingMutationCleanupThreshold)
      return;
    const e = Date.now();
    this._updatePendingMutations((n) => {
      for (const [r, s] of Array.from(n.entries()))
        s.confirmed && s.confirmed + this._pendingTxCleanupTimeout < e && n.delete(r);
    });
  }
  _trySendAuthed(...e) {
    this.status === de.AUTHENTICATED && this._trySend(...e);
  }
  _trySend(e, n, r) {
    if (this._transport.isOpen()) {
      switch (zr[n.op] || this._log.info("[send]", this._transport.id, n.op, n), n.op) {
        case "transact": {
          this._inFlightMutationEventIds.add(e);
          break;
        }
        case "init":
          this._inFlightMutationEventIds.clear();
      }
      this._transport.send({ "client-event-id": e, ...n });
    }
  }
  _startSocket() {
    if (this._wsOk = null, this._isShutdown) {
      this._log.info("[socket][start]", this.config.appId, "Reactor has been shut down and will not start a new socket");
      return;
    }
    if (this._transport && this._transport.isConnecting()) {
      this._log.info("[socket][start]", this._transport.id, "maintained as current transport, we were still in a connecting state");
      return;
    }
    const e = this._transport;
    this._transport = Cc({
      transportType: this._transportType,
      appId: this.config.appId,
      apiURI: this.config.apiURI,
      wsURI: this.config.websocketURI,
      EventSourceImpl: this._EventSource
    }), this._transport.onopen = this._transportOnOpen, this._transport.onmessage = this._transportOnMessage, this._transport.onclose = this._transportOnClose, this._transport.onerror = this._transportOnError, this._log.info("[socket][start]", this._transport.id), e != null && e.isOpen() && (this._log.info("[socket][start]", this._transport.id, "close previous transport id = ", e.id), e.close());
  }
  /**
   * Given a key, returns a stable local id, unique to this device and app.
   *
   * This can be useful if you want to create guest ids for example.
   *
   * Note: If the user deletes their local storage, this id will change.
   *
   */
  async getLocalId(e) {
    const n = `localToken_${e}`;
    if (this.kv.currentValue[n])
      return this.kv.currentValue[n];
    const r = await this.kv.waitForKeyToLoad(n);
    if (r)
      return r;
    const s = W();
    return this.kv.updateInPlace((i) => {
      i[n] || (i[n] = s);
    }), await this.kv.waitForKeyToLoad(n);
  }
  // ----
  // Auth
  _replaceUrlAfterOAuth() {
    if (typeof URL > "u")
      return;
    const e = new URL(window.location.href);
    if (e.searchParams.get(Zt)) {
      const n = e.toString();
      e.searchParams.delete(Zt), e.searchParams.delete("code"), e.searchParams.delete("error");
      const r = e.pathname + (e.searchParams.size ? "?" + e.searchParams : "") + e.hash;
      if (history.replaceState(history.state, "", r), // @ts-ignore (waiting for ts support)
      typeof navigation == "object" && // @ts-ignore (waiting for ts support)
      typeof navigation.addEventListener == "function" && // @ts-ignore (waiting for ts support)
      typeof navigation.removeEventListener == "function") {
        let s = !1;
        const i = (o) => {
          var a;
          s || (s = !0, navigation.removeEventListener("navigate", i), !o.userInitiated && o.navigationType === "replace" && ((a = o.destination) == null ? void 0 : a.url) === n && history.replaceState(history.state, "", r));
        };
        navigation.addEventListener("navigate", i);
      }
    }
  }
  /**
   *
   * @returns Promise<null | {error: {message: string}}>
   */
  async _oauthLoginInit() {
    var s, i, o, a;
    if (typeof window > "u" || typeof window.location > "u" || typeof URLSearchParams > "u")
      return null;
    const e = new URLSearchParams(window.location.search);
    if (!e.get(Zt))
      return null;
    const n = e.get("error");
    if (n)
      return this._replaceUrlAfterOAuth(), { error: { message: n } };
    const r = e.get("code");
    if (!r)
      return null;
    this._replaceUrlAfterOAuth();
    try {
      const c = await this._getCurrentUser(), u = (c == null ? void 0 : c.type) === "guest", { user: l } = await jr({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        code: r,
        refreshToken: u ? c.refresh_token : void 0
      });
      return this.setCurrentUser(l), null;
    } catch (c) {
      return ((s = c == null ? void 0 : c.body) == null ? void 0 : s.type) === "record-not-found" && ((o = (i = c == null ? void 0 : c.body) == null ? void 0 : i.hint) == null ? void 0 : o["record-type"]) === "app-oauth-code" && await this._hasCurrentUser() ? null : { error: { message: ((a = c == null ? void 0 : c.body) == null ? void 0 : a.message) || "Error logging in." } };
    }
  }
  async _waitForOAuthCallbackResponse() {
    return await this._oauthCallbackResponse;
  }
  __subscribeMutationErrors(e) {
    return this.mutationErrorCbs.push(e), () => {
      this.mutationErrorCbs = this.mutationErrorCbs.filter((n) => n !== e);
    };
  }
  subscribeAuth(e) {
    this.authCbs.push(e);
    const n = this._currentUserCached;
    n.isLoading || e(this._currentUserCached);
    let r = !1;
    return this.getCurrentUser().then((s) => {
      r || mt(s, n) || e(s);
    }), () => {
      r = !0, this.authCbs = this.authCbs.filter((s) => s !== e);
    };
  }
  async getAuth() {
    const { user: e, error: n } = await this.getCurrentUser();
    if (n)
      throw new Ne("Could not get current user: " + n.message);
    return e;
  }
  subscribeConnectionStatus(e) {
    return this.connectionStatusCbs.push(e), () => {
      this.connectionStatusCbs = this.connectionStatusCbs.filter((n) => n !== e);
    };
  }
  subscribeAttrs(e) {
    return this.attrsCbs.push(e), this.attrs && e(this.attrs.attrs), () => {
      this.attrsCbs = this.attrsCbs.filter((n) => n !== e);
    };
  }
  notifyAuthSubs(e) {
    this.authCbs.forEach((n) => n(e));
  }
  notifyMutationErrorSubs(e) {
    this.mutationErrorCbs.forEach((n) => n(e));
  }
  notifyAttrsSubs() {
    if (!this.attrs)
      return;
    const e = this.optimisticAttrs();
    this.attrsCbs.forEach((n) => n(e.attrs));
  }
  notifyConnectionStatusSubs(e) {
    this.connectionStatusCbs.forEach((n) => n(e));
  }
  async setCurrentUser(e) {
    this.kv.updateInPlace((n) => {
      n[Ve] = e;
    }), await this.kv.waitForKeyToLoad(Ve);
  }
  getCurrentUserCached() {
    return this._currentUserCached;
  }
  async _getCurrentUser() {
    const e = await this.kv.waitForKeyToLoad(Ve);
    return typeof e == "string" ? JSON.parse(e) : e;
  }
  async getCurrentUser() {
    const e = await this._waitForOAuthCallbackResponse();
    if (e != null && e.error) {
      const n = { error: e.error, user: void 0 };
      return this._currentUserCached = { isLoading: !1, ...n }, n;
    }
    try {
      const r = { user: await this._getCurrentUser(), error: void 0 };
      return this._currentUserCached = {
        isLoading: !1,
        ...r
      }, r;
    } catch (n) {
      return {
        user: void 0,
        isLoading: !1,
        error: { message: (n == null ? void 0 : n.message) || "Error loading user" }
      };
    }
  }
  async _hasCurrentUser() {
    const e = await this.kv.waitForKeyToLoad(Ve);
    return typeof e == "string" ? JSON.parse(e) != null : e != null;
  }
  async changeCurrentUser(e) {
    var r;
    const { user: n } = await this.getCurrentUser();
    if (!mt(n, e)) {
      await this.setCurrentUser(e), this.updateUser(e);
      try {
        (r = this._broadcastChannel) == null || r.postMessage({ type: "auth" });
      } catch (s) {
        console.error("Error posting message to broadcast channel", s);
      }
    }
  }
  async syncUserToEndpoint(e) {
    if (this.config.firstPartyPath)
      try {
        fetch(this.config.firstPartyPath + "/", {
          method: "POST",
          body: JSON.stringify({
            type: "sync-user",
            appId: this.config.appId,
            user: e
          }),
          headers: {
            "Content-Type": "application/json"
          }
        });
      } catch (n) {
        this._log.error("Error syncing user with external endpoint", n);
      }
  }
  updateUser(e) {
    this.syncUserToEndpoint(e);
    const n = { error: void 0, user: e };
    this._currentUserCached = { isLoading: !1, ...n }, this._dataForQueryCache = {}, this.querySubs.updateInPlace((r) => {
      Object.keys(r).forEach((s) => {
        delete r[s].result;
      });
    }), this._reconnectTimeoutMs = 0, this._transport.close(), this._oauthCallbackResponse = null, this.notifyAuthSubs(n);
  }
  sendMagicCode({ email: e }) {
    return Ba({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      email: e
    });
  }
  async signInWithMagicCode({ email: e, code: n }) {
    var o;
    const r = await this.getCurrentUser(), s = ((o = r == null ? void 0 : r.user) == null ? void 0 : o.type) === "guest", i = await Ga({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      email: e,
      code: n,
      refreshToken: s ? r.user.refresh_token : void 0
    });
    return await this.changeCurrentUser(i.user), i;
  }
  async signInWithCustomToken(e) {
    const n = await Qa({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      refreshToken: e
    });
    return await this.changeCurrentUser(n.user), n;
  }
  async signInAsGuest() {
    const e = await Ha({
      apiURI: this.config.apiURI,
      appId: this.config.appId
    });
    return await this.changeCurrentUser(e.user), e;
  }
  potentiallyInvalidateToken(e, n) {
    var i;
    const r = (i = e == null ? void 0 : e.user) == null ? void 0 : i.refresh_token;
    if (!r)
      return;
    if (n.invalidateToken === !1) {
      this._log.info("[auth-invalidate] skipped invalidateToken");
      return;
    }
    Ya({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      refreshToken: r
    }).then(() => {
      this._log.info("[auth-invalidate] completed invalidateToken");
    }).catch((o) => {
    });
  }
  async signOut(e) {
    const n = await this.getCurrentUser();
    this.potentiallyInvalidateToken(n, e), await this.changeCurrentUser(null);
  }
  /**
   * Creates an OAuth authorization URL.
   *
   * @param {Object} params - The parameters to create the authorization URL.
   * @param {string} params.clientName - The name of the client requesting authorization.
   * @param {string} params.redirectURL - The URL to redirect users to after authorization.
   * @returns {string} The created authorization URL.
   */
  createAuthorizationURL({ clientName: e, redirectURL: n }) {
    const { apiURI: r, appId: s } = this.config;
    return `${r}/runtime/oauth/start?app_id=${s}&client_name=${e}&redirect_uri=${n}`;
  }
  /**
   * @param {Object} params
   * @param {string} params.code - The code received from the OAuth service.
   * @param {string} [params.codeVerifier] - The code verifier used to generate the code challenge.
   */
  async exchangeCodeForToken({ code: e, codeVerifier: n }) {
    var o;
    const r = await this.getCurrentUser(), s = ((o = r == null ? void 0 : r.user) == null ? void 0 : o.type) === "guest", i = await jr({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      code: e,
      codeVerifier: n,
      refreshToken: s ? r.user.refresh_token : void 0
    });
    return await this.changeCurrentUser(i.user), i;
  }
  issuerURI() {
    const { apiURI: e, appId: n } = this.config;
    return `${e}/runtime/${n}`;
  }
  /**
   * @param {Object} params
   * @param {string} params.clientName - The name of the client requesting authorization.
   * @param {string} params.idToken - The id_token from the external service
   * @param {string | null | undefined} [params.nonce] - The nonce used when requesting the id_token from the external service
   */
  async signInWithIdToken({ idToken: e, clientName: n, nonce: r }) {
    var a;
    const s = await this.getCurrentUser(), i = (a = s == null ? void 0 : s.user) == null ? void 0 : a.refresh_token, o = await Ja({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      idToken: e,
      clientName: n,
      nonce: r,
      refreshToken: i
    });
    return await this.changeCurrentUser(o.user), o;
  }
  // --------
  // Rooms
  /**
   * @param {string} roomId
   * @param {any | null | undefined} [initialPresence] -- initial presence data to send when joining the room
   * @returns () => void
   */
  joinRoom(e, n) {
    let r = !1;
    this._rooms[e] || (r = !0, this._rooms[e] = {
      isConnected: !1,
      error: void 0
    }), this._presence[e] = this._presence[e] || {};
    const s = this._presence[e].result;
    return n && !s && (this._presence[e].result = this._presence[e].result || {}, this._presence[e].result.user = n, this._notifyPresenceSubs(e)), r && this._tryJoinRoom(e, n), () => {
      this._cleanupRoom(e);
    };
  }
  _cleanupRoom(e) {
    var n, r, s;
    if (!((r = (n = this._presence[e]) == null ? void 0 : n.handlers) != null && r.length) && !Object.keys(this._broadcastSubs[e] ?? {}).length) {
      const i = (s = this._rooms[e]) == null ? void 0 : s.isConnected;
      delete this._rooms[e], delete this._presence[e], delete this._broadcastSubs[e], i ? this._tryLeaveRoom(e) : this._roomsPendingLeave[e] = !0;
    }
  }
  // --------
  // Presence
  // TODO: look into typing again
  getPresence(e, n, r = {}) {
    const s = this._rooms[n], i = this._presence[n];
    return !s || !i || !i.result ? null : {
      ...rc(i.result, r, this._sessionId),
      isLoading: !s.isConnected,
      error: s.error
    };
  }
  // TODO: look into typing again
  publishPresence(e, n, r) {
    const s = this._rooms[n], i = this._presence[n];
    if (!s || !i)
      return;
    i.result = i.result || {};
    const o = {
      ...i.result.user,
      ...r
    };
    i.result.user = o, s.isConnected && (this._trySetPresence(n, o), this._notifyPresenceSubs(n));
  }
  _trySetPresence(e, n) {
    this._trySendAuthed(W(), {
      op: "set-presence",
      "room-id": e,
      data: n
    });
  }
  _tryJoinRoom(e, n) {
    this._trySendAuthed(W(), { op: "join-room", "room-id": e, data: n }), delete this._roomsPendingLeave[e];
  }
  _tryLeaveRoom(e) {
    this._trySendAuthed(W(), { op: "leave-room", "room-id": e });
  }
  _trySetRoomConnected(e, n) {
    const r = this._rooms[e];
    r && (r.isConnected = n);
  }
  // TODO: look into typing again
  subscribePresence(e, n, r, s) {
    const i = this.joinRoom(
      n,
      // Oct 28, 2025
      // Note: initialData is deprecated.
      // Keeping here for backwards compatibility
      r.initialPresence || r.initialData
    ), o = { ...r, roomId: n, cb: s, prev: null };
    return this._presence[n] = this._presence[n] || {}, this._presence[n].handlers = this._presence[n].handlers || [], this._presence[n].handlers.push(o), this._notifyPresenceSub(n, o), () => {
      var a, c;
      this._presence[n].handlers = ((c = (a = this._presence[n]) == null ? void 0 : a.handlers) == null ? void 0 : c.filter((u) => u !== o)) ?? [], i();
    };
  }
  _notifyPresenceSubs(e) {
    var n, r;
    (r = (n = this._presence[e]) == null ? void 0 : n.handlers) == null || r.forEach((s) => {
      this._notifyPresenceSub(e, s);
    });
  }
  _notifyPresenceSub(e, n) {
    const r = this.getPresence("", e, n);
    r && (n.prev && !sc(r, n.prev) || (n.prev = r, n.cb(r)));
  }
  _patchPresencePeers(e, n) {
    var o, a, c;
    const r = ((a = (o = this._presence[e]) == null ? void 0 : o.result) == null ? void 0 : a.peers) || {};
    let s = Object.fromEntries(Object.entries(r).map(([u, l]) => [u, { data: l }]));
    (c = this._presence[e]) == null || c.result;
    const i = Ct(s, (u) => {
      for (let [l, f, h] of n)
        switch (f) {
          case "+":
            xi(u, l, h);
            break;
          case "r":
            wr(u, l, h);
            break;
          case "-":
            ds(u, l);
            break;
        }
      delete u[this._sessionId];
    });
    this._setPresencePeers(e, i);
  }
  _setPresencePeers(e, n) {
    const r = { ...n };
    delete r[this._sessionId];
    const s = Object.fromEntries(Object.entries(r).map(([i, o]) => [i, o.data]));
    this._presence = Ct(this._presence, (i) => {
      wr(i, [e, "result", "peers"], s);
    });
  }
  // --------
  // Broadcast
  publishTopic({ roomType: e, roomId: n, topic: r, data: s }) {
    const i = this._rooms[n];
    if (i) {
      if (!i.isConnected) {
        this._broadcastQueue[n] = this._broadcastQueue[n] ?? [], this._broadcastQueue[n].push({ topic: r, roomType: e, data: s });
        return;
      }
      this._tryBroadcast(n, e, r, s);
    }
  }
  _tryBroadcast(e, n, r, s) {
    this._trySendAuthed(W(), {
      op: "client-broadcast",
      "room-id": e,
      roomType: n,
      topic: r,
      data: s
    });
  }
  subscribeTopic(e, n, r) {
    const s = this.joinRoom(e);
    return this._broadcastSubs[e] = this._broadcastSubs[e] || {}, this._broadcastSubs[e][n] = this._broadcastSubs[e][n] || [], this._broadcastSubs[e][n].push(r), this._presence[e] = this._presence[e] || {}, () => {
      this._broadcastSubs[e][n] = this._broadcastSubs[e][n].filter((i) => i !== r), this._broadcastSubs[e][n].length || delete this._broadcastSubs[e][n], s();
    };
  }
  _notifyBroadcastSubs(e, n, r) {
    var s, i, o;
    (o = (i = (s = this._broadcastSubs) == null ? void 0 : s[e]) == null ? void 0 : i[n]) == null || o.forEach((a) => {
      var l, f, h, y, b, g;
      const c = (l = r.data) == null ? void 0 : l.data, u = r.data["peer-id"] === this._sessionId ? (h = (f = this._presence[e]) == null ? void 0 : f.result) == null ? void 0 : h.user : (g = (b = (y = this._presence[e]) == null ? void 0 : y.result) == null ? void 0 : b.peers) == null ? void 0 : g[r.data["peer-id"]];
      return a(c, u);
    });
  }
  // --------
  // Storage
  async uploadFile(e, n, r) {
    var o;
    const s = await this.getCurrentUser(), i = (o = s == null ? void 0 : s.user) == null ? void 0 : o.refresh_token;
    return Za({
      ...r,
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      path: e,
      file: n,
      refreshToken: i
    });
  }
  async deleteFile(e) {
    var i;
    const n = await this.getCurrentUser(), r = (i = n == null ? void 0 : n.user) == null ? void 0 : i.refresh_token;
    return await Xa({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      path: e,
      refreshToken: r
    });
  }
  // Deprecated Storage API (Jan 2025)
  // ---------------------------------
  async upload(e, n) {
    var c;
    const r = await this.getCurrentUser(), s = (c = r == null ? void 0 : r.user) == null ? void 0 : c.refresh_token, i = e || n.name, o = await ec({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      fileName: i,
      refreshToken: s
    });
    return await tc(o, n);
  }
  async getDownloadUrl(e) {
    var i;
    const n = await this.getCurrentUser(), r = (i = n == null ? void 0 : n.user) == null ? void 0 : i.refresh_token;
    return await nc({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      path: e,
      refreshToken: r
    });
  }
}
function Dc(t, e) {
  return new Dt(
    qs(t, e),
    // (XXX): LinksDef<any> stems from TypeScripts inability to reconcile the
    // type EntitiesWithLinks<EntitiesWithoutLinks, Links> with
    // EntitiesWithoutLinks. TypeScript is strict about ensuring that types are
    // correctly aligned and does not allow for substituting a type that might
    // be broader or have additional properties.
    e,
    void 0
  );
}
function Uc(t) {
  return new $t(t, {});
}
function Lc() {
  return new H("string", !0, !1);
}
function Fc() {
  return new H("number", !0, !1);
}
function Nc() {
  return new H("boolean", !0, !1);
}
function Kc() {
  return new H("date", !0, !1);
}
function qc() {
  return new H("json", !0, !1);
}
function Wc() {
  return new H("json", !0, !1);
}
function qs(t, e) {
  var s, i, o, a;
  const n = { fwd: {}, rev: {} };
  for (const c of Object.values(e))
    (s = n.fwd)[i = c.forward.on] || (s[i] = {}), (o = n.rev)[a = c.reverse.on] || (o[a] = {}), n.fwd[c.forward.on][c.forward.label] = {
      entityName: c.reverse.on,
      cardinality: c.forward.has
    }, n.rev[c.reverse.on][c.reverse.label] = {
      entityName: c.forward.on,
      cardinality: c.reverse.has
    };
  return Object.fromEntries(Object.entries(t).map(([c, u]) => [
    c,
    new $t(u.attrs, {
      ...n.fwd[c],
      ...n.rev[c]
    })
  ]));
}
function zc({ entities: t, links: e, rooms: n }) {
  const r = e ?? {}, s = n ?? {};
  return new Dt(
    qs(t, r),
    // (XXX): LinksDef<any> stems from TypeScript's inability to reconcile the
    // type EntitiesWithLinks<EntitiesWithoutLinks, Links> with
    // EntitiesWithoutLinks. TypeScript is strict about ensuring that types are
    // correctly aligned and does not allow for substituting a type that might
    // be broader or have additional properties.
    r,
    s
  );
}
const xu = {
  // constructs
  graph: Dc,
  schema: zc,
  entity: Uc,
  // value types
  string: Lc,
  number: Fc,
  boolean: Nc,
  date: Kc,
  json: qc,
  any: Wc
};
let gt;
function Vc(t, e) {
  gt == null || gt.dispose();
  const n = Yc(e), r = Qc(e, a), s = Gc(Bc(t));
  function i(l) {
    var f;
    l.source === s.element.contentWindow && ((f = l.data) == null ? void 0 : f.type) === "close" && n.isVisible() && a();
  }
  function o(l) {
    const f = l.shiftKey && l.ctrlKey && l.key === "0", h = l.key === "Escape" || l.key === "Esc";
    (f || h && n.isVisible()) && a();
  }
  function a() {
    n.isVisible() ? n.element.style.display = "none" : (n.element.style.display = "block", n.element.contains(s.element) || n.element.appendChild(s.element));
  }
  function c() {
    n.element.remove(), r.element.remove(), removeEventListener("keydown", o), removeEventListener("message", i);
  }
  function u() {
    document.body.appendChild(n.element), document.body.appendChild(r.element), addEventListener("keydown", o), addEventListener("message", i), gt = {
      dispose: c
    };
  }
  return u();
}
function Bc(t) {
  return `${qn || xs ? "http://localhost:3000" : "https://instantdb.com"}/_devtool?appId=${t}`;
}
function Gc(t) {
  const e = document.createElement("iframe");
  return e.src = t, e.className = "instant-devtool-iframe", Object.assign(e.style, {
    width: "100%",
    height: "100%",
    backgroundColor: "white",
    border: "none"
  }), { element: e };
}
function Qc(t, e) {
  const n = `
    <svg width="32" height="32" viewBox="0 0 512 512" fill="none" xmlns="http://www.w3.org/2000/svg">
      <rect width="512" height="512" fill="black"/>
      <rect x="97.0973" y="91.3297" width="140" height="330" fill="white"/>
    </svg>
  `, r = document.createElement("button");
  return r.innerHTML = n, r.className = "instant-devtool-toggler", Object.assign(r.style, {
    // pos
    position: "fixed",
    ...Hc(t.position),
    height: "32px",
    width: "32px",
    // layout
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    zIndex: "9010",
    // look
    padding: "0",
    margin: "0",
    border: "none",
    cursor: "pointer"
  }), r.addEventListener("click", e), { element: r };
}
function Hc(t) {
  switch (t) {
    case "bottom-left":
      return { bottom: "24px", left: "24px" };
    case "bottom-right":
      return { bottom: "24px", right: "24px" };
    case "top-right":
      return { top: "24px", right: "24px" };
    case "top-left":
      return { top: "24px", left: "24px" };
  }
}
function Jc(t) {
  switch (t) {
    case "bottom-left":
      return { bottom: "24px", right: "24px", left: "60px", top: "72px" };
    case "bottom-right":
      return { bottom: "24px", left: "24px", right: "60px", top: "72px" };
    case "top-right":
      return { top: "24px", left: "24px", right: "60px", bottom: "72px" };
    case "top-left":
      return { top: "24px", right: "24px", left: "60px", bottom: "72px" };
  }
}
function Yc(t) {
  const e = document.createElement("div");
  Object.assign(e.style, {
    position: "fixed",
    ...Jc(t.position),
    display: "block",
    borderRadius: "4px",
    border: "1px #ccc solid",
    boxShadow: "0px 0px 8px #00000044",
    backgroundColor: "#eee",
    zIndex: "999990"
  }), e.style.display = "none", e.className = "instant-devtool-container";
  function n() {
    return e.style.display !== "none";
  }
  return { element: e, isVisible: n };
}
function Zc(t, e) {
  return e && e.refresh_token ? new Response(JSON.stringify({ ok: !0 }), {
    headers: {
      "Content-Type": "application/json",
      // 7 day expiry
      "Set-Cookie": `instant_user_${t.appId}=${encodeURIComponent(JSON.stringify(e))}; Path=/; HttpOnly; Secure; SameSite=Strict; Max-Age=604800`
    }
  }) : new Response(JSON.stringify({ ok: !0 }), {
    headers: {
      "Content-Type": "application/json",
      // remove the cookie (some browsers)
      "Set-Cookie": `instant_user_${t.appId}=; Path=/; HttpOnly; Secure; SameSite=Strict; Max-Age=-1`
    }
  });
}
function _t(t, e) {
  return new Response(JSON.stringify({ ok: !1, error: e }), {
    status: t,
    headers: { "Content-Type": "application/json" }
  });
}
const $u = (t) => ({
  POST: async (e) => {
    let n;
    try {
      n = await e.json();
    } catch {
      return _t(400, "Invalid JSON body");
    }
    if (!n.type)
      return _t(400, 'Missing "type" field');
    if (n.appId !== t.appId)
      return _t(403, "App ID mismatch");
    switch (n.type) {
      case "sync-user":
        return Zc(t, n.user ?? null);
      default:
        return _t(400, `Unknown type: ${n.type}`);
    }
  }
}), Xc = {
  apiURI: "https://api.instantdb.com",
  websocketURI: "wss://api.instantdb.com/runtime/session"
};
function eu() {
  return globalThis.__instantDbSchemaHashStore = globalThis.__instantDbSchemaHashStore ?? /* @__PURE__ */ new WeakMap(), globalThis.__instantDbSchemaHashStore;
}
function tu() {
  return globalThis.__instantDbStore = globalThis.__instantDbStore ?? {}, globalThis.__instantDbStore;
}
function wn(t) {
  const e = t.__adminToken;
  return t.appId + "_" + (t.websocketURI || "default_ws_uri") + "_" + (t.apiURI || "default_api_uri") + "_" + (e || "client_only") + "_" + t.useDateObjects;
}
const Tn = tu(), Vr = eu();
class nu {
  constructor(e) {
    p(this, "db");
    /**
     * Sends a magic code to the user's email address.
     *
     * Once you send the magic code, see {@link auth.signInWithMagicCode} to let the
     * user verify.
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *  db.auth.sendMagicCode({email: "example@gmail.com"})
     *    .catch((err) => console.error(err.body?.message))
     */
    p(this, "sendMagicCode", (e) => this.db.sendMagicCode(e));
    /**
     * Verify a magic code that was sent to the user's email address.
     *
     * @see https://instantdb.com/docs/auth
     *
     * @example
     *  db.auth.signInWithMagicCode({email: "example@gmail.com", code: "123456"})
     *       .catch((err) => console.error(err.body?.message))
     */
    p(this, "signInWithMagicCode", (e) => this.db.signInWithMagicCode(e));
    /**
     * Sign in a user with a refresh token
     *
     * @see https://instantdb.com/docs/backend#frontend-auth-sign-in-with-token
     *
     * @example
     *   // Get the token from your backend
     *   const token = await fetch('/signin', ...);
     *   //Sign in
     *   db.auth.signInWithToken(token);
     */
    p(this, "signInWithToken", (e) => this.db.signInWithCustomToken(e));
    /**
     * Sign in as guest, creating a new user without email
     *
     * @see https://instantdb.com/docs/auth
     *
     * @example
     *   db.auth.signInAsGuest();
     */
    p(this, "signInAsGuest", () => this.db.signInAsGuest());
    /**
     * Create an authorization url to sign in with an external provider.
     *
     * @see https://instantdb.com/docs/auth
     *
     * @example
     *   // Get the authorization url from your backend
     *   const url = db.auth.createAuthorizationUrl({
     *     clientName: "google",
     *     redirectURL: window.location.href,
     *   });
     *
     *   // Put it in a sign in link
     *   <a href={url}>Log in with Google</a>
     */
    p(this, "createAuthorizationURL", (e) => this.db.createAuthorizationURL(e));
    /**
     * Sign in with the id_token from an external provider like Google
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *   db.auth
     *  .signInWithIdToken({
     *    // Token from external service
     *    idToken: id_token,
     *    // The name you gave the client when you registered it with Instant
     *    clientName: "google",
     *    // The nonce, if any, that you used when you initiated the auth flow
     *    // with the external service.
     *    nonce: your_nonce
     *  })
     *  .catch((err) => console.error(err.body?.message));
     *
     */
    p(this, "signInWithIdToken", (e) => this.db.signInWithIdToken(e));
    /**
     * Sign in with the id_token from an external provider like Google
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *   db.auth
     *  .exchangeOAuthCode({
     *    // code received in redirect from OAuth callback
     *    code: code
     *    // The PKCE code_verifier, if any, that you used when you
     *    // initiated the auth flow
     *    codeVerifier: your_code_verifier
     *  })
     *  .catch((err) => console.error(err.body?.message));
     *
     */
    p(this, "exchangeOAuthCode", (e) => this.db.exchangeCodeForToken(e));
    /**
     * OpenID Discovery path for use with tools like
     * expo-auth-session that use auto-discovery of
     * OAuth parameters.
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *   const discovery = useAutoDiscovery(
     *     db.auth.issuerURI()
     *   );
     */
    p(this, "issuerURI", () => this.db.issuerURI());
    /**
     * Sign out the current user
     */
    p(this, "signOut", (e = { invalidateToken: !0 }) => this.db.signOut(e));
    this.db = e;
  }
}
class ru {
  constructor(e) {
    p(this, "db");
    /**
     * Uploads file at the provided path.
     *
     * @see https://instantdb.com/docs/storage
     * @example
     *   const [file] = e.target.files; // result of file input
     *   const data = await db.storage.uploadFile('photos/demo.png', file);
     */
    p(this, "uploadFile", (e, n, r = {}) => this.db.uploadFile(e, n, r));
    /**
     * Deletes a file by path name.
     *
     * @see https://instantdb.com/docs/storage
     * @example
     *   await db.storage.delete('photos/demo.png');
     */
    p(this, "delete", (e) => this.db.deleteFile(e));
    // Deprecated Storage API (Jan 2025)
    // ---------------------------------
    /**
     * @deprecated. Use `db.storage.uploadFile` instead
     * remove in the future.
     */
    p(this, "upload", (e, n) => this.db.upload(e, n));
    /**
     * @deprecated Use `db.storage.uploadFile` instead
     */
    p(this, "put", this.upload);
    /**
     * @deprecated. getDownloadUrl will be removed in the future.
     * Use `useQuery` instead to query and fetch for valid urls
     *
     * db.useQuery({
     *   $files: {
     *     $: {
     *       where: {
     *         path: "moop.png"
     *       }
     *     }
     *   }
     * })
     */
    p(this, "getDownloadUrl", (e) => this.db.getDownloadUrl(e));
    this.db = e;
  }
}
function su(t) {
  return JSON.parse(JSON.stringify(t));
}
class iu {
  constructor(e) {
    p(this, "_reactor");
    p(this, "auth");
    p(this, "storage");
    p(this, "tx", Kn());
    this._reactor = e, this.auth = new nu(this._reactor), this.storage = new ru(this._reactor);
  }
  /**
   * Use this to write data! You can create, update, delete, and link objects
   *
   * @see https://instantdb.com/docs/instaml
   *
   * @example
   *   // Create a new object in the `goals` namespace
   *   const goalId = id();
   *   db.transact(db.tx.goals[goalId].update({title: "Get fit"}))
   *
   *   // Update the title
   *   db.transact(db.tx.goals[goalId].update({title: "Get super fit"}))
   *
   *   // Delete it
   *   db.transact(db.tx.goals[goalId].delete())
   *
   *   // Or create an association:
   *   todoId = id();
   *   db.transact([
   *    db.tx.todos[todoId].update({ title: 'Go on a run' }),
   *    db.tx.goals[goalId].link({todos: todoId}),
   *  ])
   */
  transact(e) {
    return this._reactor.pushTx(e);
  }
  getLocalId(e) {
    return this._reactor.getLocalId(e);
  }
  /**
   * Use this to query your data!
   *
   * @see https://instantdb.com/docs/instaql
   *
   * @example
   *  // listen to all goals
   *  db.subscribeQuery({ goals: {} }, (resp) => {
   *    console.log(resp.data.goals)
   *  })
   *
   *  // goals where the title is "Get Fit"
   *  db.subscribeQuery(
   *    { goals: { $: { where: { title: "Get Fit" } } } },
   *    (resp) => {
   *      console.log(resp.data.goals)
   *    }
   *  )
   *
   *  // all goals, _alongside_ their todos
   *  db.subscribeQuery({ goals: { todos: {} } }, (resp) => {
   *    console.log(resp.data.goals)
   *  });
   */
  subscribeQuery(e, n, r) {
    return this._reactor.subscribeQuery(e, n, r);
  }
  /**
   * Listen for the logged in state. This is useful
   * for deciding when to show a login screen.
   *
   * @see https://instantdb.com/docs/auth
   * @example
   *   const unsub = db.subscribeAuth((auth) => {
   *     if (auth.user) {
   *     console.log('logged in as', auth.user.email)
   *    } else {
   *      console.log('logged out')
   *    }
   *  })
   */
  subscribeAuth(e) {
    return this._reactor.subscribeAuth(e);
  }
  /**
   * One time query for the logged in state. This is useful
   * for scenarios where you want to know the current auth
   * state without subscribing to changes.
   *
   * @see https://instantdb.com/docs/auth
   * @example
   *   const user = await db.getAuth();
   *   console.log('logged in as', user.email)
   */
  getAuth() {
    return this._reactor.getAuth();
  }
  /**
   * Listen for connection status changes to Instant. This is useful
   * for building things like connectivity indicators
   *
   * @see https://www.instantdb.com/docs/patterns#connection-status
   * @example
   *   const unsub = db.subscribeConnectionStatus((status) => {
   *     const connectionState =
   *       status === 'connecting' || status === 'opened'
   *         ? 'authenticating'
   *       : status === 'authenticated'
   *         ? 'connected'
   *       : status === 'closed'
   *         ? 'closed'
   *       : status === 'errored'
   *         ? 'errored'
   *       : 'unexpected state';
   *
   *     console.log('Connection status:', connectionState);
   *   });
   */
  subscribeConnectionStatus(e) {
    return this._reactor.subscribeConnectionStatus(e);
  }
  /**
   * Join a room to publish and subscribe to topics and presence.
   *
   * @see https://instantdb.com/docs/presence-and-topics
   * @example
   * // init
   * const db = init();
   * const room = db.joinRoom(roomType, roomId);
   * // usage
   * const unsubscribeTopic = room.subscribeTopic("foo", console.log);
   * const unsubscribePresence = room.subscribePresence({}, console.log);
   * room.publishTopic("hello", { message: "hello world!" });
   * room.publishPresence({ name: "joe" });
   * // later
   * unsubscribePresence();
   * unsubscribeTopic();
   * room.leaveRoom();
   */
  joinRoom(e = "_defaultRoomType", n = "_defaultRoomId", r) {
    return {
      leaveRoom: this._reactor.joinRoom(n, r == null ? void 0 : r.initialPresence),
      subscribeTopic: (i, o) => this._reactor.subscribeTopic(n, i, o),
      subscribePresence: (i, o) => this._reactor.subscribePresence(e, n, i, o),
      publishTopic: (i, o) => this._reactor.publishTopic({ roomType: e, roomId: n, topic: i, data: o }),
      publishPresence: (i) => this._reactor.publishPresence(e, n, i),
      getPresence: (i) => this._reactor.getPresence(e, n, i)
    };
  }
  shutdown() {
    delete Tn[wn(this._reactor.config)], this._reactor.shutdown();
  }
  /**
   * Use this for one-off queries.
   * Returns local data if available, otherwise fetches from the server.
   * Because we want to avoid stale data, this method will throw an error
   * if the user is offline or there is no active connection to the server.
   *
   * @see https://instantdb.com/docs/instaql
   *
   * @example
   *
   *  const resp = await db.queryOnce({ goals: {} });
   *  console.log(resp.data.goals)
   */
  queryOnce(e, n) {
    return this._reactor.queryOnce(e, n);
  }
  /**
   * @deprecated This is an experimental function that is not yet ready for production use.
   * Use this function to sync an entire namespace.
   * It has many limitations that will be removed in the future:
   * 1. Must be used with an admin token
   * 2. Does not support permissions
   * 3. Does not support where clauses
   * 4. Does not support links
   * It also does not support multiple top-level namespaces. For example,
   *  {posts: {}, users: {}} is invalid. Only `posts` or `users` is allowed, but not both.
   */
  _syncTableExperimental(e, n) {
    return this._reactor.subscribeTable(e, n);
  }
}
function Br(t) {
  if (!t)
    return "0";
  const e = Vr.get(t);
  if (e)
    return e;
  const n = q(t);
  return Vr.set(t, n), n;
}
function ou(t, e) {
  return Br(t._reactor.config.schema) !== Br(e);
}
function au(t, e, n, r, s) {
  var u;
  const i = {
    ...t,
    appId: (u = t.appId) == null ? void 0 : u.trim(),
    useDateObjects: t.useDateObjects ?? !1
  }, o = Tn[wn(i)];
  if (o)
    return ou(o, i.schema) && o._reactor.updateSchema(i.schema), o;
  const a = new $c({
    ...Xc,
    ...i,
    cardinalityInference: !!i.schema
  }, e || Ms, n || js, { ...r || {}, "@instantdb/core": Wn }, s), c = new iu(a);
  return Tn[wn(i)] = c, cu(i.appId, i.devtool), c;
}
function cu(t, e) {
  if (typeof window > "u" || typeof window.location > "u" || typeof document > "u" || typeof e == "boolean" && !e)
    return;
  const n = {
    position: "bottom-right",
    allowedHosts: ["localhost"],
    ...typeof e == "object" ? e : {}
  };
  n.allowedHosts.includes(window.location.hostname) && Vc(t, n);
}
var mn = { exports: {} }, Be = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Gr;
function uu() {
  if (Gr) return Be;
  Gr = 1;
  var t = ts, e = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, s = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(a, c, u) {
    var l, f = {}, h = null, y = null;
    u !== void 0 && (h = "" + u), c.key !== void 0 && (h = "" + c.key), c.ref !== void 0 && (y = c.ref);
    for (l in c) r.call(c, l) && !i.hasOwnProperty(l) && (f[l] = c[l]);
    if (a && a.defaultProps) for (l in c = a.defaultProps, c) f[l] === void 0 && (f[l] = c[l]);
    return { $$typeof: e, type: a, key: h, ref: y, props: f, _owner: s.current };
  }
  return Be.Fragment = n, Be.jsx = o, Be.jsxs = o, Be;
}
var Ge = {}, Qr;
function lu() {
  if (Qr) return Ge;
  Qr = 1;
  var t = {};
  /**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return t.NODE_ENV !== "production" && function() {
    var e = ts, n = Symbol.for("react.element"), r = Symbol.for("react.portal"), s = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), c = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), h = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), b = Symbol.for("react.offscreen"), g = Symbol.iterator, w = "@@iterator";
    function m(d) {
      if (d === null || typeof d != "object")
        return null;
      var T = g && d[g] || d[w];
      return typeof T == "function" ? T : null;
    }
    var _ = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function S(d) {
      {
        for (var T = arguments.length, v = new Array(T > 1 ? T - 1 : 0), A = 1; A < T; A++)
          v[A - 1] = arguments[A];
        O("error", d, v);
      }
    }
    function O(d, T, v) {
      {
        var A = _.ReactDebugCurrentFrame, M = A.getStackAddendum();
        M !== "" && (T += "%s", v = v.concat([M]));
        var R = v.map(function(I) {
          return String(I);
        });
        R.unshift("Warning: " + T), Function.prototype.apply.call(console[d], console, R);
      }
    }
    var E = !1, j = !1, L = !1, B = !1, qe = !1, ut;
    ut = Symbol.for("react.module.reference");
    function Ut(d) {
      return !!(typeof d == "string" || typeof d == "function" || d === s || d === o || qe || d === i || d === l || d === f || B || d === b || E || j || L || typeof d == "object" && d !== null && (d.$$typeof === y || d.$$typeof === h || d.$$typeof === a || d.$$typeof === c || d.$$typeof === u || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      d.$$typeof === ut || d.getModuleId !== void 0));
    }
    function Lt(d, T, v) {
      var A = d.displayName;
      if (A)
        return A;
      var M = T.displayName || T.name || "";
      return M !== "" ? v + "(" + M + ")" : v;
    }
    function We(d) {
      return d.displayName || "Context";
    }
    function ie(d) {
      if (d == null)
        return null;
      if (typeof d.tag == "number" && S("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof d == "function")
        return d.displayName || d.name || null;
      if (typeof d == "string")
        return d;
      switch (d) {
        case s:
          return "Fragment";
        case r:
          return "Portal";
        case o:
          return "Profiler";
        case i:
          return "StrictMode";
        case l:
          return "Suspense";
        case f:
          return "SuspenseList";
      }
      if (typeof d == "object")
        switch (d.$$typeof) {
          case c:
            var T = d;
            return We(T) + ".Consumer";
          case a:
            var v = d;
            return We(v._context) + ".Provider";
          case u:
            return Lt(d, d.render, "ForwardRef");
          case h:
            var A = d.displayName || null;
            return A !== null ? A : ie(d.type) || "Memo";
          case y: {
            var M = d, R = M._payload, I = M._init;
            try {
              return ie(I(R));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var le = Object.assign, be = 0, Vn, Bn, Gn, Qn, Hn, Jn, Yn;
    function Zn() {
    }
    Zn.__reactDisabledLog = !0;
    function Vs() {
      {
        if (be === 0) {
          Vn = console.log, Bn = console.info, Gn = console.warn, Qn = console.error, Hn = console.group, Jn = console.groupCollapsed, Yn = console.groupEnd;
          var d = {
            configurable: !0,
            enumerable: !0,
            value: Zn,
            writable: !0
          };
          Object.defineProperties(console, {
            info: d,
            log: d,
            warn: d,
            error: d,
            group: d,
            groupCollapsed: d,
            groupEnd: d
          });
        }
        be++;
      }
    }
    function Bs() {
      {
        if (be--, be === 0) {
          var d = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: le({}, d, {
              value: Vn
            }),
            info: le({}, d, {
              value: Bn
            }),
            warn: le({}, d, {
              value: Gn
            }),
            error: le({}, d, {
              value: Qn
            }),
            group: le({}, d, {
              value: Hn
            }),
            groupCollapsed: le({}, d, {
              value: Jn
            }),
            groupEnd: le({}, d, {
              value: Yn
            })
          });
        }
        be < 0 && S("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Ft = _.ReactCurrentDispatcher, Nt;
    function lt(d, T, v) {
      {
        if (Nt === void 0)
          try {
            throw Error();
          } catch (M) {
            var A = M.stack.trim().match(/\n( *(at )?)/);
            Nt = A && A[1] || "";
          }
        return `
` + Nt + d;
      }
    }
    var Kt = !1, ft;
    {
      var Gs = typeof WeakMap == "function" ? WeakMap : Map;
      ft = new Gs();
    }
    function Xn(d, T) {
      if (!d || Kt)
        return "";
      {
        var v = ft.get(d);
        if (v !== void 0)
          return v;
      }
      var A;
      Kt = !0;
      var M = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var R;
      R = Ft.current, Ft.current = null, Vs();
      try {
        if (T) {
          var I = function() {
            throw Error();
          };
          if (Object.defineProperty(I.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(I, []);
            } catch (J) {
              A = J;
            }
            Reflect.construct(d, [], I);
          } else {
            try {
              I.call();
            } catch (J) {
              A = J;
            }
            d.call(I.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (J) {
            A = J;
          }
          d();
        }
      } catch (J) {
        if (J && A && typeof J.stack == "string") {
          for (var C = J.stack.split(`
`), G = A.stack.split(`
`), D = C.length - 1, F = G.length - 1; D >= 1 && F >= 0 && C[D] !== G[F]; )
            F--;
          for (; D >= 1 && F >= 0; D--, F--)
            if (C[D] !== G[F]) {
              if (D !== 1 || F !== 1)
                do
                  if (D--, F--, F < 0 || C[D] !== G[F]) {
                    var re = `
` + C[D].replace(" at new ", " at ");
                    return d.displayName && re.includes("<anonymous>") && (re = re.replace("<anonymous>", d.displayName)), typeof d == "function" && ft.set(d, re), re;
                  }
                while (D >= 1 && F >= 0);
              break;
            }
        }
      } finally {
        Kt = !1, Ft.current = R, Bs(), Error.prepareStackTrace = M;
      }
      var Ie = d ? d.displayName || d.name : "", we = Ie ? lt(Ie) : "";
      return typeof d == "function" && ft.set(d, we), we;
    }
    function Qs(d, T, v) {
      return Xn(d, !1);
    }
    function Hs(d) {
      var T = d.prototype;
      return !!(T && T.isReactComponent);
    }
    function dt(d, T, v) {
      if (d == null)
        return "";
      if (typeof d == "function")
        return Xn(d, Hs(d));
      if (typeof d == "string")
        return lt(d);
      switch (d) {
        case l:
          return lt("Suspense");
        case f:
          return lt("SuspenseList");
      }
      if (typeof d == "object")
        switch (d.$$typeof) {
          case u:
            return Qs(d.render);
          case h:
            return dt(d.type, T, v);
          case y: {
            var A = d, M = A._payload, R = A._init;
            try {
              return dt(R(M), T, v);
            } catch {
            }
          }
        }
      return "";
    }
    var ze = Object.prototype.hasOwnProperty, er = {}, tr = _.ReactDebugCurrentFrame;
    function ht(d) {
      if (d) {
        var T = d._owner, v = dt(d.type, d._source, T ? T.type : null);
        tr.setExtraStackFrame(v);
      } else
        tr.setExtraStackFrame(null);
    }
    function Js(d, T, v, A, M) {
      {
        var R = Function.call.bind(ze);
        for (var I in d)
          if (R(d, I)) {
            var C = void 0;
            try {
              if (typeof d[I] != "function") {
                var G = Error((A || "React class") + ": " + v + " type `" + I + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof d[I] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw G.name = "Invariant Violation", G;
              }
              C = d[I](T, I, A, v, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (D) {
              C = D;
            }
            C && !(C instanceof Error) && (ht(M), S("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", A || "React class", v, I, typeof C), ht(null)), C instanceof Error && !(C.message in er) && (er[C.message] = !0, ht(M), S("Failed %s type: %s", v, C.message), ht(null));
          }
      }
    }
    var Ys = Array.isArray;
    function qt(d) {
      return Ys(d);
    }
    function Zs(d) {
      {
        var T = typeof Symbol == "function" && Symbol.toStringTag, v = T && d[Symbol.toStringTag] || d.constructor.name || "Object";
        return v;
      }
    }
    function Xs(d) {
      try {
        return nr(d), !1;
      } catch {
        return !0;
      }
    }
    function nr(d) {
      return "" + d;
    }
    function rr(d) {
      if (Xs(d))
        return S("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Zs(d)), nr(d);
    }
    var sr = _.ReactCurrentOwner, ei = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, ir, or;
    function ti(d) {
      if (ze.call(d, "ref")) {
        var T = Object.getOwnPropertyDescriptor(d, "ref").get;
        if (T && T.isReactWarning)
          return !1;
      }
      return d.ref !== void 0;
    }
    function ni(d) {
      if (ze.call(d, "key")) {
        var T = Object.getOwnPropertyDescriptor(d, "key").get;
        if (T && T.isReactWarning)
          return !1;
      }
      return d.key !== void 0;
    }
    function ri(d, T) {
      typeof d.ref == "string" && sr.current;
    }
    function si(d, T) {
      {
        var v = function() {
          ir || (ir = !0, S("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", T));
        };
        v.isReactWarning = !0, Object.defineProperty(d, "key", {
          get: v,
          configurable: !0
        });
      }
    }
    function ii(d, T) {
      {
        var v = function() {
          or || (or = !0, S("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", T));
        };
        v.isReactWarning = !0, Object.defineProperty(d, "ref", {
          get: v,
          configurable: !0
        });
      }
    }
    var oi = function(d, T, v, A, M, R, I) {
      var C = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: n,
        // Built-in properties that belong on the element
        type: d,
        key: T,
        ref: v,
        props: I,
        // Record the component responsible for creating this element.
        _owner: R
      };
      return C._store = {}, Object.defineProperty(C._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(C, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: A
      }), Object.defineProperty(C, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: M
      }), Object.freeze && (Object.freeze(C.props), Object.freeze(C)), C;
    };
    function ai(d, T, v, A, M) {
      {
        var R, I = {}, C = null, G = null;
        v !== void 0 && (rr(v), C = "" + v), ni(T) && (rr(T.key), C = "" + T.key), ti(T) && (G = T.ref, ri(T, M));
        for (R in T)
          ze.call(T, R) && !ei.hasOwnProperty(R) && (I[R] = T[R]);
        if (d && d.defaultProps) {
          var D = d.defaultProps;
          for (R in D)
            I[R] === void 0 && (I[R] = D[R]);
        }
        if (C || G) {
          var F = typeof d == "function" ? d.displayName || d.name || "Unknown" : d;
          C && si(I, F), G && ii(I, F);
        }
        return oi(d, C, G, M, A, sr.current, I);
      }
    }
    var Wt = _.ReactCurrentOwner, ar = _.ReactDebugCurrentFrame;
    function Pe(d) {
      if (d) {
        var T = d._owner, v = dt(d.type, d._source, T ? T.type : null);
        ar.setExtraStackFrame(v);
      } else
        ar.setExtraStackFrame(null);
    }
    var zt;
    zt = !1;
    function Vt(d) {
      return typeof d == "object" && d !== null && d.$$typeof === n;
    }
    function cr() {
      {
        if (Wt.current) {
          var d = ie(Wt.current.type);
          if (d)
            return `

Check the render method of \`` + d + "`.";
        }
        return "";
      }
    }
    function ci(d) {
      return "";
    }
    var ur = {};
    function ui(d) {
      {
        var T = cr();
        if (!T) {
          var v = typeof d == "string" ? d : d.displayName || d.name;
          v && (T = `

Check the top-level render call using <` + v + ">.");
        }
        return T;
      }
    }
    function lr(d, T) {
      {
        if (!d._store || d._store.validated || d.key != null)
          return;
        d._store.validated = !0;
        var v = ui(T);
        if (ur[v])
          return;
        ur[v] = !0;
        var A = "";
        d && d._owner && d._owner !== Wt.current && (A = " It was passed a child from " + ie(d._owner.type) + "."), Pe(d), S('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', v, A), Pe(null);
      }
    }
    function fr(d, T) {
      {
        if (typeof d != "object")
          return;
        if (qt(d))
          for (var v = 0; v < d.length; v++) {
            var A = d[v];
            Vt(A) && lr(A, T);
          }
        else if (Vt(d))
          d._store && (d._store.validated = !0);
        else if (d) {
          var M = m(d);
          if (typeof M == "function" && M !== d.entries)
            for (var R = M.call(d), I; !(I = R.next()).done; )
              Vt(I.value) && lr(I.value, T);
        }
      }
    }
    function li(d) {
      {
        var T = d.type;
        if (T == null || typeof T == "string")
          return;
        var v;
        if (typeof T == "function")
          v = T.propTypes;
        else if (typeof T == "object" && (T.$$typeof === u || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        T.$$typeof === h))
          v = T.propTypes;
        else
          return;
        if (v) {
          var A = ie(T);
          Js(v, d.props, "prop", A, d);
        } else if (T.PropTypes !== void 0 && !zt) {
          zt = !0;
          var M = ie(T);
          S("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", M || "Unknown");
        }
        typeof T.getDefaultProps == "function" && !T.getDefaultProps.isReactClassApproved && S("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function fi(d) {
      {
        for (var T = Object.keys(d.props), v = 0; v < T.length; v++) {
          var A = T[v];
          if (A !== "children" && A !== "key") {
            Pe(d), S("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", A), Pe(null);
            break;
          }
        }
        d.ref !== null && (Pe(d), S("Invalid attribute `ref` supplied to `React.Fragment`."), Pe(null));
      }
    }
    var dr = {};
    function hr(d, T, v, A, M, R) {
      {
        var I = Ut(d);
        if (!I) {
          var C = "";
          (d === void 0 || typeof d == "object" && d !== null && Object.keys(d).length === 0) && (C += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var G = ci();
          G ? C += G : C += cr();
          var D;
          d === null ? D = "null" : qt(d) ? D = "array" : d !== void 0 && d.$$typeof === n ? (D = "<" + (ie(d.type) || "Unknown") + " />", C = " Did you accidentally export a JSX literal instead of a component?") : D = typeof d, S("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", D, C);
        }
        var F = ai(d, T, v, M, R);
        if (F == null)
          return F;
        if (I) {
          var re = T.children;
          if (re !== void 0)
            if (A)
              if (qt(re)) {
                for (var Ie = 0; Ie < re.length; Ie++)
                  fr(re[Ie], d);
                Object.freeze && Object.freeze(re);
              } else
                S("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              fr(re, d);
        }
        if (ze.call(T, "key")) {
          var we = ie(d), J = Object.keys(T).filter(function(gi) {
            return gi !== "key";
          }), Bt = J.length > 0 ? "{key: someKey, " + J.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!dr[we + Bt]) {
            var bi = J.length > 0 ? "{" + J.join(": ..., ") + ": ...}" : "{}";
            S(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Bt, we, bi, we), dr[we + Bt] = !0;
          }
        }
        return d === s ? fi(F) : li(F), F;
      }
    }
    function di(d, T, v) {
      return hr(d, T, v, !0);
    }
    function hi(d, T, v) {
      return hr(d, T, v, !1);
    }
    var pi = hi, yi = di;
    Ge.Fragment = s, Ge.jsx = pi, Ge.jsxs = yi;
  }(), Ge;
}
var fu = {};
fu.NODE_ENV === "production" ? mn.exports = uu() : mn.exports = lu();
var V = mn.exports;
const du = {
  isLoading: !0,
  data: void 0,
  pageInfo: void 0,
  error: void 0
};
function Hr(t) {
  return {
    isLoading: !t,
    data: void 0,
    pageInfo: void 0,
    error: void 0,
    ...t || {}
  };
}
function hu(t, e, n) {
  e && n && "ruleParams" in n && (e = { $$ruleParams: n.ruleParams, ...e });
  const r = e ? su(e) : null, s = q(r), i = it(Hr(t._reactor.getPreviousResult(r))), o = _e(
    (c) => (i.current = Hr(t._reactor.getPreviousResult(r)), c(), r ? t.subscribeQuery(r, (l) => {
      i.current = {
        isLoading: !l,
        // @ts-expect-error: ts thinks this will always be overwritten
        data: void 0,
        // @ts-expect-error: ts thinks this will always be overwritten
        pageInfo: void 0,
        // @ts-expect-error: ts thinks this will always be overwritten
        error: void 0,
        ...l
      }, c();
    }) : () => {
    }),
    // Build a new subscribe function if the query changes
    [s]
  );
  return { state: tn(o, () => i.current, () => du), query: r };
}
function pu() {
  const t = it(null);
  Oe(() => {
    n();
  }, []);
  function e(r, s) {
    n(), t.current = setTimeout(s, r);
  }
  function n() {
    t.current && clearTimeout(t.current);
  }
  return { set: e, clear: n };
}
const yu = 1e3;
function bu(t, e, n) {
  const r = it(n);
  r.current = n, Oe(() => t.core._reactor.subscribeTopic(t.id, e, (i, o) => {
    r.current(i, o);
  }), [t.id, e]);
}
function gu(t, e) {
  return Oe(() => t.core._reactor.joinRoom(t.id), [t.id]), _e((r) => {
    t.core._reactor.publishTopic({
      roomType: t.type,
      roomId: t.id,
      topic: e,
      data: r
    });
  }, [t.id, e]);
}
function _u(t, e = {}) {
  var o, a;
  const [n, r] = ns(() => t.core._reactor.getPresence(t.type, t.id, e) ?? {
    peers: {},
    isLoading: !0
  });
  Oe(() => t.core._reactor.subscribePresence(t.type, t.id, e, (u) => {
    r(u);
  }), [t.id, e.user, (o = e.peers) == null ? void 0 : o.join(), (a = e.keys) == null ? void 0 : a.join()]);
  const s = _e((c) => {
    t.core._reactor.publishPresence(t.type, t.id, c);
  }, [t.type, t.id]);
  return nn(() => ({
    ...n,
    publishPresence: s
  }), [n, s]);
}
function wu(t, e, n) {
  Oe(() => t.core._reactor.joinRoom(t.id, e), [t.id]), Oe(() => t.core._reactor.publishPresence(t.type, t.id, e), [t.type, t.id, n ?? JSON.stringify(e)]);
}
function Tu(t, e, n = {}) {
  const r = pu(), s = me.usePresence(t, {
    keys: [e]
  }), i = nn(() => {
    const l = t._core._reactor.getPresence(t.type, t.id);
    return n != null && n.writeOnly ? [] : Object.values((l == null ? void 0 : l.peers) ?? {}).filter((f) => f[e] === !0);
  }, [n == null ? void 0 : n.writeOnly, s]), o = _e((l) => {
    t.core._reactor.publishPresence(t.type, t.id, {
      [e]: l
    }), l && ((n == null ? void 0 : n.timeout) === null || (n == null ? void 0 : n.timeout) === 0 || r.set((n == null ? void 0 : n.timeout) ?? yu, () => {
      t.core._reactor.publishPresence(t.type, t.id, {
        [e]: null
      });
    }));
  }, [t.type, t.id, e, n == null ? void 0 : n.timeout, r]), a = _e((l) => {
    const h = !((n == null ? void 0 : n.stopOnEnter) && l.key === "Enter");
    o(h);
  }, [n.stopOnEnter, o]), c = _e(() => {
    o(!1);
  }, [o]), u = nn(() => ({ onKeyDown: a, onBlur: c }), [a, c]);
  return {
    active: i,
    setActive: o,
    inputProps: u
  };
}
const me = {
  useTopicEffect: bu,
  usePublishTopic: gu,
  usePresence: _u,
  useSyncPresence: wu,
  useTypingIndicator: Tu
};
class mu {
  constructor(e, n, r) {
    p(this, "core");
    /** @deprecated use `core` instead */
    p(this, "_core");
    p(this, "type");
    p(this, "id");
    /**
     * @deprecated
     * `db.room(...).useTopicEffect` is deprecated. You can replace it with `db.rooms.useTopicEffect`.
     *
     * @example
     *
     * // Before
     * const room = db.room('chat', 'room-id');
     * room.useTopicEffect('emoji', (message, peer) => {  });
     *
     * // After
     * const room = db.room('chat', 'room-id');
     * db.rooms.useTopicEffect(room, 'emoji', (message, peer) => {  });
     */
    p(this, "useTopicEffect", (e, n) => {
      me.useTopicEffect(this, e, n);
    });
    /**
     * @deprecated
     * `db.room(...).usePublishTopic` is deprecated. You can replace it with `db.rooms.usePublishTopic`.
     *
     * @example
     *
     * // Before
     * const room = db.room('chat', 'room-id');
     * const publish = room.usePublishTopic('emoji');
     *
     * // After
     * const room = db.room('chat', 'room-id');
     * const publish = db.rooms.usePublishTopic(room, 'emoji');
     */
    p(this, "usePublishTopic", (e) => me.usePublishTopic(this, e));
    /**
     * @deprecated
     * `db.room(...).usePresence` is deprecated. You can replace it with `db.rooms.usePresence`.
     *
     * @example
     *
     * // Before
     * const room = db.room('chat', 'room-id');
     * const { peers } = room.usePresence({ keys: ["name", "avatar"] });
     *
     * // After
     * const room = db.room('chat', 'room-id');
     * const { peers } = db.rooms.usePresence(room, { keys: ["name", "avatar"] });
     */
    p(this, "usePresence", (e = {}) => me.usePresence(this, e));
    /**
     * @deprecated
     * `db.room(...).useSyncPresence` is deprecated. You can replace it with `db.rooms.useSyncPresence`.
     *
     * @example
     *
     * // Before
     * const room = db.room('chat', 'room-id');
     * room.useSyncPresence(room, { nickname });
     *
     * // After
     * const room = db.room('chat', 'room-id');
     * db.rooms.useSyncPresence(room, { nickname });
     */
    p(this, "useSyncPresence", (e, n) => me.useSyncPresence(this, e, n));
    /**
     * @deprecated
     * `db.room(...).useTypingIndicator` is deprecated. You can replace it with `db.rooms.useTypingIndicator`.
     *
     * @example
     *
     * // Before
     * const room = db.room('chat', 'room-id');
     * const typing = room.useTypingIndiactor(room, 'chat-input');
     *
     * // After
     * const room = db.room('chat', 'room-id');
     * const typing = db.rooms.useTypingIndiactor(room, 'chat-input');
     */
    p(this, "useTypingIndicator", (e, n = {}) => me.useTypingIndicator(this, e, n));
    this.core = e, this._core = this.core, this.type = n, this.id = r;
  }
}
const Su = {
  isLoading: !0,
  user: void 0,
  error: void 0
};
class vt {
  constructor(e, n) {
    p(this, "tx", Kn());
    p(this, "auth");
    p(this, "storage");
    p(this, "core");
    /** @deprecated use `core` instead */
    p(this, "_core");
    /**
     * Returns a unique ID for a given `name`. It's stored in local storage,
     * so you will get the same ID across sessions.
     *
     * This is useful for generating IDs that could identify a local device or user.
     *
     * @example
     *  const deviceId = await db.getLocalId('device');
     */
    p(this, "getLocalId", (e) => this.core.getLocalId(e));
    /**
     * A hook that returns a unique ID for a given `name`. localIds are
     * stored in local storage, so you will get the same ID across sessions.
     *
     * Initially returns `null`, and then loads the localId.
     *
     * @example
     * const deviceId = db.useLocalId('device');
     * if (!deviceId) return null; // loading
     * console.log('Device ID:', deviceId)
     */
    p(this, "useLocalId", (e) => {
      const [n, r] = ns(null);
      return Oe(() => {
        (async () => {
          const i = await this.getLocalId(e);
          r(i);
        })();
      }, [e]), n;
    });
    /**
     * Hooks for working with rooms
     *
     * @see https://instantdb.com/docs/presence-and-topics
     *
     * @example
     *  const room = db.room('chat', roomId);
     *  const { peers } = db.rooms.usePresence(room);
     *  const publish = db.rooms.usePublishTopic(room, 'emoji');
     *  // ...
     */
    p(this, "rooms", me);
    /**
     * Use this to write data! You can create, update, delete, and link objects
     *
     * @see https://instantdb.com/docs/instaml
     *
     * @example
     *   // Create a new object in the `goals` namespace
     *   const goalId = id();
     *   db.transact(db.tx.goals[goalId].update({title: "Get fit"}))
     *
     *   // Update the title
     *   db.transact(db.tx.goals[goalId].update({title: "Get super fit"}))
     *
     *   // Delete it
     *   db.transact(db.tx.goals[goalId].delete())
     *
     *   // Or create an association:
     *   todoId = id();
     *   db.transact([
     *    db.tx.todos[todoId].update({ title: 'Go on a run' }),
     *    db.tx.goals[goalId].link({todos: todoId}),
     *  ])
     */
    p(this, "transact", (e) => this.core.transact(e));
    /**
     * Use this to query your data!
     *
     * @see https://instantdb.com/docs/instaql
     *
     * @example
     *   // listen to all goals
     *   const { isLoading, error, data } = db.useQuery({ goals: {} });
     *
     *   // goals where the title is "Get Fit"
     *   const { isLoading, error, data } = db.useQuery({
     *     goals: { $: { where: { title: 'Get Fit' } } },
     *   });
     *
     *   // all goals, _alongside_ their todos
     *   const { isLoading, error, data } = db.useQuery({
     *     goals: { todos: {} },
     *   });
     *
     *   // skip if `user` is not logged in
     *   const { isLoading, error, data } = db.useQuery(
     *     auth.user ? { goals: {} } : null,
     *   );
     */
    p(this, "useQuery", (e, n) => hu(this.core, e, n).state);
    /**
     * Listen for the logged in state. This is useful
     * for deciding when to show a login screen.
     *
     * Check out the docs for an example `Login` component too!
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *  function App() {
     *    const { isLoading, user, error } = db.useAuth()
     *    if (isLoading) {
     *      return <div>Loading...</div>
     *    }
     *    if (error) {
     *      return <div>Uh oh! {error.message}</div>
     *    }
     *    if (user) {
     *      return <Main user={user} />
     *    }
     *    return <Login />
     *  }
     *
     */
    p(this, "useAuth", () => this._useAuth());
    /**
     * Subscribe to the currently logged in user.
     * If the user is not logged in, this hook with throw an Error.
     * You will want to protect any calls of this hook with a
     * <db.SignedIn> component, or your own logic based on db.useAuth()
     *
     * @see https://instantdb.com/docs/auth
     * @throws Error indicating user not signed in
     * @example
     *  function UserDisplay() {
     *    const user = db.useUser()
     *    return <div>Logged in as: {user.email}</div>
     *  }
     *
     *  <db.SignedIn>
     *    <UserDisplay />
     *  </db.SignedIn>
     *
     */
    p(this, "useUser", () => {
      const { user: e } = this.useAuth();
      if (!e)
        throw new Ne("useUser must be used within an auth-protected route");
      return e;
    });
    /**
     * Listen for connection status changes to Instant. Use this for things like
     * showing connection state to users
     *
     * @see https://www.instantdb.com/docs/patterns#connection-status
     * @example
     *  function App() {
     *    const status = db.useConnectionStatus()
     *    const connectionState =
     *      status === 'connecting' || status === 'opened'
     *        ? 'authenticating'
     *      : status === 'authenticated'
     *        ? 'connected'
     *      : status === 'closed'
     *        ? 'closed'
     *      : status === 'errored'
     *        ? 'errored'
     *      : 'unexpected state';
     *
     *    return <div>Connection state: {connectionState}</div>
     *  }
     */
    p(this, "useConnectionStatus", () => {
      const e = it(this.core._reactor.status), n = _e((s) => this.core.subscribeConnectionStatus((o) => {
        o !== e.current && (e.current = o, s());
      }), []);
      return tn(
        n,
        () => e.current,
        // For SSR, always return 'connecting' as the initial state
        () => "connecting"
      );
    });
    /**
     * Use this for one-off queries.
     * Returns local data if available, otherwise fetches from the server.
     * Because we want to avoid stale data, this method will throw an error
     * if the user is offline or there is no active connection to the server.
     *
     * @see https://instantdb.com/docs/instaql
     *
     * @example
     *
     *  const resp = await db.queryOnce({ goals: {} });
     *  console.log(resp.data.goals)
     */
    p(this, "queryOnce", (e, n) => this.core.queryOnce(e, n));
    /**
     * Only render children if the user is signed in.
     * @see https://instantdb.com/docs/auth
     *
     * @example
     *  <db.SignedIn>
     *    <MyComponent />
     *  </db.SignedIn>
     *
     */
    p(this, "SignedIn", ({ children: e }) => {
      const n = this.useAuth();
      return n.isLoading || n.error || !n.user ? null : V.jsx(V.Fragment, { children: e });
    });
    /**
     * Only render children if the user is signed out.
     * @see https://instantdb.com/docs/auth
     *
     * @example
     *  <db.SignedOut>
     *    <MyComponent />
     *  </db.SignedOut>
     *
     */
    p(this, "SignedOut", ({ children: e }) => {
      const n = this.useAuth();
      return n.isLoading || n.error || n.user ? null : V.jsx(V.Fragment, { children: e });
    });
    this.core = au(
      e,
      // @ts-expect-error because TS can't resolve subclass statics
      e.Store || this.constructor.Store,
      // @ts-expect-error because TS can't resolve subclass statics
      this.constructor.NetworkListener,
      n,
      // @ts-expect-error because TS can't resolve subclass statics
      this.constructor.EventSourceImpl
    ), this._core = this.core, this.auth = this.core.auth, this.storage = this.core.storage;
  }
  /**
   * Obtain a handle to a room, which allows you to listen to topics and presence data
   *
   * If you don't provide a `type` or `id`, Instant will default to `_defaultRoomType` and `_defaultRoomId`
   * as the room type and id, respectively.
   *
   * @see https://instantdb.com/docs/presence-and-topics
   *
   * @example
   *  const room = db.room('chat', roomId);
   *  const { peers } = db.rooms.usePresence(room);
   */
  room(e = "_defaultRoomType", n = "_defaultRoomId") {
    return new mu(this.core, e, n);
  }
  _useAuth() {
    const e = it(this.core._reactor._currentUserCached), n = _e((s) => this.core.subscribeAuth((o) => {
      e.current = { isLoading: !1, ...o }, s();
    }), []);
    return tn(n, () => e.current, () => Su);
  }
  /**
   * One time query for the logged in state. This is useful
   * for scenarios where you want to know the current auth
   * state without subscribing to changes.
   *
   * @see https://instantdb.com/docs/auth
   * @example
   *   const user = await db.getAuth();
   *   console.log('logged in as', user.email)
   */
  getAuth() {
    return this.core.getAuth();
  }
}
p(vt, "Store"), p(vt, "NetworkListener"), p(vt, "EventSourceImpl");
class Jr extends Error {
  constructor(e, n) {
    super(e), this.name = "ParseError", this.type = n.type, this.field = n.field, this.value = n.value, this.line = n.line;
  }
}
function en(t) {
}
function vu(t) {
  if (typeof t == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent: e = en, onError: n = en, onRetry: r = en, onComment: s } = t;
  let i = "", o = !0, a, c = "", u = "";
  function l(g) {
    const w = o ? g.replace(/^\xEF\xBB\xBF/, "") : g, [m, _] = Eu(`${i}${w}`);
    for (const S of m)
      f(S);
    i = _, o = !1;
  }
  function f(g) {
    if (g === "") {
      y();
      return;
    }
    if (g.startsWith(":")) {
      s && s(g.slice(g.startsWith(": ") ? 2 : 1));
      return;
    }
    const w = g.indexOf(":");
    if (w !== -1) {
      const m = g.slice(0, w), _ = g[w + 1] === " " ? 2 : 1, S = g.slice(w + _);
      h(m, S, g);
      return;
    }
    h(g, "", g);
  }
  function h(g, w, m) {
    switch (g) {
      case "event":
        u = w;
        break;
      case "data":
        c = `${c}${w}
`;
        break;
      case "id":
        a = w.includes("\0") ? void 0 : w;
        break;
      case "retry":
        /^\d+$/.test(w) ? r(parseInt(w, 10)) : n(
          new Jr(`Invalid \`retry\` value: "${w}"`, {
            type: "invalid-retry",
            value: w,
            line: m
          })
        );
        break;
      default:
        n(
          new Jr(
            `Unknown field "${g.length > 20 ? `${g.slice(0, 20)}` : g}"`,
            { type: "unknown-field", field: g, value: w, line: m }
          )
        );
        break;
    }
  }
  function y() {
    c.length > 0 && e({
      id: a,
      event: u || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: c.endsWith(`
`) ? c.slice(0, -1) : c
    }), a = void 0, c = "", u = "";
  }
  function b(g = {}) {
    i && g.consume && f(i), o = !0, a = void 0, c = "", u = "", i = "";
  }
  return { feed: l, reset: b };
}
function Eu(t) {
  const e = [];
  let n = "", r = 0;
  for (; r < t.length; ) {
    const s = t.indexOf("\r", r), i = t.indexOf(`
`, r);
    let o = -1;
    if (s !== -1 && i !== -1 ? o = Math.min(s, i) : s !== -1 ? o = s : i !== -1 && (o = i), o === -1) {
      n = t.slice(r);
      break;
    } else {
      const a = t.slice(r, o);
      e.push(a), r = o + 1, t[r - 1] === "\r" && t[r] === `
` && r++;
    }
  }
  return [e, n];
}
class Yr extends Event {
  /**
   * Constructs a new `ErrorEvent` instance. This is typically not called directly,
   * but rather emitted by the `EventSource` object when an error occurs.
   *
   * @param type - The type of the event (should be "error")
   * @param errorEventInitDict - Optional properties to include in the error event
   */
  constructor(e, n) {
    var r, s;
    super(e), this.code = (r = n == null ? void 0 : n.code) != null ? r : void 0, this.message = (s = n == null ? void 0 : n.message) != null ? s : void 0;
  }
  /**
   * Node.js "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Node.js when you `console.log` an instance of this class.
   *
   * @param _depth - The current depth
   * @param options - The options passed to `util.inspect`
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @returns A string representation of the error
   */
  [Symbol.for("nodejs.util.inspect.custom")](e, n, r) {
    return r(Zr(this), n);
  }
  /**
   * Deno "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Deno when you `console.log` an instance of this class.
   *
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @param options - The options passed to `Deno.inspect`
   * @returns A string representation of the error
   */
  [Symbol.for("Deno.customInspect")](e, n) {
    return e(Zr(this), n);
  }
}
function Ou(t) {
  const e = globalThis.DOMException;
  return typeof e == "function" ? new e(t, "SyntaxError") : new SyntaxError(t);
}
function Sn(t) {
  return t instanceof Error ? "errors" in t && Array.isArray(t.errors) ? t.errors.map(Sn).join(", ") : "cause" in t && t.cause instanceof Error ? `${t}: ${Sn(t.cause)}` : t.message : `${t}`;
}
function Zr(t) {
  return {
    type: t.type,
    message: t.message,
    code: t.code,
    defaultPrevented: t.defaultPrevented,
    cancelable: t.cancelable,
    timeStamp: t.timeStamp
  };
}
var Ws = (t) => {
  throw TypeError(t);
}, zn = (t, e, n) => e.has(t) || Ws("Cannot " + n), k = (t, e, n) => (zn(t, e, "read from private field"), n ? n.call(t) : e.get(t)), K = (t, e, n) => e.has(t) ? Ws("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, n), $ = (t, e, n, r) => (zn(t, e, "write to private field"), e.set(t, n), n), he = (t, e, n) => (zn(t, e, "access private method"), n), Y, Se, je, Et, Mt, rt, $e, st, ge, Re, Ue, xe, Ze, oe, vn, En, On, Xr, An, kn, Xe, Cn, Pn;
class Ot extends EventTarget {
  constructor(e, n) {
    var r, s;
    super(), K(this, oe), this.CONNECTING = 0, this.OPEN = 1, this.CLOSED = 2, K(this, Y), K(this, Se), K(this, je), K(this, Et), K(this, Mt), K(this, rt), K(this, $e), K(this, st, null), K(this, ge), K(this, Re), K(this, Ue, null), K(this, xe, null), K(this, Ze, null), K(this, En, async (i) => {
      var o;
      k(this, Re).reset();
      const { body: a, redirected: c, status: u, headers: l } = i;
      if (u === 204) {
        he(this, oe, Xe).call(this, "Server sent HTTP 204, not reconnecting", 204), this.close();
        return;
      }
      if (c ? $(this, je, new URL(i.url)) : $(this, je, void 0), u !== 200) {
        he(this, oe, Xe).call(this, `Non-200 status code (${u})`, u);
        return;
      }
      if (!(l.get("content-type") || "").startsWith("text/event-stream")) {
        he(this, oe, Xe).call(this, 'Invalid content type, expected "text/event-stream"', u);
        return;
      }
      if (k(this, Y) === this.CLOSED)
        return;
      $(this, Y, this.OPEN);
      const f = new Event("open");
      if ((o = k(this, Ze)) == null || o.call(this, f), this.dispatchEvent(f), typeof a != "object" || !a || !("getReader" in a)) {
        he(this, oe, Xe).call(this, "Invalid response body, expected a web ReadableStream", u), this.close();
        return;
      }
      const h = new TextDecoder(), y = a.getReader();
      let b = !0;
      do {
        const { done: g, value: w } = await y.read();
        w && k(this, Re).feed(h.decode(w, { stream: !g })), g && (b = !1, k(this, Re).reset(), he(this, oe, Cn).call(this));
      } while (b);
    }), K(this, On, (i) => {
      $(this, ge, void 0), !(i.name === "AbortError" || i.type === "aborted") && he(this, oe, Cn).call(this, Sn(i));
    }), K(this, An, (i) => {
      typeof i.id == "string" && $(this, st, i.id);
      const o = new MessageEvent(i.event || "message", {
        data: i.data,
        origin: k(this, je) ? k(this, je).origin : k(this, Se).origin,
        lastEventId: i.id || ""
      });
      k(this, xe) && (!i.event || i.event === "message") && k(this, xe).call(this, o), this.dispatchEvent(o);
    }), K(this, kn, (i) => {
      $(this, rt, i);
    }), K(this, Pn, () => {
      $(this, $e, void 0), k(this, Y) === this.CONNECTING && he(this, oe, vn).call(this);
    });
    try {
      if (e instanceof URL)
        $(this, Se, e);
      else if (typeof e == "string")
        $(this, Se, new URL(e, Au()));
      else
        throw new Error("Invalid URL");
    } catch {
      throw Ou("An invalid or illegal string was specified");
    }
    $(this, Re, vu({
      onEvent: k(this, An),
      onRetry: k(this, kn)
    })), $(this, Y, this.CONNECTING), $(this, rt, 3e3), $(this, Mt, (r = n == null ? void 0 : n.fetch) != null ? r : globalThis.fetch), $(this, Et, (s = n == null ? void 0 : n.withCredentials) != null ? s : !1), he(this, oe, vn).call(this);
  }
  /**
   * Returns the state of this EventSource object's connection. It can have the values described below.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/readyState)
   *
   * Note: typed as `number` instead of `0 | 1 | 2` for compatibility with the `EventSource` interface,
   * defined in the TypeScript `dom` library.
   *
   * @public
   */
  get readyState() {
    return k(this, Y);
  }
  /**
   * Returns the URL providing the event stream.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/url)
   *
   * @public
   */
  get url() {
    return k(this, Se).href;
  }
  /**
   * Returns true if the credentials mode for connection requests to the URL providing the event stream is set to "include", and false otherwise.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/withCredentials)
   */
  get withCredentials() {
    return k(this, Et);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/error_event) */
  get onerror() {
    return k(this, Ue);
  }
  set onerror(e) {
    $(this, Ue, e);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/message_event) */
  get onmessage() {
    return k(this, xe);
  }
  set onmessage(e) {
    $(this, xe, e);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/open_event) */
  get onopen() {
    return k(this, Ze);
  }
  set onopen(e) {
    $(this, Ze, e);
  }
  addEventListener(e, n, r) {
    const s = n;
    super.addEventListener(e, s, r);
  }
  removeEventListener(e, n, r) {
    const s = n;
    super.removeEventListener(e, s, r);
  }
  /**
   * Aborts any instances of the fetch algorithm started for this EventSource object, and sets the readyState attribute to CLOSED.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/close)
   *
   * @public
   */
  close() {
    k(this, $e) && clearTimeout(k(this, $e)), k(this, Y) !== this.CLOSED && (k(this, ge) && k(this, ge).abort(), $(this, Y, this.CLOSED), $(this, ge, void 0));
  }
}
Y = /* @__PURE__ */ new WeakMap(), Se = /* @__PURE__ */ new WeakMap(), je = /* @__PURE__ */ new WeakMap(), Et = /* @__PURE__ */ new WeakMap(), Mt = /* @__PURE__ */ new WeakMap(), rt = /* @__PURE__ */ new WeakMap(), $e = /* @__PURE__ */ new WeakMap(), st = /* @__PURE__ */ new WeakMap(), ge = /* @__PURE__ */ new WeakMap(), Re = /* @__PURE__ */ new WeakMap(), Ue = /* @__PURE__ */ new WeakMap(), xe = /* @__PURE__ */ new WeakMap(), Ze = /* @__PURE__ */ new WeakMap(), oe = /* @__PURE__ */ new WeakSet(), /**
* Connect to the given URL and start receiving events
*
* @internal
*/
vn = function() {
  $(this, Y, this.CONNECTING), $(this, ge, new AbortController()), k(this, Mt)(k(this, Se), he(this, oe, Xr).call(this)).then(k(this, En)).catch(k(this, On));
}, En = /* @__PURE__ */ new WeakMap(), On = /* @__PURE__ */ new WeakMap(), /**
* Get request options for the `fetch()` request
*
* @returns The request options
* @internal
*/
Xr = function() {
  var t;
  const e = {
    // [spec] Let `corsAttributeState` be `Anonymous`
    // [spec] will have their mode set to "cors"
    mode: "cors",
    redirect: "follow",
    headers: { Accept: "text/event-stream", ...k(this, st) ? { "Last-Event-ID": k(this, st) } : void 0 },
    cache: "no-store",
    signal: (t = k(this, ge)) == null ? void 0 : t.signal
  };
  return "window" in globalThis && (e.credentials = this.withCredentials ? "include" : "same-origin"), e;
}, An = /* @__PURE__ */ new WeakMap(), kn = /* @__PURE__ */ new WeakMap(), /**
* Handles the process referred to in the EventSource specification as "failing a connection".
*
* @param error - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/
Xe = function(t, e) {
  var n;
  k(this, Y) !== this.CLOSED && $(this, Y, this.CLOSED);
  const r = new Yr("error", { code: e, message: t });
  (n = k(this, Ue)) == null || n.call(this, r), this.dispatchEvent(r);
}, /**
* Schedules a reconnection attempt against the EventSource endpoint.
*
* @param message - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/
Cn = function(t, e) {
  var n;
  if (k(this, Y) === this.CLOSED)
    return;
  $(this, Y, this.CONNECTING);
  const r = new Yr("error", { code: e, message: t });
  (n = k(this, Ue)) == null || n.call(this, r), this.dispatchEvent(r), $(this, $e, setTimeout(k(this, Pn), k(this, rt)));
}, Pn = /* @__PURE__ */ new WeakMap(), /**
* ReadyState representing an EventSource currently trying to connect
*
* @public
*/
Ot.CONNECTING = 0, /**
* ReadyState representing an EventSource connection that is open (eg connected)
*
* @public
*/
Ot.OPEN = 1, /**
* ReadyState representing an EventSource connection that is closed (eg disconnected)
*
* @public
*/
Ot.CLOSED = 2;
function Au() {
  const t = "document" in globalThis ? globalThis.document : void 0;
  return t && typeof t == "object" && "baseURI" in t && typeof t.baseURI == "string" ? t.baseURI : void 0;
}
class zs extends vt {
}
p(zs, "EventSourceImpl", Ot);
function ku(t) {
  const e = {
    ...t,
    useDateObjects: t.useDateObjects ?? !1
  };
  return new zs(e, {
    "@instantdb/react": Wn
  });
}
const Du = ku;
function Uu({
  as: t = "div",
  spaceId: e,
  room: n,
  className: r,
  style: s,
  userCursorColor: i,
  children: o,
  renderCursor: a,
  propagate: c,
  zIndex: u
}) {
  const l = e || `cursors-space-default--${String(n.type)}-${n.id}`, f = n.usePresence({
    keys: [l]
  }), h = n._core._reactor.getPresence(n.type, n.id);
  function y(_, S) {
    const O = S.clientX, E = S.clientY, j = (O - _.left) / _.width * 100, L = (E - _.top) / _.height * 100;
    f.publishPresence({
      [l]: {
        x: O,
        y: E,
        xPercent: j,
        yPercent: L,
        color: i
      }
    });
  }
  function b(_) {
    c || _.stopPropagation();
    const S = _.currentTarget.getBoundingClientRect();
    y(S, _);
  }
  function g(_) {
    f.publishPresence({
      [l]: void 0
    });
  }
  function w(_) {
    if (_.touches.length !== 1)
      return;
    const S = _.touches[0];
    if (S.target instanceof Element) {
      c || _.stopPropagation();
      const O = S.target.getBoundingClientRect();
      y(O, S);
    }
  }
  function m(_) {
    f.publishPresence({
      [l]: void 0
    });
  }
  return Ti(
    t,
    {
      onMouseMove: b,
      onMouseOut: g,
      onTouchMove: w,
      onTouchEnd: m,
      className: r,
      style: {
        position: "relative",
        ...s
      }
    },
    [
      o,
      /* @__PURE__ */ V.jsx(
        "div",
        {
          style: {
            ...es,
            ...Pu,
            zIndex: u !== void 0 ? u : Iu
          },
          children: Object.entries(f.peers).map(([_, S]) => {
            const O = S[l];
            return O ? /* @__PURE__ */ V.jsx(
              "div",
              {
                style: {
                  ...es,
                  transform: `translate(${O.xPercent}%, ${O.yPercent}%)`,
                  transformOrigin: "0 0",
                  transition: "transform 100ms"
                },
                children: a ? a({
                  color: O.color,
                  presence: h == null ? void 0 : h.peers[_]
                }) : /* @__PURE__ */ V.jsx(Cu, { ...O })
              },
              _
            ) : null;
          })
        },
        l
      )
    ]
  );
}
function Cu({ color: t }) {
  const n = t || "black";
  return /* @__PURE__ */ V.jsxs(
    "svg",
    {
      style: { height: 35, width: 35 },
      viewBox: "0 0 35 35",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [
        /* @__PURE__ */ V.jsxs(
          "g",
          {
            fill: "rgba(0,0,0,.2)",
            transform: "matrix(1, 0, 0, 1, -11.999999046325684, -8.406899452209473)",
            children: [
              /* @__PURE__ */ V.jsx("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }),
              /* @__PURE__ */ V.jsx("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })
            ]
          }
        ),
        /* @__PURE__ */ V.jsxs(
          "g",
          {
            fill: "white",
            transform: "matrix(1, 0, 0, 1, -11.999999046325684, -8.406899452209473)",
            children: [
              /* @__PURE__ */ V.jsx("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }),
              /* @__PURE__ */ V.jsx("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })
            ]
          }
        ),
        /* @__PURE__ */ V.jsxs(
          "g",
          {
            fill: n,
            transform: "matrix(1, 0, 0, 1, -11.999999046325684, -8.406899452209473)",
            children: [
              /* @__PURE__ */ V.jsx("path", { d: "m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z" }),
              /* @__PURE__ */ V.jsx("path", { d: "m13 10.814v11.188l2.969-2.866.428-.139h4.768z" })
            ]
          }
        )
      ]
    }
  );
}
const es = {
  position: "absolute",
  top: 0,
  left: 0,
  bottom: 0,
  right: 0
}, Pu = {
  overflow: "hidden",
  pointerEvents: "none",
  userSelect: "none"
}, Iu = 99999;
export {
  Uu as Cursors,
  xt as InstantAPIError,
  vt as InstantReactAbstractDatabase,
  zs as InstantReactWebDatabase,
  Fa as StoreInterface,
  Te as SyncTableCallbackEventType,
  $u as createInstantRouteHandler,
  xu as i,
  W as id,
  ku as init,
  Du as init_experimental,
  la as lookup,
  Ru as tx
};
