{"version":3,"file":"HydrationStreamProvider.js","sourceRoot":"","sources":["../../../src/next-ssr/HydrationStreamProvider.tsx"],"names":[],"mappings":"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","sourcesContent":["'use client';\n\n// This allows us to send serialized json from the server to the client using 'useServerInsertedHTML'\n// We are allowed to send whatever json we want, however it must be triggered at the same time as the client is recieving new html to display\n// after a suspsense boundary resolves\n// We do this to send a list of triples and attrs for each query that the server made so they can be pre-filled on the client render.\n// useServerInsertedHTML is called whenever a suspense boundary resolves, resulting in new html being streamed down to the client.\n\nexport const isServer = typeof window === 'undefined' || 'Deno' in globalThis;\n\nimport { useServerInsertedHTML } from 'next/navigation.js';\n\nimport * as React from 'react';\nimport { htmlEscapeJsonString } from './htmlescape.js';\n\nconst serializedSymbol = Symbol('serialized');\n\ninterface DataTransformer {\n  serialize: (object: any) => any;\n  deserialize: (object: any) => any;\n}\n\ntype Serialized<TData> = unknown & {\n  [serializedSymbol]: TData;\n};\n\ninterface TypedDataTransformer<TData> {\n  serialize: (obj: TData) => Serialized<TData>;\n  deserialize: (obj: Serialized<TData>) => TData;\n}\n\ninterface HydrationStreamContext<TShape> {\n  id: string;\n  stream: {\n    /**\n     * **Server method**\n     * Push a new entry to the stream\n     * Will be ignored on the client\n     */\n    push: (...shape: Array<TShape>) => void;\n  };\n}\n\nexport interface HydrationStreamProviderProps<TShape> {\n  children: React.ReactNode;\n  /**\n   * Optional transformer to serialize/deserialize the data\n   * Example devalue, superjson et al\n   */\n  transformer?: DataTransformer;\n  /**\n   * **Client method**\n   * Called in the browser when new entries are received\n   */\n  onEntries: (entries: Array<TShape>) => void;\n  /**\n   * **Server method**\n   * onFlush is called on the server when the cache is flushed\n   */\n  onFlush?: () => Array<TShape>;\n  /**\n   * A nonce that'll allow the inline script to be executed when Content Security Policy is enforced\n   */\n  nonce?: string;\n}\n\nexport function createHydrationStreamProvider<TShape>() {\n  const context = React.createContext<HydrationStreamContext<TShape>>(\n    null as any,\n  );\n  /**\n\n   * 1. (Happens on server): `useServerInsertedHTML()` is called **on the server** whenever a `Suspense`-boundary completes\n   *    - This means that we might have some new entries in the cache that needs to be flushed\n   *    - We pass these to the client by inserting a `<script>`-tag where we do `window[id].push(serializedVersionOfCache)`\n   * 2. (Happens in browser) In `useEffect()`:\n   *   - We check if `window[id]` is set to an array and call `push()` on all the entries which will call `onEntries()` with the new entries\n   *   - We replace `window[id]` with a `push()`-method that will be called whenever new entries are received\n   **/\n  function UseClientHydrationStreamProvider(props: {\n    children: React.ReactNode;\n    /**\n     * Optional transformer to serialize/deserialize the data\n     * Example devalue, superjson et al\n     */\n    transformer?: DataTransformer;\n    /**\n     * **Client method**\n     * Called in the browser when new entries are received\n     */\n    onEntries: (entries: Array<TShape>) => void;\n    /**\n     * **Server method**\n     * onFlush is called on the server when the cache is flushed\n     */\n    onFlush?: () => Array<TShape>;\n    /**\n     * A nonce that'll allow the inline script to be executed when Content Security Policy is enforced\n     */\n    nonce?: string;\n  }) {\n    // unique id for the cache provider\n    const id = `__RQ${React.useId()}`;\n    const idJSON = htmlEscapeJsonString(JSON.stringify(id));\n\n    const [transformer] = React.useState(\n      () =>\n        (props.transformer ?? {\n          // noop\n          serialize: (obj: any) => obj,\n          deserialize: (obj: any) => obj,\n        }) as unknown as TypedDataTransformer<TShape>,\n    );\n\n    // <server stuff>\n    const [stream] = React.useState<Array<TShape>>(() => {\n      if (!isServer) {\n        return {\n          push() {\n            // no-op on the client\n          },\n        } as unknown as Array<TShape>;\n      }\n      return [];\n    });\n    const count = React.useRef(0);\n    useServerInsertedHTML(() => {\n      // This only happens on the server\n      stream.push(...(props.onFlush?.() ?? []));\n\n      if (!stream.length) {\n        return null;\n      }\n      // console.log(`pushing ${stream.length} entries`)\n      const serializedCacheArgs = stream\n        .map((entry) => transformer.serialize(entry))\n        .map((entry) => JSON.stringify(entry))\n        .join(',');\n\n      // Flush stream\n      // eslint-disable-next-line react-hooks/immutability\n      stream.length = 0;\n\n      const html: Array<string> = [\n        `window[${idJSON}] = window[${idJSON}] || [];`,\n        `window[${idJSON}].push(${htmlEscapeJsonString(serializedCacheArgs)});`,\n      ];\n      return (\n        <script\n          key={count.current++}\n          nonce={props.nonce}\n          dangerouslySetInnerHTML={{\n            __html: html.join(''),\n          }}\n        />\n      );\n    });\n    // </server stuff>\n\n    // <client stuff>\n    // Setup and run the onEntries handler on the client only, but do it during\n    // the initial render so children have access to the data immediately\n    // This is important to avoid the client suspending during the initial render\n    // if the data has not yet been hydrated.\n    if (!isServer) {\n      const win = window as any;\n      if (!win[id]?.initialized) {\n        // Client: consume cache:\n        const onEntries = (...serializedEntries: Array<Serialized<TShape>>) => {\n          const entries = serializedEntries.map((serialized) =>\n            transformer.deserialize(serialized),\n          );\n          props.onEntries(entries);\n        };\n\n        const winStream: Array<Serialized<TShape>> = win[id] ?? [];\n\n        onEntries(...winStream);\n\n        // eslint-disable-next-line react-hooks/immutability\n        win[id] = {\n          initialized: true,\n          push: onEntries,\n        };\n      }\n    }\n    // </client stuff>\n\n    return (\n      <context.Provider value={{ stream, id }}>\n        {props.children}\n      </context.Provider>\n    );\n  }\n\n  return {\n    Provider: UseClientHydrationStreamProvider,\n    context,\n  };\n}\n"]}