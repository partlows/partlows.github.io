'use client';
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.isServer = void 0;
exports.createHydrationStreamProvider = createHydrationStreamProvider;
const jsx_runtime_1 = require("react/jsx-runtime");
// This allows us to send serialized json from the server to the client using 'useServerInsertedHTML'
// We are allowed to send whatever json we want, however it must be triggered at the same time as the client is recieving new html to display
// after a suspsense boundary resolves
// We do this to send a list of triples and attrs for each query that the server made so they can be pre-filled on the client render.
// useServerInsertedHTML is called whenever a suspense boundary resolves, resulting in new html being streamed down to the client.
exports.isServer = typeof window === 'undefined' || 'Deno' in globalThis;
const navigation_js_1 = require("next/navigation.js");
const React = __importStar(require("react"));
const htmlescape_js_1 = require("./htmlescape.js");
const serializedSymbol = Symbol('serialized');
function createHydrationStreamProvider() {
    const context = React.createContext(null);
    /**
  
     * 1. (Happens on server): `useServerInsertedHTML()` is called **on the server** whenever a `Suspense`-boundary completes
     *    - This means that we might have some new entries in the cache that needs to be flushed
     *    - We pass these to the client by inserting a `<script>`-tag where we do `window[id].push(serializedVersionOfCache)`
     * 2. (Happens in browser) In `useEffect()`:
     *   - We check if `window[id]` is set to an array and call `push()` on all the entries which will call `onEntries()` with the new entries
     *   - We replace `window[id]` with a `push()`-method that will be called whenever new entries are received
     **/
    function UseClientHydrationStreamProvider(props) {
        // unique id for the cache provider
        const id = `__RQ${React.useId()}`;
        const idJSON = (0, htmlescape_js_1.htmlEscapeJsonString)(JSON.stringify(id));
        const [transformer] = React.useState(() => (props.transformer ?? {
            // noop
            serialize: (obj) => obj,
            deserialize: (obj) => obj,
        }));
        // <server stuff>
        const [stream] = React.useState(() => {
            if (!exports.isServer) {
                return {
                    push() {
                        // no-op on the client
                    },
                };
            }
            return [];
        });
        const count = React.useRef(0);
        (0, navigation_js_1.useServerInsertedHTML)(() => {
            // This only happens on the server
            stream.push(...(props.onFlush?.() ?? []));
            if (!stream.length) {
                return null;
            }
            // console.log(`pushing ${stream.length} entries`)
            const serializedCacheArgs = stream
                .map((entry) => transformer.serialize(entry))
                .map((entry) => JSON.stringify(entry))
                .join(',');
            // Flush stream
            // eslint-disable-next-line react-hooks/immutability
            stream.length = 0;
            const html = [
                `window[${idJSON}] = window[${idJSON}] || [];`,
                `window[${idJSON}].push(${(0, htmlescape_js_1.htmlEscapeJsonString)(serializedCacheArgs)});`,
            ];
            return ((0, jsx_runtime_1.jsx)("script", { nonce: props.nonce, dangerouslySetInnerHTML: {
                    __html: html.join(''),
                } }, count.current++));
        });
        // </server stuff>
        // <client stuff>
        // Setup and run the onEntries handler on the client only, but do it during
        // the initial render so children have access to the data immediately
        // This is important to avoid the client suspending during the initial render
        // if the data has not yet been hydrated.
        if (!exports.isServer) {
            const win = window;
            if (!win[id]?.initialized) {
                // Client: consume cache:
                const onEntries = (...serializedEntries) => {
                    const entries = serializedEntries.map((serialized) => transformer.deserialize(serialized));
                    props.onEntries(entries);
                };
                const winStream = win[id] ?? [];
                onEntries(...winStream);
                // eslint-disable-next-line react-hooks/immutability
                win[id] = {
                    initialized: true,
                    push: onEntries,
                };
            }
        }
        // </client stuff>
        return ((0, jsx_runtime_1.jsx)(context.Provider, { value: { stream, id }, children: props.children }));
    }
    return {
        Provider: UseClientHydrationStreamProvider,
        context,
    };
}
//# sourceMappingURL=HydrationStreamProvider.js.map