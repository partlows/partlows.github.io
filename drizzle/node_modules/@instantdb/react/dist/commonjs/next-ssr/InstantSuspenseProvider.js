'use client';
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstantSuspenseProvider = exports.createUseSuspenseQuery = exports.SuspsenseQueryContext = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
// InstantSuspenseProvider can only be used in a client context so this prevents errors from trying to use it in a server component.
const core_1 = require("@instantdb/core");
const HydrationStreamProvider_tsx_1 = require("./HydrationStreamProvider.js");
const react_1 = require("react");
const stream = (0, HydrationStreamProvider_tsx_1.createHydrationStreamProvider)();
exports.SuspsenseQueryContext = (0, react_1.createContext)(null);
// Creates a typed useSuspense hook
const createUseSuspenseQuery = (_db) => {
    return (q, opts) => {
        const ctx = (0, react_1.useContext)(exports.SuspsenseQueryContext);
        if (!ctx) {
            throw new Error('useSuspenseQuery must be used within a SuspenseQueryProvider');
        }
        return ctx.useSuspenseQuery(q, opts);
    };
};
exports.createUseSuspenseQuery = createUseSuspenseQuery;
const InstantSuspenseProvider = (props) => {
    const clientRef = (0, react_1.useRef)(null);
    if (!props.db) {
        throw new Error('Must provide either a db or config to InstantSuspenseProvider');
    }
    const db = (0, react_1.useRef)(props.db);
    const [trackedKeys] = (0, react_1.useState)(() => new Set());
    if (!clientRef.current) {
        if (props.user && !props.user.refresh_token) {
            throw new Error('User must have a refresh_token field. Recieved: ' +
                JSON.stringify(props.user, null, 2));
        }
        clientRef.current = new core_1.FrameworkClient({
            token: props.user?.refresh_token,
            db: db.current.core,
        });
    }
    if (HydrationStreamProvider_tsx_1.isServer) {
        clientRef.current.subscribe((result) => {
            const { queryHash } = result;
            trackedKeys.add(queryHash);
        });
    }
    const useSuspenseQuery = (query, opts) => {
        const nonSuspenseResult = db.current.useQuery(query, {
            ...opts,
        });
        if (nonSuspenseResult.data) {
            return {
                data: nonSuspenseResult.data,
                pageInfo: nonSuspenseResult.pageInfo,
            };
        }
        // should never happen (typeguard)
        if (!clientRef.current) {
            throw new Error('Client ref not set up');
        }
        let entry = clientRef.current.getExistingResultForQuery(query, {
            ruleParams: opts?.ruleParams,
        });
        if (!entry) {
            entry = clientRef.current.query(query, opts);
        }
        if (entry.status === 'pending') {
            throw entry.promise;
        }
        if (entry.status === 'error') {
            throw entry.error;
        }
        if (entry.status === 'success' && entry.type === 'session') {
            return entry.data;
        }
        if (entry.status === 'success') {
            const data = entry.data;
            const result = clientRef.current.completeIsomorphic(query, data.triples, data.attrs, data.pageInfo);
            return result;
        }
    };
    return ((0, jsx_runtime_1.jsx)(exports.SuspsenseQueryContext.Provider, { value: { useSuspenseQuery, ssrUser: props.user }, children: (0, jsx_runtime_1.jsx)(stream.Provider, { nonce: props.nonce, onFlush: () => {
                const toSend = [];
                for (const [key, value] of clientRef.current.resultMap.entries()) {
                    if (trackedKeys.has(key) && value.status === 'success') {
                        toSend.push({
                            queryKey: key,
                            value: value.data,
                        });
                    }
                }
                trackedKeys.clear();
                return toSend;
            }, onEntries: (entries) => {
                entries.forEach((entry) => {
                    clientRef.current.addQueryResult(entry.queryKey, entry.value);
                });
            }, children: props.children }) }));
};
exports.InstantSuspenseProvider = InstantSuspenseProvider;
//# sourceMappingURL=InstantSuspenseProvider.js.map