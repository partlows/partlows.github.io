'use client';
import { jsx as _jsx } from "react/jsx-runtime";
// This allows us to send serialized json from the server to the client using 'useServerInsertedHTML'
// We are allowed to send whatever json we want, however it must be triggered at the same time as the client is recieving new html to display
// after a suspsense boundary resolves
// We do this to send a list of triples and attrs for each query that the server made so they can be pre-filled on the client render.
// useServerInsertedHTML is called whenever a suspense boundary resolves, resulting in new html being streamed down to the client.
export const isServer = typeof window === 'undefined' || 'Deno' in globalThis;
import { useServerInsertedHTML } from 'next/navigation.js';
import * as React from 'react';
import { htmlEscapeJsonString } from './htmlescape.js';
const serializedSymbol = Symbol('serialized');
export function createHydrationStreamProvider() {
    const context = React.createContext(null);
    /**
  
     * 1. (Happens on server): `useServerInsertedHTML()` is called **on the server** whenever a `Suspense`-boundary completes
     *    - This means that we might have some new entries in the cache that needs to be flushed
     *    - We pass these to the client by inserting a `<script>`-tag where we do `window[id].push(serializedVersionOfCache)`
     * 2. (Happens in browser) In `useEffect()`:
     *   - We check if `window[id]` is set to an array and call `push()` on all the entries which will call `onEntries()` with the new entries
     *   - We replace `window[id]` with a `push()`-method that will be called whenever new entries are received
     **/
    function UseClientHydrationStreamProvider(props) {
        // unique id for the cache provider
        const id = `__RQ${React.useId()}`;
        const idJSON = htmlEscapeJsonString(JSON.stringify(id));
        const [transformer] = React.useState(() => (props.transformer ?? {
            // noop
            serialize: (obj) => obj,
            deserialize: (obj) => obj,
        }));
        // <server stuff>
        const [stream] = React.useState(() => {
            if (!isServer) {
                return {
                    push() {
                        // no-op on the client
                    },
                };
            }
            return [];
        });
        const count = React.useRef(0);
        useServerInsertedHTML(() => {
            // This only happens on the server
            stream.push(...(props.onFlush?.() ?? []));
            if (!stream.length) {
                return null;
            }
            // console.log(`pushing ${stream.length} entries`)
            const serializedCacheArgs = stream
                .map((entry) => transformer.serialize(entry))
                .map((entry) => JSON.stringify(entry))
                .join(',');
            // Flush stream
            // eslint-disable-next-line react-hooks/immutability
            stream.length = 0;
            const html = [
                `window[${idJSON}] = window[${idJSON}] || [];`,
                `window[${idJSON}].push(${htmlEscapeJsonString(serializedCacheArgs)});`,
            ];
            return (_jsx("script", { nonce: props.nonce, dangerouslySetInnerHTML: {
                    __html: html.join(''),
                } }, count.current++));
        });
        // </server stuff>
        // <client stuff>
        // Setup and run the onEntries handler on the client only, but do it during
        // the initial render so children have access to the data immediately
        // This is important to avoid the client suspending during the initial render
        // if the data has not yet been hydrated.
        if (!isServer) {
            const win = window;
            if (!win[id]?.initialized) {
                // Client: consume cache:
                const onEntries = (...serializedEntries) => {
                    const entries = serializedEntries.map((serialized) => transformer.deserialize(serialized));
                    props.onEntries(entries);
                };
                const winStream = win[id] ?? [];
                onEntries(...winStream);
                // eslint-disable-next-line react-hooks/immutability
                win[id] = {
                    initialized: true,
                    push: onEntries,
                };
            }
        }
        // </client stuff>
        return (_jsx(context.Provider, { value: { stream, id }, children: props.children }));
    }
    return {
        Provider: UseClientHydrationStreamProvider,
        context,
    };
}
//# sourceMappingURL=HydrationStreamProvider.js.map