'use client';
import { jsx as _jsx } from "react/jsx-runtime";
// InstantSuspenseProvider can only be used in a client context so this prevents errors from trying to use it in a server component.
import { FrameworkClient, } from '@instantdb/core';
import { createHydrationStreamProvider, isServer, } from "./HydrationStreamProvider.js";
import { createContext, useContext, useRef, useState } from 'react';
const stream = createHydrationStreamProvider();
export const SuspsenseQueryContext = createContext(null);
// Creates a typed useSuspense hook
export const createUseSuspenseQuery = (_db) => {
    return (q, opts) => {
        const ctx = useContext(SuspsenseQueryContext);
        if (!ctx) {
            throw new Error('useSuspenseQuery must be used within a SuspenseQueryProvider');
        }
        return ctx.useSuspenseQuery(q, opts);
    };
};
export const InstantSuspenseProvider = (props) => {
    const clientRef = useRef(null);
    if (!props.db) {
        throw new Error('Must provide either a db or config to InstantSuspenseProvider');
    }
    const db = useRef(props.db);
    const [trackedKeys] = useState(() => new Set());
    if (!clientRef.current) {
        if (props.user && !props.user.refresh_token) {
            throw new Error('User must have a refresh_token field. Recieved: ' +
                JSON.stringify(props.user, null, 2));
        }
        clientRef.current = new FrameworkClient({
            token: props.user?.refresh_token,
            db: db.current.core,
        });
    }
    if (isServer) {
        clientRef.current.subscribe((result) => {
            const { queryHash } = result;
            trackedKeys.add(queryHash);
        });
    }
    const useSuspenseQuery = (query, opts) => {
        const nonSuspenseResult = db.current.useQuery(query, {
            ...opts,
        });
        if (nonSuspenseResult.data) {
            return {
                data: nonSuspenseResult.data,
                pageInfo: nonSuspenseResult.pageInfo,
            };
        }
        // should never happen (typeguard)
        if (!clientRef.current) {
            throw new Error('Client ref not set up');
        }
        let entry = clientRef.current.getExistingResultForQuery(query, {
            ruleParams: opts?.ruleParams,
        });
        if (!entry) {
            entry = clientRef.current.query(query, opts);
        }
        if (entry.status === 'pending') {
            throw entry.promise;
        }
        if (entry.status === 'error') {
            throw entry.error;
        }
        if (entry.status === 'success' && entry.type === 'session') {
            return entry.data;
        }
        if (entry.status === 'success') {
            const data = entry.data;
            const result = clientRef.current.completeIsomorphic(query, data.triples, data.attrs, data.pageInfo);
            return result;
        }
    };
    return (_jsx(SuspsenseQueryContext.Provider, { value: { useSuspenseQuery, ssrUser: props.user }, children: _jsx(stream.Provider, { nonce: props.nonce, onFlush: () => {
                const toSend = [];
                for (const [key, value] of clientRef.current.resultMap.entries()) {
                    if (trackedKeys.has(key) && value.status === 'success') {
                        toSend.push({
                            queryKey: key,
                            value: value.data,
                        });
                    }
                }
                trackedKeys.clear();
                return toSend;
            }, onEntries: (entries) => {
                entries.forEach((entry) => {
                    clientRef.current.addQueryResult(entry.queryKey, entry.value);
                });
            }, children: props.children }) }));
};
//# sourceMappingURL=InstantSuspenseProvider.js.map