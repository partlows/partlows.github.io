import * as ComLink from 'comlink';
import { TriplitClient as Client, } from '../client/triplit-client.js';
import { WorkerInternalClientNotInitializedError } from '../errors.js';
import { logger as LOGGER } from '@triplit/logger';
export class ClientComlinkWrapper {
    client = null;
    variableChangeListeners = new Set();
    constructor() { }
    init(options, workerThreadLogHandler) {
        if (this.client != undefined)
            return;
        // Handle session in main thread
        const { token, ...remainingOptions } = options;
        // Setup logger
        LOGGER.registerHandler(workerThreadLogHandler);
        this.client = new Client({
            ...remainingOptions,
            // Handle autoConnect in the main thread
            autoConnect: false,
        });
    }
    async fetch(...args) {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return await this.client.fetch(...args);
    }
    // @ts-expect-error
    async transact(...args) {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return await this.client.transact((tx) => args[0](ComLink.proxy(tx)), args[1]);
    }
    async fetchById(...args) {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return await this.client.fetchById(...args);
    }
    async fetchOne(...args) {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return await this.client.fetchOne(...args);
    }
    async insert(...args) {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return await this.client.insert(...args);
    }
    async update(collectionName, entityId, data) {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return await this.client.update(collectionName, entityId, data);
    }
    async getSchema() {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return await this.client.getSchema();
    }
    async delete(...args) {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return await this.client.delete(...args);
    }
    // @ts-expect-error
    async subscribe(...args) {
        args[3] = await normalizeSubscriptionOptions(args[3]);
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return ComLink.proxy(this.client.subscribe(...args));
    }
    // @ts-expect-error
    async subscribeBackground(query, options = {}) {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return ComLink.proxy(this.client.subscribeBackground(query, options));
    }
    // @ts-expect-error
    async subscribeWithPagination(...args) {
        args[3] = await normalizeSubscriptionOptions(args[3]);
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return ComLink.proxy(this.client.subscribeWithPagination(...args));
    }
    // @ts-expect-error
    async subscribeWithExpand(...args) {
        args[3] = await normalizeSubscriptionOptions(args[3]);
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return ComLink.proxy(this.client.subscribeWithExpand(...args));
    }
    // @ts-expect-error
    async subscribeWithStatus(...args) {
        args[2] = await normalizeSubscriptionOptions(args[2]);
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return ComLink.proxy(this.client.subscribeWithStatus(...args));
    }
    async startSession(...args) {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        const normalizedOptions = await normalizeStartSessionOptions(args[2]);
        const unsubCallback = await this.client.startSession(args[0], args[1], normalizedOptions);
        if (unsubCallback == undefined)
            return;
        return ComLink.proxy(unsubCallback);
    }
    async endSession(...args) {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return await this.client.endSession(...args);
    }
    updateSessionToken(...args) {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return this.client.updateSessionToken(...args);
    }
    onSessionError(...args) {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return ComLink.proxy(this.client.onSessionError(...args));
    }
    updateServerUrl(...args) {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return this.client.updateServerUrl(...args);
    }
    onSyncMessageReceived(...args) {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return ComLink.proxy(this.client.onSyncMessageReceived(...args));
    }
    onSyncMessageSent(...args) {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return ComLink.proxy(this.client.onSyncMessageSent(...args));
    }
    onEntitySyncSuccess(...args) {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return ComLink.proxy(this.client.onEntitySyncSuccess(...args));
    }
    onEntitySyncError(...args) {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return ComLink.proxy(this.client.onEntitySyncError(...args));
    }
    onFailureToSyncWrites(callback) {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return ComLink.proxy(this.client.onFailureToSyncWrites(callback));
    }
    onConnectionStatusChange(...args) {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return ComLink.proxy(this.client.onConnectionStatusChange(...args));
    }
    onVariablesChange(callback) {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        const unsub = this.client.onConnectionOptionsChange(() => {
            callback(this.client.vars);
        });
        this.variableChangeListeners.add(callback);
        let unsubscribed = false;
        // TODO: really need to clean up some of this async state logic
        this.client.ready.then(() => {
            if (unsubscribed)
                return;
            callback(this.client.vars);
        });
        return ComLink.proxy(() => {
            unsubscribed = true;
            this.variableChangeListeners.delete(callback);
            unsub();
        });
    }
    connect() {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return this.client.connect();
    }
    disconnect() {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return this.client.disconnect();
    }
    syncWrites(...args) {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return this.client.syncWrites(...args);
    }
    isFirstTimeFetchingQuery(query) {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return this.client.isFirstTimeFetchingQuery(query);
    }
    async updateGlobalVariables(...args) {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        await this.client.updateGlobalVariables(...args);
        for (const callback of this.variableChangeListeners) {
            callback(this.client.vars);
        }
    }
    async clear(options = {}) {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return await this.client.clear(options);
    }
    async reset(options = {}) {
        if (!this.client)
            throw new WorkerInternalClientNotInitializedError();
        return await this.client.reset(options);
    }
}
async function normalizeSubscriptionOptions(options) {
    if (options == undefined)
        return {};
    return {
        localOnly: await options.localOnly,
        onRemoteFulfilled: await options.onRemoteFulfilled,
    };
}
async function normalizeStartSessionOptions(options) {
    if (options == undefined)
        return undefined;
    return {
        interval: await options.interval,
        refreshHandler: options.refreshHandler,
    };
}
//# sourceMappingURL=client-comlink-wrapper.js.map