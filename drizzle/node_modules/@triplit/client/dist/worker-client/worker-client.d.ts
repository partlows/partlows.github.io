import * as ComLink from 'comlink';
import { type TriplitClient as Client } from '../client/triplit-client.js';
import { SubscribeBackgroundOptions, ClientFetchOptions, InfiniteSubscription, PaginatedSubscription, SubscriptionOptions, SubscriptionSignalPayload } from '../client/types';
import { ClearOptions, CollectionNameFromModels, CollectionQuery, FetchResult, Models, ReadModel, SchemaQuery, SubscriptionResultsCallback, TransactCallback, UpdatePayload, WriteModel } from '@triplit/db';
import { ClientComlinkWrapper } from './client-comlink-wrapper.js';
import { ClientOptions, ClientTransactOptions, SerializableStorageOptions } from '../client/types/client.js';
import { ConnectionStatus } from '../types.js';
export declare function getTriplitWorkerEndpoint(workerUrl?: string): ComLink.Endpoint;
export declare function getTriplitSharedWorkerPort(workerUrl?: string): SharedWorker['port'];
export declare class WorkerClient<M extends Models<M> = Models> implements Client<M> {
    initialized: Promise<void>;
    clientWorker: ClientComlinkWrapper<M>;
    private _connectionStatus;
    private _vars;
    constructor(options?: Omit<ClientOptions<M>, 'storage'> & {
        workerUrl?: string;
        storage?: SerializableStorageOptions;
    }, workerEndpoint?: ComLink.Endpoint, sharedWorkerPort?: MessagePort);
    get connectionStatus(): ConnectionStatus;
    query<CN extends CollectionNameFromModels<M>>(collectionName: CN): import("@triplit/db").QueryBuilder<M, CN, import("@triplit/db").WithInclusion<CollectionQuery<M, CN>, {}>>;
    fetch<Q extends SchemaQuery<M>>(query: Q, options?: Partial<ClientFetchOptions>): Promise<FetchResult<M, Q, 'many'>>;
    transact<CN extends CollectionNameFromModels<M>, Output>(callback: TransactCallback<M, Output>, options?: Partial<ClientTransactOptions>): Promise<Output>;
    private getChangesFromUpdatePayload;
    fetchById<CN extends CollectionNameFromModels<M>>(collectionName: CN, id: string, options?: Partial<ClientFetchOptions>): Promise<FetchResult<M, {
        collectionName: CN;
    }, 'one'>>;
    fetchOne<Q extends SchemaQuery<M>>(query: Q, options?: Partial<ClientFetchOptions>): Promise<FetchResult<M, Q, 'one'>>;
    insert<CN extends CollectionNameFromModels<M>>(collectionName: CN, object: WriteModel<M, CN>): Promise<ReadModel<M, CN>>;
    update<CN extends CollectionNameFromModels<M>>(collectionName: CN, entityId: string, data: UpdatePayload<M, CN>): Promise<void>;
    delete<CN extends CollectionNameFromModels<M>>(collectionName: CN, entityId: string): Promise<void>;
    subscribe<Q extends SchemaQuery<M>>(query: Q, onResults: SubscriptionResultsCallback<M, Q>, onError?: (error: any) => void | Promise<void>, options?: Partial<SubscriptionOptions>): () => void;
    subscribeWithStatus<Q extends SchemaQuery<M>>(query: Q, callback: (state: SubscriptionSignalPayload<M, Q>) => void, options?: Partial<SubscriptionOptions>): () => void;
    subscribeBackground<Q extends SchemaQuery<M>>(query: Q, options?: SubscribeBackgroundOptions): () => void;
    /**
     * Subscribe to a query with helpers for pagination
     * This query will "oversubscribe" by 1 on either side of the current page to determine if there are "next" or "previous" pages
     * The window generally looks like [buffer, ...page..., buffer]
     * Depending on the current paging direction, the query may have its original order reversed
     *
     * The pagination will also do its best to always return full pages
     */
    subscribeWithPagination<Q extends SchemaQuery<M>>(query: Q, onResults: (results: FetchResult<M, Q, 'many'>, info: {
        hasNextPage: boolean;
        hasPreviousPage: boolean;
    }) => void | Promise<void>, onError?: (error: any) => void | Promise<void>, options?: Partial<SubscriptionOptions>): PaginatedSubscription;
    subscribeWithExpand<Q extends SchemaQuery<M>>(query: Q, onResults: (results: FetchResult<M, Q, 'many'>, info: {
        hasMore: boolean;
    }) => void | Promise<void>, onError?: (error: any) => void | Promise<void>, options?: Partial<SubscriptionOptions>): InfiniteSubscription;
    getSchema(): Promise<import("@triplit/db").DBSchema<M> | undefined>;
    updateServerUrl(serverUrl: string): Promise<void>;
    startSession(...args: Parameters<Client<M>['startSession']>): Promise<((() => void) & ComLink.ProxyMarked) | undefined>;
    endSession(...args: Parameters<Client<M>['endSession']>): Promise<void>;
    onSessionError(...args: Parameters<Client<M>['onSessionError']>): Promise<(() => void) & ComLink.ProxyMarked>;
    updateSessionToken(...args: Parameters<Client<M>['updateSessionToken']>): Promise<void>;
    updateGlobalVariables(vars: Record<string, any>): Promise<void>;
    isFirstTimeFetchingQuery(query: CollectionQuery): Promise<boolean>;
    onSyncMessageReceived(...args: Parameters<typeof this.clientWorker.onSyncMessageReceived>): () => Promise<void>;
    onSyncMessageSent(...args: Parameters<typeof this.clientWorker.onSyncMessageSent>): () => Promise<void>;
    onEntitySyncSuccess(...args: Parameters<typeof this.clientWorker.onEntitySyncSuccess>): () => Promise<void>;
    onEntitySyncError(...args: Parameters<typeof this.clientWorker.onEntitySyncError>): () => Promise<void>;
    onFailureToSyncWrites(callback: (e: unknown) => void): () => void;
    onConnectionStatusChange(callback: (status: ConnectionStatus) => void, runImmediately?: boolean): () => Promise<void>;
    get vars(): {
        $token: Record<string, any>;
        $global: Record<string, any>;
        $session: Record<string, any>;
    };
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    syncWrites(): Promise<{
        didSync: boolean;
        syncFailureReason?: string;
    }>;
    clear(options?: ClearOptions): Promise<void>;
    reset(options?: ClearOptions): Promise<void>;
}
