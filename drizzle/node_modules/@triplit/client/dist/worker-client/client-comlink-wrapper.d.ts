import * as ComLink from 'comlink';
import { TriplitClient as Client, TriplitClient } from '../client/triplit-client.js';
import { SubscribeBackgroundOptions } from '../client/types';
import { ClearOptions, CollectionNameFromModels, CollectionQuery, Models, ReadModel, SchemaQuery } from '@triplit/db';
import { LogHandler } from '@triplit/logger';
import { ClientOptions, ClientTransactOptions } from '../client/types/client.js';
interface ClientWorker<M extends Models<M> = Models> extends Omit<Client<M>, 'update' | 'transact'> {
    init: (options: ClientOptions<M>, logger: any) => void;
    update: <CN extends CollectionNameFromModels<M>>(collectionName: CN, entityId: string, data: Partial<ReadModel<M, CN>>) => Promise<void>;
    transact: <Output>(callback: string, options?: Partial<ClientTransactOptions>) => Promise<Output>;
}
type VariablesChangeHandler = (variables: typeof TriplitClient.prototype.vars) => void;
export declare class ClientComlinkWrapper<M extends Models<M> = Models> implements ClientWorker<M> {
    client: Client<M> | null;
    private variableChangeListeners;
    constructor();
    init(options: ClientOptions<M>, workerThreadLogHandler: LogHandler): void;
    fetch(...args: Parameters<Client<M>['fetch']>): Promise<import("@triplit/db").Unalias<SchemaQuery<M> extends infer T ? T extends SchemaQuery<M> ? T extends CollectionQuery<M, infer CN extends keyof M_1 & string> ? (T["select"] extends readonly (infer S)[] ? (((S extends string ? S : never) extends infer T_1 ? T_1 extends (S extends string ? S : never) ? T_1 extends infer P ? P extends string ? (P extends infer T_2 ? T_2 extends P ? T_2 extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, .../*elided*/ any] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [T_2] : never : never) extends infer T_3 ? T_3 extends (P extends infer T_14 ? T_14 extends P ? T_14 extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, .../*elided*/ any] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [T_14] : never : never) ? T_3 extends [infer Head_1, ...infer Tail_1] ? Head_1 extends import("@triplit/db").StringKey<import("@triplit/db").Decoded<M[CN]["schema"]>> ? { [K in Head_1]: Extract<Tail_1, string[]> extends infer T_4 ? T_4 extends Extract<Tail_1, string[]> ? T_4 extends [infer Head_1, ...infer Tail_1] ? Head_1 extends import("@triplit/db").StringKey<import("@triplit/db").Decoded<M[CN]["schema"]>[K]> ? { [K_1 in Head_1]: Extract<Tail_1, string[]> extends infer T_5 ? T_5 extends Extract<Tail_1, string[]> ? T_5 extends [infer Head_1, ...infer Tail_1] ? Head_1 extends import("@triplit/db").StringKey<import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1]> ? { [K_2 in Head_1]: Extract<Tail_1, string[]> extends infer T_6 ? T_6 extends Extract<Tail_1, string[]> ? T_6 extends [infer Head_1, ...infer Tail_1] ? Head_1 extends import("@triplit/db").StringKey<import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2]> ? { [K_3 in Head_1]: Extract<Tail_1, string[]> extends infer T_7 ? T_7 extends Extract<Tail_1, string[]> ? T_7 extends [infer Head_1, ...infer Tail_1] ? Head_1 extends import("@triplit/db").StringKey<import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3]> ? { [K_4 in Head_1]: Extract<Tail_1, string[]> extends infer T_8 ? T_8 extends Extract<Tail_1, string[]> ? T_8 extends [infer Head_1, ...infer Tail_1] ? Head_1 extends import("@triplit/db").StringKey<import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3][K_4]> ? { [K_5 in Head_1]: Extract<Tail_1, string[]> extends infer T_9 ? T_9 extends Extract<Tail_1, string[]> ? T_9 extends [infer Head_1, ...infer Tail_1] ? Head_1 extends import("@triplit/db").StringKey<import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3][K_4][K_5]> ? { [K_6 in Head_1]: Extract<Tail_1, string[]> extends infer T_10 ? T_10 extends Extract<Tail_1, string[]> ? T_10 extends [infer Head_1, ...infer Tail_1] ? Head_1 extends import("@triplit/db").StringKey<import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3][K_4][K_5][K_6]> ? { [K_7 in Head_1]: Extract<Tail_1, string[]> extends infer T_11 ? T_11 extends Extract<Tail_1, string[]> ? T_11 extends [infer Head_1, ...infer Tail_1] ? Head_1 extends import("@triplit/db").StringKey<import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7]> ? { [K_8 in Head_1]: Extract<Tail_1, string[]> extends infer T_12 ? T_12 extends Extract<Tail_1, string[]> ? T_12 extends [infer Head_1, ...infer Tail_1] ? Head_1 extends import("@triplit/db").StringKey<import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8]> ? { [K_9 in Head_1]: Extract<Tail_1, string[]> extends infer T_13 ? T_13 extends Extract<Tail_1, string[]> ? T_13 extends [infer Head_1, ...infer Tail_1] ? Head_1 extends import("@triplit/db").StringKey<import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9]> ? { [K_10 in Head_1]: /*elided*/ any; } : {} : import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9] : never : never; } : {} : import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8] : never : never; } : {} : import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7] : never : never; } : {} : import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3][K_4][K_5][K_6] : never : never; } : {} : import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3][K_4][K_5] : never : never; } : {} : import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3][K_4] : never : never; } : {} : import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3] : never : never; } : {} : import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2] : never : never; } : {} : import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1] : never : never; } : {} : import("@triplit/db").Decoded<M[CN]["schema"]>[K] : never : never; } : {} : import("@triplit/db").Decoded<M[CN]["schema"]> : never : never : never : never : never : never) extends infer T_15 ? T_15 extends ((S extends string ? S : never) extends infer T_16 ? T_16 extends (S extends string ? S : never) ? T_16 extends infer P ? P extends string ? (P extends infer T_17 ? T_17 extends P ? T_17 extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, .../*elided*/ any] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [T_17] : never : never) extends infer T_18 ? T_18 extends (P extends infer T_29 ? T_29 extends P ? T_29 extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, ...Tail extends `${infer Head}.${infer Tail}` ? [Head, .../*elided*/ any] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [Tail]] : [T_29] : never : never) ? T_18 extends [infer Head_1, ...infer Tail_1] ? Head_1 extends import("@triplit/db").StringKey<import("@triplit/db").Decoded<M[CN]["schema"]>> ? { [K in Head_1]: Extract<Tail_1, string[]> extends infer T_19 ? T_19 extends Extract<Tail_1, string[]> ? T_19 extends [infer Head_1, ...infer Tail_1] ? Head_1 extends import("@triplit/db").StringKey<import("@triplit/db").Decoded<M[CN]["schema"]>[K]> ? { [K_1 in Head_1]: Extract<Tail_1, string[]> extends infer T_20 ? T_20 extends Extract<Tail_1, string[]> ? T_20 extends [infer Head_1, ...infer Tail_1] ? Head_1 extends import("@triplit/db").StringKey<import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1]> ? { [K_2 in Head_1]: Extract<Tail_1, string[]> extends infer T_21 ? T_21 extends Extract<Tail_1, string[]> ? T_21 extends [infer Head_1, ...infer Tail_1] ? Head_1 extends import("@triplit/db").StringKey<import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2]> ? { [K_3 in Head_1]: Extract<Tail_1, string[]> extends infer T_22 ? T_22 extends Extract<Tail_1, string[]> ? T_22 extends [infer Head_1, ...infer Tail_1] ? Head_1 extends import("@triplit/db").StringKey<import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3]> ? { [K_4 in Head_1]: Extract<Tail_1, string[]> extends infer T_23 ? T_23 extends Extract<Tail_1, string[]> ? T_23 extends [infer Head_1, ...infer Tail_1] ? Head_1 extends import("@triplit/db").StringKey<import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3][K_4]> ? { [K_5 in Head_1]: Extract<Tail_1, string[]> extends infer T_24 ? T_24 extends Extract<Tail_1, string[]> ? T_24 extends [infer Head_1, ...infer Tail_1] ? Head_1 extends import("@triplit/db").StringKey<import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3][K_4][K_5]> ? { [K_6 in Head_1]: Extract<Tail_1, string[]> extends infer T_25 ? T_25 extends Extract<Tail_1, string[]> ? T_25 extends [infer Head_1, ...infer Tail_1] ? Head_1 extends import("@triplit/db").StringKey<import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3][K_4][K_5][K_6]> ? { [K_7 in Head_1]: Extract<Tail_1, string[]> extends infer T_26 ? T_26 extends Extract<Tail_1, string[]> ? T_26 extends [infer Head_1, ...infer Tail_1] ? Head_1 extends import("@triplit/db").StringKey<import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7]> ? { [K_8 in Head_1]: Extract<Tail_1, string[]> extends infer T_27 ? T_27 extends Extract<Tail_1, string[]> ? T_27 extends [infer Head_1, ...infer Tail_1] ? Head_1 extends import("@triplit/db").StringKey<import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8]> ? { [K_9 in Head_1]: Extract<Tail_1, string[]> extends infer T_28 ? T_28 extends Extract<Tail_1, string[]> ? T_28 extends [infer Head_1, ...infer Tail_1] ? Head_1 extends import("@triplit/db").StringKey<import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9]> ? { [K_10 in Head_1]: /*elided*/ any; } : {} : import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9] : never : never; } : {} : import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8] : never : never; } : {} : import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7] : never : never; } : {} : import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3][K_4][K_5][K_6] : never : never; } : {} : import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3][K_4][K_5] : never : never; } : {} : import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3][K_4] : never : never; } : {} : import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2][K_3] : never : never; } : {} : import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1][K_2] : never : never; } : {} : import("@triplit/db").Decoded<M[CN]["schema"]>[K][K_1] : never : never; } : {} : import("@triplit/db").Decoded<M[CN]["schema"]>[K] : never : never; } : {} : import("@triplit/db").Decoded<M[CN]["schema"]> : never : never : never : never : never : never) ? T_15 extends any ? (k: T_15) => void : never : never : never) extends (k: infer I) => void ? I : never : import("@triplit/db").Decoded<M[CN]["schema"]>) & { [K_11 in import("@triplit/db").StringKey<T["include"]>]: T["include"][K_11] extends infer T_30 ? T_30 extends T["include"][K_11] ? T_30 extends import("@triplit/db").RelationSubquery<M, infer Subquery extends SchemaQuery<M_2, CollectionNameFromModels<M_2>>, infer Cardinality extends import("@triplit/db").QueryResultCardinality> ? import("@triplit/db").AliasedFetchResult<M, Subquery, Cardinality> : T_30 extends import("@triplit/db").RefSubquery<M, CN, infer Ref extends keyof NonNullable<M_2[CN_1]["relationships"]> & string> ? import("@triplit/db").AliasedFetchResult<M, import("@triplit/db").RefQuery<M, CN, Ref> & Omit<T_30, "_extends">, import("@triplit/db").RefDefinition<M, CN, Ref>["cardinality"]> : T_30 extends import("@triplit/db").RefShorthand ? K_11 extends import("@triplit/db").RelationshipRef<M, CN> ? import("@triplit/db").AliasedFetchResult<M, import("@triplit/db").RefDefinition<M, CN, K_11>["query"], import("@triplit/db").RefDefinition<M, CN, K_11>["cardinality"]> : never : never : never : never; } : never : never : never>[]>;
    transact(...args: Parameters<Client<M>['transact']>): Promise<unknown>;
    fetchById(...args: Parameters<Client<M>['fetchById']>): Promise<any>;
    fetchOne(...args: Parameters<Client<M>['fetchOne']>): Promise<import("@triplit/db").FetchResult<M, SchemaQuery<M>, "one">>;
    insert(...args: Parameters<Client<M>['insert']>): Promise<import("@triplit/db").Unalias<import("@triplit/db").Decoded<M[CollectionNameFromModels<M>]["schema"]>>>;
    update<CN extends CollectionNameFromModels<M>>(collectionName: CN, entityId: string, data: Partial<ReadModel<M, CN>>): Promise<void>;
    getSchema(): Promise<import("@triplit/db").DBSchema<M> | undefined>;
    delete(...args: Parameters<Client<M>['delete']>): Promise<void>;
    subscribe(...args: Parameters<Client<M>['subscribe']>): Promise<(() => void) & ComLink.ProxyMarked>;
    subscribeBackground<Q extends SchemaQuery<M>>(query: Q, options?: SubscribeBackgroundOptions): Promise<(() => void) & ComLink.ProxyMarked>;
    subscribeWithPagination(...args: Parameters<Client<M>['subscribeWithPagination']>): Promise<import("../types.js").PaginatedSubscription & ComLink.ProxyMarked>;
    subscribeWithExpand(...args: Parameters<Client<M>['subscribeWithExpand']>): Promise<import("../types.js").InfiniteSubscription & ComLink.ProxyMarked>;
    subscribeWithStatus(...args: Parameters<Client<M>['subscribeWithStatus']>): Promise<(() => void) & ComLink.ProxyMarked>;
    startSession(...args: Parameters<Client<M>['startSession']>): Promise<((() => void) & ComLink.ProxyMarked) | undefined>;
    endSession(...args: Parameters<Client<M>['endSession']>): Promise<void>;
    updateSessionToken(...args: Parameters<Client<M>['updateSessionToken']>): Promise<void>;
    onSessionError(...args: Parameters<Client<M>['onSessionError']>): (() => void) & ComLink.ProxyMarked;
    updateServerUrl(...args: Parameters<Client<M>['updateServerUrl']>): void;
    onSyncMessageReceived(...args: Parameters<NonNullable<typeof this.client>['onSyncMessageReceived']>): (() => void) & ComLink.ProxyMarked;
    onSyncMessageSent(...args: Parameters<NonNullable<typeof this.client>['onSyncMessageSent']>): (() => void) & ComLink.ProxyMarked;
    onEntitySyncSuccess(...args: Parameters<NonNullable<typeof this.client>['onEntitySyncSuccess']>): (() => void) & ComLink.ProxyMarked;
    onEntitySyncError(...args: Parameters<NonNullable<typeof this.client>['onEntitySyncError']>): (() => void) & ComLink.ProxyMarked;
    onFailureToSyncWrites(callback: (e: unknown) => void): () => void;
    onConnectionStatusChange(...args: Parameters<NonNullable<typeof this.client>['onConnectionStatusChange']>): (() => void) & ComLink.ProxyMarked;
    onVariablesChange(callback: VariablesChangeHandler): (() => void) & ComLink.ProxyMarked;
    connect(): Promise<void>;
    disconnect(): void;
    syncWrites(...args: Parameters<Client<M>['syncWrites']>): Promise<{
        didSync: boolean;
        syncFailureReason?: string;
    }>;
    isFirstTimeFetchingQuery(query: CollectionQuery<any, any>): Promise<boolean>;
    updateGlobalVariables(...args: Parameters<Client<M>['db']['updateGlobalVariables']>): Promise<void>;
    clear(options?: ClearOptions): Promise<void>;
    reset(options?: ClearOptions): Promise<void>;
}
export {};
