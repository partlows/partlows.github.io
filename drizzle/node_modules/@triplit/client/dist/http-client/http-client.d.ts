import { CollectionNameFromModels, FetchResult, Models, ReadModel, SchemaQuery, UpdatePayload, WriteModel } from '@triplit/db';
export type HttpClientOptions<M extends Models<M> = Models> = {
    serverUrl?: string;
    token?: string;
    schema?: M;
    schemaFactory?: () => M | Promise<M>;
};
export declare class HttpClient<M extends Models<M> = Models> {
    private options;
    constructor(options?: HttpClientOptions<M>);
    private _schemaInitialized;
    private schema;
    updateOptions(options: HttpClientOptions<M>): void;
    private sendRequest;
    fetch<Q extends SchemaQuery<M>>(query: Q): Promise<FetchResult<M, Q, 'many'>>;
    fetchOne<Q extends SchemaQuery<M>>(query: Q): Promise<FetchResult<M, Q, 'one'>>;
    fetchById<CN extends CollectionNameFromModels<M>>(collectionName: CN, id: string): Promise<FetchResult<M, {
        collectionName: CN;
    }, 'one'>>;
    insert<CN extends CollectionNameFromModels<M>>(collectionName: CN, object: WriteModel<M, CN>): Promise<ReadModel<M, CN>>;
    bulkInsert(bulk: BulkInsert<M>): Promise<BulkInsertResult<M>>;
    update<CN extends CollectionNameFromModels<M>>(collectionName: CN, id: string, update: UpdatePayload<M, CN>): Promise<any>;
    delete<CN extends CollectionNameFromModels<M>>(collectionName: CN, entityId: string): Promise<any>;
    deleteAll<CN extends CollectionNameFromModels<M>>(collectionName: CN): Promise<any>;
    query<CN extends CollectionNameFromModels<M>>(collectionName: CN): import("@triplit/db").QueryBuilder<M, CN, import("@triplit/db").WithInclusion<import("@triplit/db").CollectionQuery<M, CN>, {}>>;
}
export type BulkInsert<M extends Models<M> = Models> = {
    [CN in CollectionNameFromModels<M>]?: WriteModel<M, CN>[];
};
export type BulkInsertResult<M extends Models<M> = Models> = {
    [CN in CollectionNameFromModels<M>]?: ReadModel<M, CN>[];
};
