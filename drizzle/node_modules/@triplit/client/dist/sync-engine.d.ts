import { CollectionQuery } from '@triplit/db';
import { TriplitClient } from './client/triplit-client.js';
import { EntitySyncErrorCallback, ErrorCallback, OnMessageReceivedCallback, OnMessageSentCallback, OnSessionErrorCallback, SyncOptions, SyncStateCallback, TokenRefreshOptions } from './client/types';
import { Logger } from '@triplit/logger';
import { ConnectionStatus, TransportConnectParams } from './types.js';
type SyncSession = {
    serverUrl?: string;
    token: string;
    status: ConnectionStatus;
};
/**
 * The SyncEngine is responsible for managing the connection to the server and syncing data
 */
export declare class SyncEngine {
    private transport;
    private client;
    private connectionChangeHandlers;
    private messageReceivedSubscribers;
    private messageSentSubscribers;
    private sessionErrorSubscribers;
    private entitySyncErrorSubscribers;
    private entitySyncSuccessSubscribers;
    private onFailureToSyncWritesSubscribers;
    logger: Logger;
    private syncInProgress;
    private reconnectTimeoutDelay;
    private reconnectTimeout;
    private serverReady;
    currentSession: SyncSession | undefined;
    private queries;
    clientId: string | null;
    /**
     *
     * @param options configuration options for the sync engine
     * @param db the client database to be synced
     */
    constructor(client: TriplitClient<any>, options: SyncOptions);
    ping(): void;
    private sendChanges;
    /**
     * Handles a new token and update the sync connection accordingly.
     * - If the token is the same as the current session, it will just connect if `connect` is true.
     * - If the token is different, it will reset the current session and start a new one with the new token.
     */
    assignSessionToken(token: string | undefined, connect?: boolean, refreshOptions?: TokenRefreshOptions): Promise<(() => void) | undefined>;
    /**
     * Attempts to update the token of the current session, which re-use the current connection. If the new token does not have the same roles as the current session, an error will be thrown.
     */
    updateSessionToken(token: string): Promise<void>;
    private tokenRefreshTimer;
    resetTokenRefreshHandler(): void;
    /**
     * Manually send any pending writes to the remote database. This may be a no-op if:
     * - there is already a push in progress
     * - the connection is not open
     * - the server is not ready
     *
     * This will switch the active and inactive buffers if we are able to push
     *
     * If the push is successful, it will return `success: true`. If the push fails, it will return `success: false` and a `failureReason`.
     */
    syncWrites(): Promise<{
        didSync: boolean;
        syncFailureReason?: string;
    }>;
    /**
     * FOR INTERNAL USE ONLY, in most cases (even internally) you should use the safer `syncWrites` method
     *
     * This method will attempt to send the changes in the locked buffer to the server and mutates the `syncInProgress` state.
     */
    private trySyncLockedBuffer;
    private createRollbackBufferFromChanges;
    clearPendingChangesForEntity(collection: string, id: string): Promise<{
        didSync: boolean;
        syncFailureReason?: string;
    }>;
    clearPendingChangesAll(): Promise<void>;
    /**
     * @hidden
     */
    private updateTokenForSession;
    onSyncMessageReceived(callback: OnMessageReceivedCallback): () => void;
    onSyncMessageSent(callback: OnMessageSentCallback): () => void;
    onEntitySyncSuccess(collection: string, entityId: string, callback: () => void): () => void;
    onEntitySyncError(collection: string, entityId: string, callback: EntitySyncErrorCallback): () => void;
    onFailureToSyncWrites(callback: (e: unknown) => void): () => void;
    onSessionError(callback: OnSessionErrorCallback): () => void;
    getConnectionParams(): Promise<Partial<TransportConnectParams>>;
    isFirstTimeFetchingQuery(query: CollectionQuery<any, any>): Promise<boolean>;
    private markQueryAsSeen;
    /**
     * @hidden
     */
    subscribe(params: CollectionQuery<any, any>, options?: {
        onQueryFulfilled?: () => void;
        onQueryError?: ErrorCallback;
        onQuerySyncStateChange?: SyncStateCallback;
    }): Promise<() => void>;
    private connectQuery;
    hasServerRespondedForQuery(query: CollectionQuery<any, any>): boolean;
    /**
     * @hidden
     */
    disconnectQuery(id: string): void;
    /**
     * A hash of the last set of connected params, should not reconnect if the same params are used twice and the connection is already open
     */
    private lastParamsHash;
    connect(): Promise<void>;
    /**
     * Initiate a sync connection with the server
     */
    createConnection(session: SyncSession | undefined): void;
    private initializeSync;
    private onMessageHandler;
    private onOpenHandler;
    private onCloseHandler;
    private onErrorHandler;
    private lastKnownConnectionStatus;
    private fireConnectionChangeHandlers;
    /**
     * The current connection status of the sync engine
     */
    get connectionStatus(): ConnectionStatus;
    /**
     * Disconnect from the server
     */
    disconnect(): void;
    /**
     * Resets the server acks for remote queries.
     * On the next connection, queries will be re-sent to server as if there is no previous seen data.
     * If the connection is currently open, it will be closed and you will need to call `connect()` again.
     */
    resetQueryState(): void;
    /**
     * Resets all state related to a sync connection (so if we lose connection, this should reset)
     *
     * Marks all queries as unsent and resets the syncInProgress indicator, so on next connection we will re-send data to the server
     */
    private resetSyncConnectionState;
    private handleErrorMessage;
    private sendMessage;
    /**
     * Sets up a listener for connection status changes
     * @param callback A callback that will be called when the connection status changes
     * @param runImmediately Run the callback immediately with the current connection status
     * @returns A function that removes the callback from the connection status change listeners
     */
    onConnectionStatusChange(callback: (status: ConnectionStatus) => void, runImmediately?: boolean): () => void;
    private closeConnection;
    private resetReconnectTimeout;
    /**
     * @hidden
     */
    syncQuery(query: CollectionQuery<any, any>): Promise<unknown>;
    private validateSessionWithWarning;
}
export {};
