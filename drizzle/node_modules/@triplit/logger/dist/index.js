export const LOG_LEVELS = [
    'TRACE', // 1-4
    'DEBUG', // 5-8
    'INFO', // 9-12
    'WARN', // 13-16
    'ERROR', // 17-20
    'FATAL', // 21-24
];
const LOG_LEVEL_INDICES = Object.fromEntries(LOG_LEVELS.map((level, index) => [level, index]));
export const logLevelNumberToLevelName = (number) => {
    if (number < 5)
        return 'TRACE';
    if (number < 9)
        return 'DEBUG';
    if (number < 13)
        return 'INFO';
    if (number < 17)
        return 'WARN';
    if (number < 21)
        return 'ERROR';
    return 'FATAL';
};
/***************************************
 * DISPOSABLE SPAN WRAPPER
 * This is the object you get when you call `logger.trace(...)`.
 * It implements [Symbol.dispose] so that when you exit the `using` block,
 * it automatically calls logger.endSpan(...).
 ***************************************/
export class DisposableSpan {
    logger;
    spans;
    constructor(logger, spans) {
        this.logger = logger;
        this.spans = spans;
    }
    [Symbol.dispose]() {
        this.logger._endSpans(this.spans);
    }
}
/***************************************
 * LOGGER CLASS
 ***************************************/
export class Logger {
    handlers;
    loggerContext;
    resourceAttributes;
    exclusiveHandlerMode = false;
    constructor(handlers, resourceAttributes, logLevel = 'INFO') {
        // Provide a default ConsoleTransport if none supplied:
        this.handlers = handlers ?? [];
        // Resource attributes allow you to specify
        // things like service.name, service.version, etc.
        this.resourceAttributes = resourceAttributes || {};
        this.logLevel = logLevel;
    }
    registerHandler(handler, options) {
        if (this.exclusiveHandlerMode) {
            return false;
        }
        this.handlers.push(handler);
        if (options?.exclusive) {
            this.exclusiveHandlerMode = true;
        }
        return true;
    }
    /**
     * Create a new Logger that has a given context.
     * This context can represent a subsystem, feature, or namespace.
     */
    context(context) {
        const childLogger = new Logger(this.handlers, this.resourceAttributes, this.logLevel);
        childLogger.loggerContext = context;
        return childLogger;
    }
    logLevel = 'INFO';
    setLogLevel(level) {
        const formattedLevel = level.toUpperCase();
        if (LOG_LEVELS.includes(formattedLevel) ||
            formattedLevel === 'NONE') {
            this.logLevel = formattedLevel;
        }
    }
    /**
     * Catch all internal log method to dispatch to log handlers
     */
    _log(level, message, attributes) {
        if (this.logLevel === 'NONE')
            return;
        if (LOG_LEVEL_INDICES[level] < LOG_LEVEL_INDICES[this.logLevel])
            return;
        const record = {
            level,
            message,
            timestamp: Date.now(),
            context: this.loggerContext,
            attributes,
            resource: this.resourceAttributes,
        };
        // Send to all registered transports
        for (const handler of this.handlers) {
            try {
                handler.log(record);
            }
            catch (error) {
                console.error('Error in log handler:', error);
            }
        }
    }
    spanTrace(name, attributes) {
        // This method starts a "span" for tracing.
        // We'll return a DisposableSpan that calls endSpan upon disposal.
        const startedSpans = this.handlers.map((transport) => transport.startSpan(name, this.loggerContext, {
            ...this.resourceAttributes,
            ...attributes,
        }));
        return new DisposableSpan(this, startedSpans);
    }
    trace(message, attributes) {
        this._log('TRACE', message, attributes);
    }
    debug(message, attributes) {
        this._log('DEBUG', message, attributes);
    }
    // Using `info` is preferred
    log(message, attributes) {
        this.info(message, attributes);
    }
    info(message, attributes) {
        this._log('INFO', message, attributes);
    }
    warn(message, attributes) {
        this._log('WARN', message, attributes);
    }
    error(message, attributes) {
        this._log('ERROR', message, attributes);
    }
    fatal(message, attributes) {
        this._log('FATAL', message, attributes);
    }
    /*******************************
     * METRICS
     *******************************/
    /**
     * Emit a metric value to all transports.
     */
    metric(name, value, attributes) {
        for (const transport of this.handlers) {
            transport.recordMetric(name, value, {
                ...this.resourceAttributes,
                ...attributes,
            });
        }
    }
    /*******************************
     * INTERNAL SPAN HANDLING
     *******************************/
    /**
     * Called internally when a DisposableSpan goes out of scope
     * and triggers its [Symbol.dispose]() method.
     */
    _endSpans(spans) {
        for (let i = 0; i < spans.length; i++) {
            const span = spans[i];
            const transport = this.handlers[i];
            if (transport) {
                transport.endSpan(span);
            }
        }
    }
}
export const logger = new Logger();
