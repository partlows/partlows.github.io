export declare const LOG_LEVELS: readonly ["TRACE", "DEBUG", "INFO", "WARN", "ERROR", "FATAL"];
export type LogLevelName = (typeof LOG_LEVELS)[number];
export declare const logLevelNumberToLevelName: (number: number) => LogLevelName;
/***************************************
 * LOG RECORD INTERFACE
 ***************************************/
export interface LogRecord {
    level: LogLevelName;
    message: string;
    timestamp: number;
    context?: string;
    attributes?: Record<string, any>;
    resource?: Record<string, any>;
}
export interface LogHandler {
    /**
     * Handles a single LogRecord. For example, writing to console, file, or
     * sending to a remote logging service.
     */
    log(record: LogRecord): void;
    /**
     * Starts a new span for tracing.
     * Returns a handle/ID that can be used to end the span.
     */
    startSpan(name: string, context?: string, attributes?: Record<string, any>): any;
    /**
     * Ends an existing span (closing the trace).
     */
    endSpan(span: any): void;
    /**
     * Records a metric, e.g. gauge, counter, etc.
     */
    recordMetric(name: string, value: number, attributes?: Record<string, any>): void;
}
/***************************************
 * DISPOSABLE SPAN WRAPPER
 * This is the object you get when you call `logger.trace(...)`.
 * It implements [Symbol.dispose] so that when you exit the `using` block,
 * it automatically calls logger.endSpan(...).
 ***************************************/
export declare class DisposableSpan {
    private logger;
    private spans;
    constructor(logger: Logger, spans: any[]);
    [Symbol.dispose](): void;
}
/***************************************
 * LOGGER CLASS
 ***************************************/
export declare class Logger {
    private handlers;
    private loggerContext?;
    private resourceAttributes;
    exclusiveHandlerMode: boolean;
    constructor(handlers?: LogHandler[], resourceAttributes?: Record<string, any>, logLevel?: LogLevelName | 'NONE');
    registerHandler(handler: LogHandler, options?: {
        exclusive?: boolean;
    }): boolean;
    /**
     * Create a new Logger that has a given context.
     * This context can represent a subsystem, feature, or namespace.
     */
    context(context: string): Logger;
    private logLevel;
    setLogLevel(level: string): void;
    /**
     * Catch all internal log method to dispatch to log handlers
     */
    _log(level: LogLevelName, message: string, attributes?: Record<string, any>): void;
    spanTrace(name: string, attributes?: Record<string, any>): DisposableSpan;
    trace(message: string, attributes?: Record<string, any>): void;
    debug(message: string, attributes?: Record<string, any>): void;
    log(message: string, attributes?: Record<string, any>): void;
    info(message: string, attributes?: Record<string, any>): void;
    warn(message: string, attributes?: Record<string, any>): void;
    error(message: string, attributes?: Record<string, any>): void;
    fatal(message: string, attributes?: Record<string, any>): void;
    /*******************************
     * METRICS
     *******************************/
    /**
     * Emit a metric value to all transports.
     */
    metric(name: string, value: number, attributes?: Record<string, any>): void;
    /*******************************
     * INTERNAL SPAN HANDLING
     *******************************/
    /**
     * Called internally when a DisposableSpan goes out of scope
     * and triggers its [Symbol.dispose]() method.
     */
    _endSpans(spans: any[]): void;
}
export declare const logger: Logger;
