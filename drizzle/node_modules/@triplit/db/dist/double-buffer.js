import { mergeDBChanges } from './memory-write-buffer.js';
import { deepObjectAssign } from './utils/deep-merge.js';
export class KVDoubleBuffer {
    _buffers;
    activeBufferIndex = 0;
    constructor(buffer0, buffer1) {
        this._buffers = [buffer0, buffer1];
    }
    get activeBuffer() {
        return this._buffers[this.activeBufferIndex];
    }
    get inactiveBuffer() {
        return this._buffers[1 - this.activeBufferIndex];
    }
    async getChangesForCollection(storage, collectionName) {
        const [inactiveBufferChanges, activeBufferChanges] = await Promise.all([
            this.inactiveBuffer.getChangesForCollection(storage, collectionName),
            this.activeBuffer.getChangesForCollection(storage, collectionName),
        ]);
        if (!inactiveBufferChanges && !activeBufferChanges) {
            return undefined;
        }
        if (!inactiveBufferChanges) {
            return activeBufferChanges;
        }
        if (!activeBufferChanges) {
            return inactiveBufferChanges;
        }
        return mergeDBChanges({}, { [collectionName]: inactiveBufferChanges }, { [collectionName]: activeBufferChanges })[collectionName];
    }
    async getChangesForEntity(storage, collection, id) {
        const inactiveBufferEntityChanges = await this.inactiveBuffer.getChangesForEntity(storage, collection, id);
        const activeBufferEntityChanges = await this.activeBuffer.getChangesForEntity(storage, collection, id);
        if (!inactiveBufferEntityChanges && !activeBufferEntityChanges) {
            return undefined;
        }
        // TODO: is this correct?
        const _delete = !!(inactiveBufferEntityChanges?.delete || activeBufferEntityChanges?.delete);
        const update = deepObjectAssign({}, inactiveBufferEntityChanges?.update, activeBufferEntityChanges?.update);
        return { update, delete: _delete };
    }
    async clear(tx) {
        await Promise.all(this._buffers.map((buffer) => buffer.clear(tx)));
    }
    // TODO: determine the semantics of clearing entity changes
    // on a double buffer. should it just affect the unlocked buffer?
    async clearChangesForEntity(tx, collectionName, id) {
        await Promise.all(this._buffers.map((buffer) => buffer.clearChangesForEntity(tx, collectionName, id)));
    }
    async write(tx, changes) {
        await this.activeBuffer.write(tx, changes);
    }
    async isEmpty(storage) {
        return (await Promise.all([
            this.activeBuffer.isEmpty(storage),
            this.inactiveBuffer.isEmpty(storage),
        ])).every((isEmpty) => isEmpty);
    }
    async getChanges(storage) {
        const changes = await Promise.all([
            this.getLockedBuffer().getChanges(storage),
            this.getUnlockedBuffer().getChanges(storage),
        ]);
        return mergeDBChanges({}, changes[0], changes[1]);
    }
    lockAndSwitchBuffers() {
        this.activeBufferIndex = this.activeBufferIndex === 0 ? 1 : 0;
    }
    getLockedBuffer() {
        return this.inactiveBuffer;
    }
    getUnlockedBuffer() {
        return this.activeBuffer;
    }
}
//# sourceMappingURL=double-buffer.js.map