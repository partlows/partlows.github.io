import { EntityMetadataStore } from './entity-metadata-store.js';
import { EntityDataStore } from './entity-data-store.js';
export class EntityStoreKV {
    storagePrefix;
    metadataStore;
    dataStore;
    constructor(storagePrefix = []) {
        this.storagePrefix = storagePrefix;
        this.metadataStore = new EntityMetadataStore([
            ...this.storagePrefix,
            'metadata',
        ]);
        this.dataStore = new EntityDataStore([...this.storagePrefix, 'data']); // storage.scope(['data'])
    }
    async applyChanges(tx, buffer, options) {
        return this.dataStore.applyChanges(tx, buffer, options);
    }
    async applyChangesWithTimestamp(tx, buffer, timestamp, options) {
        // This implicitly updates metadata
        const prunedChanges = await this.metadataStore.applyChanges(tx, buffer, timestamp);
        return this.dataStore.applyChanges(tx, prunedChanges, options);
    }
    // We make no guarantees that the entity is full (Insert type) or partial (Update type)
    // Because null may represent an update (ie delete), this should return undefined to indicate no changes
    async getEntity(storage, collection, id) {
        return this.dataStore.getEntity(storage, collection, id);
    }
    getEntitiesInCollection(storage, collection) {
        return this.dataStore.getEntitiesInCollection(storage, collection);
    }
    getCollectionStats(storage, knownCollections) {
        return this.dataStore.getCollectionStats(storage, knownCollections);
    }
}
//# sourceMappingURL=entity-store.js.map