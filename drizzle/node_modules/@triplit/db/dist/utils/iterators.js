export function* iterFromIndex(array, index) {
    for (let i = index; i < array.length; i++) {
        yield array[i];
    }
}
export function* iterFilter(iterator, predicate) {
    for (const value of iterator) {
        if (predicate(value)) {
            yield value;
        }
    }
}
export function* iterConcat(...iterators) {
    for (const iterator of iterators) {
        for (const value of iterator) {
            yield value;
        }
    }
}
export function* iterUnique(iterator) {
    const seen = new Set();
    for (const value of iterator) {
        if (!seen.has(value)) {
            seen.add(value);
            yield value;
        }
    }
}
export function* iterMap(iterator, mapper) {
    for (const value of iterator) {
        yield mapper(value);
    }
}
// Return an empty iterator
export function iterEmpty() {
    return (function* () { })();
}
// AsyncIterable
export async function* asyncIterTake(iterator, count) {
    let i = 0;
    for await (const result of iterator) {
        if (i >= count) {
            return;
        }
        yield result;
        i++;
    }
}
export async function* asyncIterFilter(iterator, predicate) {
    for await (const result of iterator) {
        if (await predicate(result)) {
            yield result;
        }
    }
}
export async function* asyncIterConcat(...iterators) {
    for (const iterator of iterators) {
        for await (const result of iterator) {
            yield result;
        }
    }
}
export async function* asyncIterUnique(iterator, getId) {
    const seen = new Set();
    for await (const result of iterator) {
        const id = getId ? getId(result) : result;
        if (!seen.has(id)) {
            seen.add(id);
            yield result;
        }
    }
}
export async function* asyncIterMap(iterator, mapper) {
    for await (const item of iterator) {
        yield mapper(item);
    }
}
export async function asyncIterEvery(iterator, predicate) {
    // TODO: look into using sync iterator when possible
    for await (const item of iterator) {
        if (!(await predicate(item))) {
            return false;
        }
    }
    return true;
}
export async function asyncIterSome(iterator, predicate) {
    for await (const item of iterator) {
        if (await predicate(item)) {
            return true;
        }
    }
    return false;
}
//# sourceMappingURL=iterators.js.map