const MB1 = 1024 * 1024;
const GB1 = 1024 * MB1;
export const STATEMENTS = Object.freeze({
    /**
     * Create the table if it doesn't exist.
     *
     * We use `WITHOUT ROWID` to create a clustered index on the `key` column to improve locality during range scans.
     */
    createTable: 'CREATE TABLE IF NOT EXISTS data (key TEXT PRIMARY KEY, value TEXT) WITHOUT ROWID',
    get: 'SELECT value FROM data WHERE key = ?',
    scan: 'SELECT key, value FROM data WHERE key >= ? AND key < ?',
    scanValues: 'SELECT value FROM data WHERE key >= ? AND key < ?',
    count: 'SELECT COUNT(*) FROM data',
    countRange: 'SELECT COUNT(*) FROM data WHERE key >= ? AND key < ?',
    set: 'INSERT OR REPLACE INTO data VALUES (?, ?)',
    delete: 'DELETE FROM data WHERE key = ?',
    deleteRange: 'DELETE FROM data WHERE key >= ? AND key < ?',
    truncate: 'DELETE FROM data',
});
export const CHECKPOINT_RESTART = 'PRAGMA wal_checkpoint(RESTART);';
export const CHECKPOINT_TRUNCATE = 'PRAGMA wal_checkpoint(TRUNCATE);';
export function parseSqliteKvStoreOptions(options) {
    const storageSize = options.storageSize || 5 * GB1;
    const journalSizeLimit = options.journalSizeLimit || defaultJournalSizeLimit(storageSize);
    const walAutocheckpoint = options.walAutocheckpoint || defaultWalAutocheckpoint(journalSizeLimit);
    const checkpointRestart = options.checkpointRestart || defaultCheckpointRestart(storageSize);
    const checkpointTruncate = options.checkpointTruncate || defaultCheckpointTruncate(storageSize);
    return {
        storageSize,
        journalSizeLimit,
        walAutocheckpoint,
        checkpointRestart,
        checkpointTruncate,
        pragma: defaultPragma(walAutocheckpoint, journalSizeLimit) +
            (options.pragma || ''),
    };
}
// Reasonable heuristic ≈ 2.5 % storage
function defaultJournalSizeLimit(storageSize) {
    return Math.floor(storageSize * 0.025);
}
// Reasonable heuristic ≈ journal_size_limit / page_size
function defaultWalAutocheckpoint(journalSizeLimit) {
    const pageSize = 4096; // default page size, TODO: make this configurable
    return Math.floor(journalSizeLimit / pageSize);
}
// Reasonable heuristic ≈ 5 % storage
function defaultCheckpointRestart(storageSize) {
    return Math.floor(storageSize * 0.05);
}
// Reasonable heuristic ≈ 20 % storage
function defaultCheckpointTruncate(storageSize) {
    return Math.floor(storageSize * 0.2);
}
/**
 * journal_mode = WAL: Use Write-Ahead Logging (WAL) mode for better concurrency.
 * synchronous = NORMAL: In WAL mode, provides best performance with durability guarantees.
 * temp_store = memory: Use memory for temporary tables and indexes.
 * mmap_size: Set the memory-mapped I/O size to 256MB for better performance. TODO: 256MB is a reasonable default, make this configurable.
 * wal_autocheckpoint: The number of pages in the WAL file that will trigger a (PASSIVE) checkpoint.
 * journal_size_limit: The maximum size of the WAL file before it is truncated.
 */
function defaultPragma(walAutocheckpoint, journalSizeLimit) {
    return `
    PRAGMA journal_mode = WAL;
    PRAGMA synchronous = NORMAL;
    PRAGMA temp_store = memory;
    PRAGMA mmap_size = ${256 * MB1};
    PRAGMA wal_autocheckpoint  = ${walAutocheckpoint};
    PRAGMA journal_size_limit  = ${journalSizeLimit};
  `;
}
//# sourceMappingURL=sqlite.js.map