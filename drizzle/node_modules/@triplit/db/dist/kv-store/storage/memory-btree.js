import { compareTuple } from '../../codec.js';
import BTree_ from 'sorted-btree';
// @ts-expect-error - BTree import broken
const BTree = ('default' in BTree_ ? BTree_.default : BTree_);
import { MemoryTransaction } from '../transactions/memory-tx.js';
import { debugFreeze } from '../../macros/debug.js';
import { ScopedKVStore } from '../utils/scoped-store.js';
export class BTreeKVStore {
    data;
    constructor(data) {
        this.data =
            data ??
                // @ts-expect-error - BTree import broken
                new BTree(undefined, compareTuple);
    }
    get(key, scope) {
        const fullKey = scope ? [...scope, ...key] : key;
        return Promise.resolve(this.data.get(fullKey));
    }
    set(key, value, scope) {
        const fullKey = scope ? [...scope, ...key] : key;
        debugFreeze(value);
        this.data.set(fullKey, value);
        return Promise.resolve();
    }
    delete(key, scope) {
        const fullKey = scope ? [...scope, ...key] : key;
        this.data.delete(fullKey);
        return Promise.resolve();
    }
    // @ts-expect-error - not returning async iter
    *scan(options, scope) {
        const low = scope ? [...scope, ...options.prefix] : options.prefix;
        const high = [...low, '\uffff'];
        const results = [];
        this.data.forRange(low, high, false, (key, value) => {
            const prefixLength = (scope?.length ?? 0) + options.prefix.length;
            const keyWithoutPrefix = prefixLength > 0 ? key.slice(prefixLength) : key;
            if (keyWithoutPrefix.length === 0)
                return;
            results.push([keyWithoutPrefix, value]);
        });
        yield* results;
    }
    // @ts-expect-error - not returning async iter
    *scanValues(options, scope) {
        const low = scope ? [...scope, ...options.prefix] : options.prefix;
        const high = [...low, '\uffff'];
        const results = [];
        this.data.forRange(low, high, false, (_key, value) => {
            results.push(value);
        });
        yield* results;
    }
    count(options, scope) {
        const low = scope ? [...scope, ...options.prefix] : options.prefix;
        if (!low.length) {
            return this.data.size;
        }
        const high = [...low, '\uffff'];
        return this.data.forRange(low, high, false);
        // let count = 0;
        // this.data.forRange(low, high, false, () => {
        //   count++;
        // });
        // return Promise.resolve(count);
    }
    transact() {
        return new MemoryTransaction(this);
    }
    async clear(scope) {
        if (!scope?.length) {
            this.data.clear();
            return;
        }
        for await (const [key] of this.scan({ prefix: scope })) {
            await this.delete(key, scope);
        }
    }
    scope(prefix) {
        return new ScopedKVStore(this, prefix);
    }
    async applyEdits(sets, deletes) {
        for await (const key of deletes) {
            this.data.delete(key);
        }
        for await (const [key, value] of sets) {
            this.data.set(key, value);
        }
    }
}
//# sourceMappingURL=memory-btree.js.map