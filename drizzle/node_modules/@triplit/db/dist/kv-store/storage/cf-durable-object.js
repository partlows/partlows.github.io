import { decodeTuple, encodeTuple, } from '../../index.js';
import { MemoryTransaction } from '../transactions/memory-tx.js';
import { ScopedKVStore } from '../utils/scoped-store.js';
import { STATEMENTS } from '../utils/sqlite.js';
export class CloudflareDurableObjectKVStore {
    sql;
    constructor(database) {
        this.sql = database.sql;
        this.sql.exec(STATEMENTS.createTable);
    }
    scope(scope) {
        return new ScopedKVStore(this, scope);
    }
    transact() {
        return new MemoryTransaction(this);
    }
    async applyEdits(sets, deletes) {
        for await (const key of deletes) {
            await this.delete(key);
        }
        for await (const [key, value] of sets) {
            await this.set(key, value);
        }
        return Promise.resolve();
    }
    get(key, scope) {
        const fullKey = scope ? [...scope, ...key] : key;
        const encodedKey = encodeTuple(fullKey);
        const result = this.sql.exec(STATEMENTS.get, encodedKey).next();
        if (result.done) {
            return Promise.resolve(undefined);
        }
        // @ts-expect-error
        return Promise.resolve(JSON.parse(result.value.value));
    }
    set(key, value, scope) {
        const fullKey = scope ? [...scope, ...key] : key;
        const encodedKey = encodeTuple(fullKey);
        this.sql.exec(STATEMENTS.set, encodedKey, JSON.stringify(value));
        return Promise.resolve();
    }
    delete(key, scope) {
        const fullKey = scope ? [...scope, ...key] : key;
        const encodedKey = encodeTuple(fullKey);
        this.sql.exec(STATEMENTS.delete, encodedKey);
        return Promise.resolve();
    }
    async *scan(options, scope) {
        const low = scope
            ? encodeTuple([...scope, ...options.prefix])
            : encodeTuple(options.prefix);
        const high = low + '\uffff';
        const results = this.sql.exec(STATEMENTS.scan, low, high);
        for (const row of results) {
            const { key, value } = row;
            const decodedKey = decodeTuple(key);
            const prefixLength = (scope?.length ?? 0) + options.prefix.length;
            const keyWithoutPrefix = prefixLength > 0 ? decodedKey.slice(prefixLength) : decodedKey;
            if (keyWithoutPrefix.length === 0)
                continue;
            yield [keyWithoutPrefix, JSON.parse(value)];
        }
    }
    async *scanValues(options, scope) {
        const low = scope
            ? encodeTuple([...scope, ...options.prefix])
            : encodeTuple(options.prefix);
        const high = low + '\uffff';
        const results = this.sql.exec(STATEMENTS.scanValues, low, high);
        for (const row of results) {
            const { value } = row;
            yield JSON.parse(value);
        }
    }
    async clear(scope) {
        if (!scope?.length) {
            this.sql.exec(STATEMENTS.truncate);
            return;
        }
        const low = encodeTuple(scope);
        const high = low + '\uffff';
        this.sql.exec(STATEMENTS.deleteRange, low, high);
    }
    async count(options, scope) {
        const fullPrefix = scope ? [...scope, ...options.prefix] : options.prefix;
        if (!fullPrefix.length) {
            return this.sql.exec(STATEMENTS.count).one()[COUNT_KEY];
        }
        const low = encodeTuple(fullPrefix);
        const high = low + '\uffff';
        const result = this.sql.exec(STATEMENTS.countRange, low, high);
        return result.one()[COUNT_KEY];
    }
}
const COUNT_KEY = 'COUNT(*)';
//# sourceMappingURL=cf-durable-object.js.map