import type { Database } from 'better-sqlite3';
import { CountOptions, KVStore, KVStoreTransaction, ScanOptions } from '../../types.js';
import { Tuple } from '../../codec.js';
import { SQLiteKVStoreOptions } from '../utils/sqlite.js';
/**
 * Performance notes:
 * - WITHOUT ROWID makes our range scans pretty fast in SQLite
 * - With large data / scans, the bottleneck becomes getting data into javascript in the correct format
 *  - stmt.pluck(true) the `value` column in the scan query (if you dont need the key value) to just get a string array right off the bat
 *  - patch better-sqlite3 to parse JSON values directly (seems possible, could add some api to know which strings should be parsed that way)
 *    - Saves us the cost of SQLite -> string -> JSON.parse()
 */
export declare class SQLiteKVStore implements KVStore {
    private statements;
    private transactions;
    db: Database;
    private walGuard?;
    constructor(db: Database, options?: SQLiteKVStoreOptions);
    private startWalGuard;
    private createTable;
    /**
     * If a statement is busy, we will prepare a new one to use temporarily
     * A statement may be busy if it is being iterated over (and we are performing a subquery on top of tha=7890-)
     * A further optimzation would be to use a pool of statements or a stack of statements
     * If we start to notice `prepare` taking up time in the profiler, we should probably do that
     */
    private freeStatement;
    get(key: Tuple, scope?: Tuple): Promise<any>;
    set(key: Tuple, value: any, scope?: Tuple): Promise<void>;
    delete(key: Tuple, scope?: Tuple): Promise<void>;
    scan(options: ScanOptions, scope?: Tuple): AsyncIterable<[Tuple, any]>;
    scanValues(options: ScanOptions, scope?: Tuple): AsyncIterable<any>;
    count(options: CountOptions, scope?: Tuple): Promise<number>;
    clear(scope?: Tuple): Promise<void>;
    scope(scope: Tuple): KVStore;
    transact(): KVStoreTransaction;
    applyEdits(sets: AsyncIterable<[Tuple, any]> | Iterable<[Tuple, any]>, deletes: AsyncIterable<Tuple> | Iterable<Tuple>): Promise<void>;
}
