import { MemoryTransaction } from '../transactions/memory-tx.js';
import { TriplitError } from '../../errors.js';
import { ScopedKVStore } from '../utils/scoped-store.js';
export class LmdbKVStore {
    db;
    constructor(db) {
        this.db = db;
    }
    get(key, scope) {
        const fullKey = (scope ? [...scope, ...key] : key);
        return this.db.get(fullKey);
    }
    async set(key, value, scope) {
        const fullKey = (scope ? [...scope, ...key] : key);
        await this.db.put(fullKey, value);
        return Promise.resolve();
    }
    async delete(key, scope) {
        const fullKey = (scope ? [...scope, ...key] : key);
        await this.db.remove(fullKey);
        return Promise.resolve();
    }
    async *scan(options, scope) {
        const start = (scope ? [...scope, ...options.prefix] : options.prefix);
        const end = [...start, '\uffff'];
        for await (const { key, value } of this.db.getRange({ start, end })) {
            // LMDB seeming converts keys with one element to a string
            if (typeof key === 'string') {
                yield [[key], value];
                continue;
            }
            if (Array.isArray(key)) {
                const prefixLength = (scope?.length ?? 0) + options.prefix.length;
                const keyWithoutPrefix = prefixLength > 0 ? key.slice(prefixLength) : key;
                if (keyWithoutPrefix.length === 0)
                    continue;
                yield [keyWithoutPrefix, value];
                continue;
            }
            throw new TriplitError('Unable to decode key from LMDB');
        }
    }
    async *scanValues(options, scope) {
        const start = (scope ? [...scope, ...options.prefix] : options.prefix);
        const end = [...start, '\uffff'];
        for await (const { value } of this.db.getRange({ start, end })) {
            yield value;
        }
    }
    async count(options, scope) {
        const start = (scope ? [...scope, ...options.prefix] : options.prefix);
        const end = [...start, '\uffff'];
        let count = 0;
        for await (const _ of this.db.getRange({ start, end })) {
            count++;
        }
        return count;
    }
    transact() {
        return new MemoryTransaction(this);
    }
    async clear(scope) {
        if (!scope?.length) {
            return await this.db.clearAsync();
        }
        await this.db.transaction(async () => {
            for await (const [key] of this.scan({ prefix: [] }, scope)) {
                await this.delete(key, scope);
            }
        });
    }
    scope(scope) {
        return new ScopedKVStore(this, scope);
    }
    async applyEdits(sets, deletes) {
        await this.db.transaction(async () => {
            for await (const key of deletes) {
                await this.db.remove(key);
            }
            for await (const [key, value] of sets) {
                await this.db.put(key, value);
            }
        });
    }
}
//# sourceMappingURL=lmdb.js.map