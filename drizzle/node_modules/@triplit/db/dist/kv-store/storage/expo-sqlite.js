import { decodeTuple, encodeTuple } from '../../codec.js';
import * as SQLite from 'expo-sqlite';
import { parseSqliteKvStoreOptions, STATEMENTS, } from '../utils/sqlite.js';
import { MemoryTransaction } from '../transactions/memory-tx.js';
import { ScopedKVStore } from '../utils/scoped-store.js';
export class ExpoSQLiteKVStore {
    storeReady;
    constructor(arg0, options = {}) {
        let dbPromise;
        if (typeof arg0 === 'string') {
            dbPromise = SQLite.openDatabaseAsync(arg0);
        }
        else {
            dbPromise = Promise.resolve(arg0);
        }
        const parsedOptions = parseSqliteKvStoreOptions(options);
        this.storeReady = dbPromise.then(async (db) => {
            await db.execAsync(parsedOptions.pragma);
            // TODO: promise.all the prepares?
            const createTableStatement = await db.prepareAsync(STATEMENTS.createTable);
            createTableStatement.executeAsync();
            return {
                db,
                statements: {
                    createTable: createTableStatement,
                    get: await db.prepareAsync(STATEMENTS.get),
                    set: await db.prepareAsync(STATEMENTS.set),
                    delete: await db.prepareAsync(STATEMENTS.delete),
                    deleteRange: await db.prepareAsync(STATEMENTS.deleteRange),
                    scan: await db.prepareAsync(STATEMENTS.scan),
                    scanValues: await db.prepareAsync(STATEMENTS.scanValues),
                    count: await db.prepareAsync(STATEMENTS.count),
                    countRange: await db.prepareAsync(STATEMENTS.countRange),
                    truncate: await db.prepareAsync(STATEMENTS.truncate),
                },
            };
        });
    }
    scope(scope) {
        return new ScopedKVStore(this, scope);
    }
    transact() {
        return new MemoryTransaction(this);
    }
    async applyEdits(sets, deletes) {
        const { db, statements } = await this.storeReady;
        await db.withExclusiveTransactionAsync(async () => {
            for await (const [key, value] of sets) {
                const encodedKey = encodeTuple(key);
                const encodedValue = JSON.stringify(value);
                await statements.set.executeAsync(encodedKey, encodedValue);
            }
            for await (const key of deletes) {
                const encodedKey = encodeTuple(key);
                await statements.delete.executeAsync(encodedKey);
            }
        });
    }
    async get(key, scope) {
        const { statements } = await this.storeReady;
        const fullKey = scope ? [...scope, ...key] : key;
        const encodedKey = encodeTuple(fullKey);
        const row = await (await statements.get.executeAsync(encodedKey)).getFirstAsync();
        if (!row)
            return undefined;
        return JSON.parse(
        // @ts-expect-error
        row.value);
    }
    async set(key, value, scope) {
        const { statements } = await this.storeReady;
        const fullKey = scope ? [...scope, ...key] : key;
        const encodedKey = encodeTuple(fullKey);
        const encodedValue = JSON.stringify(value);
        await statements.set.executeAsync(encodedKey, encodedValue);
    }
    async delete(key, scope) {
        const { statements } = await this.storeReady;
        const fullKey = scope ? [...scope, ...key] : key;
        const encodedKey = encodeTuple(fullKey);
        await statements.delete.executeAsync(encodedKey);
    }
    async *scan(options, scope) {
        const { statements } = await this.storeReady;
        const low = scope
            ? encodeTuple([...scope, ...options.prefix])
            : encodeTuple(options.prefix);
        const high = low + '\uffff';
        const results = await statements.scan.executeAsync(low, high);
        for await (const row of results) {
            const key = decodeTuple(
            // @ts-expect-error
            row.key);
            const prefixLength = (scope?.length ?? 0) + options.prefix.length;
            const keyWithoutPrefix = prefixLength > 0 ? key.slice(prefixLength) : key;
            if (keyWithoutPrefix.length === 0)
                continue;
            yield [
                keyWithoutPrefix,
                JSON.parse(
                // @ts-expect-error
                row.value),
            ];
        }
    }
    async *scanValues(options, scope) {
        const { statements } = await this.storeReady;
        const low = scope
            ? encodeTuple([...scope, ...options.prefix])
            : encodeTuple(options.prefix);
        const high = low + '\uffff';
        const results = await statements.scanValues.executeForRawResultAsync(low, high);
        for await (const row of results) {
            yield JSON.parse(row[0]);
        }
    }
    async count(options, scope) {
        const { statements } = await this.storeReady;
        const fullPrefix = scope ? [...scope, ...options.prefix] : options.prefix;
        if (!fullPrefix.length) {
            return (await (await statements.count.executeForRawResultAsync()).getFirstAsync())?.[0];
        }
        const low = encodeTuple(fullPrefix);
        const high = low + '\uffff';
        return (await (await statements.countRange.executeForRawResultAsync(low, high)).getFirstAsync())?.[0];
    }
    async clear(scope) {
        const { statements } = await this.storeReady;
        // if we know that this is not a scoped store, we can just delete everything
        if (!scope?.length) {
            await statements.truncate.executeAsync();
            return;
        }
        const low = encodeTuple(scope);
        const high = low + '\uffff';
        await statements.deleteRange.executeAsync(low, high);
    }
}
//# sourceMappingURL=expo-sqlite.js.map