import { FilterStatement, PreparedOrder, PreparedQuery, PreparedWhere, QueryAfter } from '../types.js';
import { StaticFilter } from '../filters.js';
export interface RelationalPlan {
    views: Record<string, PreparedQuery>;
    rootQuery: PreparedQuery;
}
export type AfterFilter = {
    after: QueryAfter;
    order: PreparedOrder;
};
export type Step = {
    type: 'SCAN';
    collectionName: string;
} | {
    type: 'ID_LOOK_UP';
    collectionName: string;
    ids: string | string[];
} | {
    type: 'RESOLVE_FROM_VIEW';
    viewId: string;
    filter: FilterStatement[];
} | {
    type: 'COLLECT';
} | {
    type: 'ITERATOR_FILTER';
    filter: StaticFilter[];
    after?: AfterFilter;
} | {
    type: 'ITERATOR_LIMIT';
    count: number;
} | {
    type: 'ITERATOR_SUBQUERY_FILTER';
    subPlan: Step[];
} | {
    type: 'FILTER';
    filter: StaticFilter[];
    after?: AfterFilter;
} | {
    type: 'SORT';
    fields: PreparedOrder;
} | {
    type: 'LIMIT';
    count: number;
} | {
    type: 'PREPARE_VIEW';
    viewId: string;
} | {
    type: 'SUBQUERY';
    alias: string;
    subPlan: Step[];
} | {
    type: 'PICK';
};
export interface ViewResultRef {
    type: 'VIEW_RESULT_IDS';
    viewId: string;
    field: string;
}
export interface CompiledPlan {
    steps: Step[];
    views: Record<string, CompiledPlan>;
}
export declare function extractViews(query: PreparedQuery, generateViewId: () => string): RelationalPlan;
export declare function compileQuery(query: PreparedQuery): CompiledPlan;
export declare function compileRelationalPlan(relPlan: RelationalPlan): CompiledPlan;
export declare function statementHasViewReference(filter: FilterStatement): filter is FilterStatement;
export declare function extractInvertedViews(query: PreparedQuery): {
    rewrittenQuery: PreparedQuery;
    views: HashedViewMap;
};
export type HashedViewMap = Map<number, PreparedQuery>;
export declare function extractedInvertedViewsFromFilters(where: PreparedWhere): {
    where: PreparedWhere;
    views: Map<number, PreparedQuery>;
};
