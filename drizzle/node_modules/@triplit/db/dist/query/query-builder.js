import { AfterClauseWithNoOrderError, QueryClauseFormattingError, } from '../errors.js';
import { isFilterStatement, isIdFilter, isWhereFilter } from '../filters.js';
import { ValuePointer } from '../utils/value-pointer.js';
export function queryBuilder(collectionName) {
    return new QueryBuilder(collectionName);
}
export class QueryBuilder {
    collectionName;
    select = undefined;
    where = undefined;
    limit = undefined;
    order = undefined;
    include = undefined;
    after = undefined;
    vars = undefined;
    constructor(collectionName, query) {
        this.collectionName = collectionName;
        if (query) {
            this.select = query.select;
            this.where = query.where;
            this.limit = query.limit;
            this.order = query.order;
            this.include = query.include;
            this.after = query.after;
            this.vars = query.vars;
        }
    }
    Select(value) {
        const select = value;
        return new QueryBuilder(this.collectionName, 
        // @ts-expect-error
        {
            ...this,
            select,
        });
    }
    Where(...args) {
        const where = QUERY_INPUT_TRANSFORMERS().where(this, ...args);
        return new QueryBuilder(this.collectionName, 
        // @ts-expect-error
        {
            ...this,
            where,
        });
    }
    Id(value) {
        const where = this.where ? this.where.filter((f) => !isIdFilter(f)) : [];
        where.push(
        // @ts-expect-error
        ['id', '=', value]);
        return new QueryBuilder(this.collectionName, 
        // @ts-expect-error
        {
            ...this,
            where,
        });
    }
    Limit(value) {
        const limit = value;
        return new QueryBuilder(this.collectionName, 
        // @ts-expect-error
        {
            ...this,
            limit,
        });
    }
    Order(...args) {
        const order = QUERY_INPUT_TRANSFORMERS().order(this, ...args);
        return new QueryBuilder(this.collectionName, 
        // @ts-expect-error
        {
            ...this,
            order,
        });
    }
    After(value, inclusive) {
        const after = QUERY_INPUT_TRANSFORMERS().after(this, value, inclusive);
        return new QueryBuilder(this.collectionName, 
        // @ts-expect-error
        {
            ...this,
            after,
        });
    }
    Vars(value) {
        const vars = value;
        return new QueryBuilder(this.collectionName, 
        // @ts-expect-error
        {
            ...this,
            vars,
        });
    }
    Include(alias, queryExt) {
        if (typeof queryExt === 'function') {
            queryExt = queryExt(relationBuilder);
        }
        const include = QUERY_INPUT_TRANSFORMERS().include(this, alias, queryExt);
        return new QueryBuilder(this.collectionName, 
        // @ts-expect-error
        {
            ...this,
            include,
        });
    }
    SubqueryOne(alias, subquery) {
        if (typeof subquery === 'function') {
            subquery = subquery(queryBuilder);
        }
        const include = QUERY_INPUT_TRANSFORMERS().include(this, alias, {
            subquery,
            cardinality: 'one',
        });
        return new QueryBuilder(this.collectionName, 
        // @ts-expect-error
        {
            ...this,
            include,
        });
    }
    SubqueryMany(alias, subquery) {
        if (typeof subquery === 'function') {
            subquery = subquery(queryBuilder);
        }
        const include = QUERY_INPUT_TRANSFORMERS().include(this, alias, {
            subquery,
            cardinality: 'many',
        });
        return new QueryBuilder(this.collectionName, 
        // @ts-expect-error
        {
            ...this,
            include,
        });
    }
}
export function relationBuilder(ref) {
    return new RelationBuilder(ref);
}
export class RelationBuilder {
    _extends;
    select = undefined;
    where = undefined;
    limit = undefined;
    order = undefined;
    include = undefined;
    constructor(ref, query) {
        this._extends = ref;
        if (query) {
            this.select = query.select;
            this.where = query.where;
            this.limit = query.limit;
            this.order = query.order;
            this.include = query.include;
        }
    }
    // TODO: add back include
    // TOOD: fixup types once you have included return types set up
    Select(value) {
        const select = value;
        return new RelationBuilder(this._extends, 
        // @ts-expect-error
        {
            ...this,
            select,
        });
    }
    Where(...args) {
        const where = QUERY_INPUT_TRANSFORMERS().where(this, ...args);
        return new RelationBuilder(this._extends, 
        // @ts-expect-error
        {
            ...this,
            where,
        });
    }
    Id(id) {
        const where = this.where ? this.where.filter((f) => !isIdFilter(f)) : [];
        where.push(
        // @ts-expect-error
        ['id', '=', id]);
        return new RelationBuilder(this._extends, 
        // @ts-expect-error
        {
            ...this,
            where,
        });
    }
    Limit(value) {
        const limit = value;
        return new RelationBuilder(this._extends, 
        // @ts-expect-error
        {
            ...this,
            limit,
        });
    }
    Order(...args) {
        const order = QUERY_INPUT_TRANSFORMERS().order(this, ...args);
        return new RelationBuilder(this._extends, 
        // @ts-expect-error
        {
            ...this,
            order,
        });
    }
    Include(alias, queryExt) {
        if (typeof queryExt === 'function') {
            queryExt = queryExt(relationBuilder);
        }
        const include = QUERY_INPUT_TRANSFORMERS().include(this, alias, queryExt);
        return new RelationBuilder(this._extends, 
        // @ts-expect-error
        {
            ...this,
            include,
        });
    }
    SubqueryOne(alias, subquery) {
        if (typeof subquery === 'function') {
            subquery = subquery(queryBuilder);
        }
        const include = QUERY_INPUT_TRANSFORMERS().include(this, alias, {
            subquery,
            cardinality: 'one',
        });
        return new RelationBuilder(this._extends, {
            ...this,
            include,
        });
    }
    SubqueryMany(alias, subquery) {
        if (typeof subquery === 'function') {
            subquery = subquery(queryBuilder);
        }
        const include = QUERY_INPUT_TRANSFORMERS().include(this, alias, {
            subquery,
            cardinality: 'many',
        });
        return new RelationBuilder(this._extends, {
            ...this,
            include,
        });
    }
}
// /**
//  * Helper type to extract the subquery information from a relation name based on include() inputs
//  */
// export type InclusionByRName<
//   M extends Models,
//   CN extends CollectionNameFromModels<M>,
//   RName extends RelationAttributes<M, CN>,
// > = RelationSubquery<
//   M,
//   ToQuery<M, RefQuery<M, CN, RName>>,
//   Ref<M, CN, RName>['cardinality']
// >;
// /**
//  * A collection query with just allowed params for a subquery in an include() clause
//  */
// export type IncludeSubquery<
//   M extends Models,
//   CN extends CollectionNameFromModels<M>,
// > = Pick<
//   CollectionQueryDefault<M, CN>,
//   'select' | 'order' | 'where' | 'limit' | 'include'
// >;
/**
 * E.g. where(undefined)
 */
function isInputNoOp(args) {
    return Array.isArray(args) && args[0] === undefined;
}
/**
 * E.g. where("id", "=", "123")
 */
function isInputSpreadFilter(args) {
    return isFilterStatement(args);
}
/**
 * E.g. where(["id", "=", "123"], more filters)
 */
function isInputSpreadClauses(args) {
    return Array.isArray(args) && args.every((arg) => isWhereFilter(arg));
}
/**
 *  E.g. where([["id", "=", "123"], ["name", "=", "foo"]])
 */
function isInputClauseGroup(args) {
    return args.length === 1 && isInputSpreadClauses(args[0]);
}
export const QUERY_INPUT_TRANSFORMERS = () => ({
    where: (q, ...args) => {
        let newWhere = [];
        if (isInputNoOp(args))
            return q.where ?? [];
        if (isInputSpreadFilter(args)) {
            newWhere = [args];
        }
        else if (isInputSpreadClauses(args)) {
            newWhere = args;
        }
        else if (isInputClauseGroup(args)) {
            newWhere = args[0];
        }
        else {
            throw new QueryClauseFormattingError('where', args);
        }
        return [...(q.where ?? []), ...newWhere];
    },
    order: (q, ...args) => {
        if (!args[0])
            return q.order ?? [];
        let newOrder = [];
        /**
         * E.g. order("id", "ASC")
         */
        if (args.length === 2 &&
            args.every((arg) => typeof arg === 'string')) {
            newOrder = [[...args]];
        }
        else if (
        /**
         * E.g. order([["id", "ASC"], ["name", "DESC"]])
         */
        args.length === 1 &&
            args[0] instanceof Array &&
            args[0].every((arg) => arg instanceof Array)) {
            newOrder = args[0];
        }
        else if (args.every((arg) => arg instanceof Array)) {
            /**
             * E.g. order(["id", "ASC"], ["name", "DESC"])
             */
            newOrder = args;
        }
        else {
            throw new QueryClauseFormattingError('order', args);
        }
        return [...(q.order ?? []), ...newOrder];
    },
    include(q, alias, query) {
        // TODO: include should be typed as a set of subqueries
        return {
            ...q.include,
            // Set to null so the inclusion of the key can be serialized
            [alias]: query ?? null,
        };
    },
    after(q, after, inclusive) {
        if (!after)
            return undefined;
        if (!q.order)
            throw new AfterClauseWithNoOrderError(after);
        const orderAttributes = q.order.map((o) => o[0]);
        if (after instanceof Array)
            return [after, inclusive ?? false];
        if (typeof after === 'object') {
            return [
                // Maybe even sunset this and only use ValueCursor format
                orderAttributes.map((attr) => ValuePointer.Get(after, attr)),
                inclusive ?? false,
            ];
        }
        throw new QueryClauseFormattingError('after', after);
    },
});
//# sourceMappingURL=query-builder.js.map