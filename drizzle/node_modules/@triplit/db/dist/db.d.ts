import { DBChanges, Triple, KVStore, EntitySyncStore, Timestamp, PreparedQuery } from './types.js';
import { HybridLogicalClock } from './hybrid-clock.js';
import { ViewEntity } from './query-engine.js';
import { IVM } from './ivm/index.js';
import { DBSession } from './session.js';
import { TypeConverters } from './schema/converters.js';
import { Logger } from '@triplit/logger';
import { CollectionNameFromModels, FailedSchemaChange, Models, Roles, SchemaChange } from './schema/index.js';
import { CollectionQuery, FetchResult, QueryResultCardinality, SchemaQuery } from './query/types/index.js';
import { QueryBuilder } from './query/query-builder.js';
import { ClearOptions, DBOptions, EntityWriteOptions, FetchOptions, OnCommitCallback, ReadModel, SchemaChangeListener, SubscriptionResultsCallback, TransactCallback, TransactOptions, UpdatePayload, WriteModel } from './types/db.js';
export type DBSchema<M extends Models<M> = Models> = {
    collections: M;
    roles?: Roles;
};
export declare class DB<M extends Models<M> = Models, E extends EntitySyncStore = EntitySyncStore> {
    entityStore: E;
    clock: HybridLogicalClock;
    session: DBSession | undefined;
    globalVars: Record<string, any>;
    logger: Logger;
    subscribedQueries: Map<string, {
        query: CollectionQuery;
        resultsListeners: Set<SubscriptionResultsCallback>;
        lastResult?: any[];
    }>;
    readonly clientId: string;
    ivm: IVM;
    schema: DBSchema<M> | undefined;
    onCommitListeners: Set<OnCommitCallback>;
    readonly kv: KVStore;
    private typeConverters?;
    constructor(options?: DBOptions<M, E>);
    static getSchemaFromStorage(kv: KVStore): Promise<DBSchema | undefined>;
    getSchema(): DBSchema<M> | undefined;
    subscribe<Q extends SchemaQuery<M>>(query: Q, onResults: SubscriptionResultsCallback<M, Q>, onError?: (error: Error) => void, options?: FetchOptions & {
        queryState?: {
            timestamp: Timestamp;
            entityIds: Record<string, string[]>;
        };
        queryKey?: string;
    }): () => void;
    subscribeRaw(query: PreparedQuery, onResults: SubscriptionResultsCallback, onError?: (error: Error) => void, options?: {
        queryState?: {
            timestamp: Timestamp;
            entityIds: Record<string, string[]>;
        };
        queryKey?: string;
    }): () => void;
    /**
     * @deprecated TODO remove
     */
    subscribeWithChanges<Q extends SchemaQuery<M>>(query: Q, onResults: (args: {
        results: FetchResult<M, Q, 'many'>;
        changes: DBChanges;
    }) => void, onError?: (error: Error) => void, options?: FetchOptions): () => void;
    /**
     * @deprecated TODO remove
     */
    subscribeChanges<Q extends SchemaQuery<M>>(query: Q, onResults: (results: DBChanges, queryId?: string) => void | Promise<void>, options?: FetchOptions & {
        queryState?: {
            timestamp: Timestamp;
            entityIds: Record<string, string[]>;
        };
    } & {
        queryKey?: string;
        errorCallback?: (error: Error) => void;
    }): () => void;
    fetch<Q extends SchemaQuery<M>>(query: Q, options?: FetchOptions): Promise<FetchResult<M, Q, 'many'>>;
    rawFetch(query: PreparedQuery, vars?: any): Promise<ViewEntity[]>;
    /**
     * @deprecated
     * @param query
     * @param options
     * @returns
     */
    fetchChanges(query: CollectionQuery<M>, options?: FetchOptions): Promise<DBChanges>;
    fetchOne<Q extends SchemaQuery<M>>(query: Q, options?: FetchOptions): Promise<FetchResult<M, Q, 'one'>>;
    fetchById<CN extends CollectionNameFromModels<M>>(collectionName: CN, id: string, options?: FetchOptions): Promise<FetchResult<M, {
        collectionName: CN;
    }, 'one'>>;
    insert<CN extends CollectionNameFromModels<M>>(collectionName: CN, data: WriteModel<M, CN>, options?: EntityWriteOptions): Promise<ReadModel<M, CN>>;
    update<CN extends CollectionNameFromModels<M>>(collectionName: CN, id: string, data: UpdatePayload<M, CN>, options?: EntityWriteOptions): Promise<void>;
    delete<CN extends CollectionNameFromModels<M>>(collectionName: CN, id: string, options?: EntityWriteOptions): Promise<void>;
    onCommit(callback: OnCommitCallback): () => void;
    updateQueryViews(): Promise<void>;
    broadcastToQuerySubscribers(): void;
    transact<Output>(callback: TransactCallback<M, Output>, options?: TransactOptions): Promise<Output>;
    applyChanges(changes: DBChanges, options: EntityWriteOptions): Promise<void>;
    applyChangesWithTimestamp(changes: DBChanges, timestamp: Timestamp, options: EntityWriteOptions): Promise<void>;
    getCollectionStats(): Promise<Map<string, number>>;
    overrideSchema(newSchema: DBSchema, options?: {
        failOnBackwardsIncompatibleChange?: boolean;
    }): Promise<SchemaChange>;
    private _overrideSchema;
    setMetadata(key: string[], value: any): Promise<void>;
    getMetadata<T = any>(key: string[]): Promise<T | undefined>;
    /**
     * Runs a transaction on the kv store that updates the schema
     * This WILL NOT perform any validation or compatibility checks, so ensure the update is valid beforehand
     */
    private updateSchema;
    /**
     * WARNING: (I think) using `this` in the constructor will not pick up the proxy information created here
     * Example: new IVM(this) // db.session will be undefined
     */
    withSessionVars(variables: Record<string, any>): DB<M, E>;
    schemaChangeListeners: SchemaChangeListener[];
    onSchemaChange(callback: SchemaChangeListener): () => void;
    query<CN extends CollectionNameFromModels<M>>(collectionName: CN): QueryBuilder<M, CN, import("./types.js").WithInclusion<CollectionQuery<M, CN>, {}>>;
    Query<CN extends CollectionNameFromModels<M>>(collectionName: CN): QueryBuilder<M, CN, import("./types.js").WithInclusion<CollectionQuery<M, CN>, {}>>;
    clear(options?: ClearOptions): Promise<void>;
    updateGlobalVariables(vars: Record<string, any>): void;
    get systemVars(): {
        $global: Record<string, any>;
        $session: Record<string, any>;
    };
    private validateEntityChange;
    private checkWritePermission;
}
export declare function changesToTriples(changes: DBChanges, timestamp: Timestamp): Triple[];
export type DBInitializationEvent = {
    type: 'ERROR';
    error: Error;
} | {
    type: 'SCHEMA_UPDATE_FAILED';
    change: FailedSchemaChange;
} | {
    type: 'SUCCESS';
    change: SchemaChange | undefined;
};
/**
 * Creates a new database instance and performs and necessary async operations as part of the initialization.
 * It is guaranteed to return a DB instance, however it may throw an error if a DB instance could not be created.
 * The event parameter will indicate the result of the initialization process, some notable cases include:
 * - if the provided schema cannot be applied, an instance with the old schema will be returned
 */
export declare function createDB<M extends Models<M> = Models, E extends EntitySyncStore = EntitySyncStore>(options: DBOptions<M, E> & {
    failOnBackwardsIncompatibleChange?: boolean;
}): Promise<{
    db: DB<M, E>;
    event: DBInitializationEvent;
}>;
export declare function applyProjectionsAndConversions(results: ViewEntity[] | ViewEntity | null, query: PreparedQuery, cardinality: QueryResultCardinality, typeConverters?: TypeConverters): any[] | any;
