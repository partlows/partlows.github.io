import { useCallback, useEffect, useMemo, useRef, useState, useSyncExternalStore, } from 'react';
import { getDisabledSubscriptionState, isSubscriptionEnabled, getInitialSubscriptionState, } from '@triplit/client';
export function createStateSubscription(client, query, options) {
    if (!isSubscriptionEnabled(options)) {
        const disabledState = getDisabledSubscriptionState();
        return [() => () => { }, () => disabledState];
    }
    let latestValue = getInitialSubscriptionState();
    return [
        (callback) => {
            return client.subscribeWithStatus(query, (newVal) => {
                latestValue = newVal;
                callback();
            }, options);
        },
        () => latestValue,
    ];
}
/**
 * A React hook that subscribes to a query
 *
 * @param client - The client instance to query with
 * @param query - The query to subscribe to
 * @param options - Additional options for the subscription
 * @param options.localOnly - If true, the subscription will only use the local cache. Defaults to false.
 * @param options.onRemoteFulfilled - An optional callback that is called when the remote query has been fulfilled.
 * @returns An object containing the fetching state, the result of the query, and any error that occurred
 */
export function useQuery(client, query, options) {
    const stringifiedQuery = query && JSON.stringify(query);
    const [subscribe, snapshot] = useMemo(() => createStateSubscription(client, query, options), [stringifiedQuery, client, options?.localOnly, options?.enabled]);
    const getServerSnapshot = useCallback(() => {
        return snapshot();
    }, [snapshot]);
    return useSyncExternalStore(subscribe, snapshot, getServerSnapshot);
}
/**
 * A React hook that subscribes to a query in a paginated manner
 *
 * @param client - The client instance to query with
 * @param query - The query, with a limit set, to subscribe to
 * @param options - Additional options for the subscription
 * @param options.localOnly - If true, the subscription will only use the local cache. Defaults to false.
 * @param options.onRemoteFulfilled - An optional callback that is called when the remote query has been fulfilled.
 * @returns An object containing functions to load the previous and next pages, the fetching state, the result of the query, and any error that occurred
 */
export function usePaginatedQuery(client, query, options) {
    const [hasNextPage, setHasNextPage] = useState(false);
    const [hasPreviousPage, setHasPreviousPage] = useState(false);
    const [results, setResults] = useState(undefined);
    const [error, setError] = useState(undefined);
    const [fetching, setFetching] = useState(true);
    const [fetchingPage, setFetchingPage] = useState(false);
    const nextPageRef = useRef();
    const prevPageRef = useRef();
    const disconnectRef = useRef();
    const stringifiedQuery = query && JSON.stringify(query);
    useEffect(() => {
        const { unsubscribe, nextPage, prevPage } = client.subscribeWithPagination(query, (results, info) => {
            setFetching(false);
            setError(undefined);
            setFetchingPage(false);
            setHasNextPage(info.hasNextPage);
            setHasPreviousPage(info.hasPreviousPage);
            // TODO: fix types to match
            setResults(results);
        }, (error) => {
            setFetching(false);
            setFetchingPage(false);
            setError(error);
        }, options);
        nextPageRef.current = nextPage;
        prevPageRef.current = prevPage;
        disconnectRef.current = unsubscribe;
        return () => {
            unsubscribe();
        };
    }, [stringifiedQuery, client]);
    const nextPage = useCallback(() => {
        setFetchingPage(true);
        nextPageRef.current?.();
    }, []);
    const prevPage = useCallback(() => {
        setFetchingPage(true);
        prevPageRef.current?.();
    }, []);
    const disconnect = useCallback(() => {
        disconnectRef.current?.();
    }, []);
    return {
        results,
        fetching,
        fetchingPage,
        error,
        hasNextPage,
        hasPreviousPage,
        nextPage,
        prevPage,
        disconnect,
    };
}
/**
 * A React hook that subscribes to a query with an initial limit and allows for loading more results
 *
 * @param client - The client instance to query with
 * @param query - The query, with a limit set, to subscribe to
 * @param options - Additional options for the subscription
 * @param options.localOnly - If true, the subscription will only use the local cache. Defaults to false.
 * @param options.onRemoteFulfilled - An optional callback that is called when the remote query has been fulfilled. * @returns An object containing a function to load more results, the fetching state, the result of the query, and any error that occurred
 */
export function useInfiniteQuery(client, query, options) {
    const stringifiedQuery = query && JSON.stringify(query);
    const [hasMore, setHasMore] = useState(false);
    const [results, setResults] = useState(undefined);
    const [error, setError] = useState(undefined);
    const [fetching, setFetching] = useState(true);
    const [fetchingRemote, setFetchingRemote] = useState(client.connectionStatus !== 'CLOSED');
    const [fetchingMore, setFetchingMore] = useState(false);
    const loadMoreRef = useRef();
    const disconnectRef = useRef();
    const hasResponseFromServer = useRef(false);
    useEffect(() => {
        const unsub = client.onConnectionStatusChange((status) => {
            if (status === 'CLOSING' || status === 'CLOSED') {
                setFetchingRemote(false);
                return;
            }
            if (status === 'OPEN' && hasResponseFromServer.current === false) {
                setFetchingRemote(true);
                return;
            }
        }, true);
        return () => {
            unsub();
        };
    }, [stringifiedQuery, client]);
    useEffect(() => {
        const { unsubscribe, loadMore } = client.subscribeWithExpand(query, (results, info) => {
            setFetching(false);
            setError(undefined);
            setFetchingMore(false);
            setHasMore(info.hasMore);
            setResults(
            // TODO: fix types to match
            results);
        }, (error) => {
            setFetching(false);
            setFetchingRemote(false);
            setFetchingMore(false);
            setError(error);
        }, {
            ...(options ?? {}),
            onRemoteFulfilled: () => {
                hasResponseFromServer.current = true;
                setFetchingRemote(false);
            },
        });
        loadMoreRef.current = loadMore;
        disconnectRef.current = unsubscribe;
        return () => {
            unsubscribe();
        };
    }, [stringifiedQuery, client]);
    const loadMore = useCallback((pageSize) => {
        setFetchingMore(true);
        loadMoreRef.current?.(pageSize);
    }, []);
    const disconnect = useCallback(() => {
        disconnectRef.current?.();
    }, []);
    return {
        results,
        fetching,
        fetchingRemote,
        fetchingMore,
        error,
        hasMore,
        loadMore,
        disconnect,
    };
}
